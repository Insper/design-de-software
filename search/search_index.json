{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Design de Software \u00b6 Bem vindo ao curso de Design de Software 2020/2. Professores Andrew Kurauchi Luciano Soares Professora Auxiliar B\u00e1rbara Agena NINJAs Evandro Fontana Romeiro (Turma A) Diego Saragoza da Silva (Turma B) Gabriella Escobar Cukier (Turmas A e B) Servidor de Exerc\u00edcios Uma conta deve ter sido criada para voc\u00ea usando o seu nome de usu\u00e1rio Insper. Por exemplo, se o seu usu\u00e1rio Insper \u00e9 fulano123 , o seu login no servidor ser\u00e1 fulano123 e a sua senha tamb\u00e9m ser\u00e1 fulano123 . Altere sua senha depois que fizer o primeiro login . Entrar no Servidor Objetivos de Aprendizagem \u00b6 Ao final da disciplina o aluno ser\u00e1 capaz de: Desenvolver programas de computador Identificar e desenhar estrat\u00e9gias algor\u00edtmicas computacionais Atuar em uma equipe autogerenciada de desenvolvimento Avalia\u00e7\u00e3o \u00b6 A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, exerc\u00edcios programa (EP) e um projeto final. Os objetivos de aprendizagem s\u00e3o distribu\u00eddos entre os instrumentos de avalia\u00e7\u00e3o da seguinte maneira: Provas EP Projeto Desenvolver programas de computador X X X Identificar e desenhar estrat\u00e9gias algor\u00edtmicas computacionais X X X Atuar em uma equipe autogerenciada de desenvolvimento X X Os pesos de cada instrumento de avalia\u00e7\u00e3o \u00e9 apresentado a seguir: Nota Individual (NI): provas compostas por exerc\u00edcios pr\u00e1ticos de programa\u00e7\u00e3o; [10%] Quiz [40%] Prova Intermedi\u00e1ria (PI) [50%] Prova Final (PF) Prova Substitutiva A prova substitutiva engloba todo o conte\u00fado e pode ser realizada apenas pelos alunos que n\u00e3o tiverem realizado a PI ou PF. O quiz N\u00c3O possui sub. Nota em Grupo (NG): ser\u00e3o avaliados por rubricas e ser\u00e1 atribu\u00eddo um conceito [20%] Exerc\u00edcios Programa (EP): exerc\u00edcios que integram os conte\u00fados das aulas. Podem ser feitos em duplas. [80%] Projeto Final: projeto em Python utilizando uma biblioteca gr\u00e1fica (PyGame) para o desenvolvimento de uma aplica\u00e7\u00e3o interativa. Reprova\u00e7\u00e3o por APS Caso o aluno n\u00e3o entregue o EP, ser\u00e1 reprovado por APS. N\u00e3o existe recupera\u00e7\u00e3o (trabalho extra, prova extra, etc.) Ser\u00e1 utilizada a tabela oficial do Blackboard para a convers\u00e3o de conceito para nota, quando necess\u00e1rio: Conceito Nota A 9 B 7 C 5 D 4 I 0 A m\u00e9dia final \u00e9 dada por M\u00e9dia Final NI <5 \u22655 NG <5 min(NI,NG) min(NI,NG) \u22655 min(NI,NG) (NI,NG)/2","title":"Home"},{"location":"#design-de-software","text":"Bem vindo ao curso de Design de Software 2020/2. Professores Andrew Kurauchi Luciano Soares Professora Auxiliar B\u00e1rbara Agena NINJAs Evandro Fontana Romeiro (Turma A) Diego Saragoza da Silva (Turma B) Gabriella Escobar Cukier (Turmas A e B) Servidor de Exerc\u00edcios Uma conta deve ter sido criada para voc\u00ea usando o seu nome de usu\u00e1rio Insper. Por exemplo, se o seu usu\u00e1rio Insper \u00e9 fulano123 , o seu login no servidor ser\u00e1 fulano123 e a sua senha tamb\u00e9m ser\u00e1 fulano123 . Altere sua senha depois que fizer o primeiro login .","title":"Design de Software"},{"location":"#objetivos-de-aprendizagem","text":"Ao final da disciplina o aluno ser\u00e1 capaz de: Desenvolver programas de computador Identificar e desenhar estrat\u00e9gias algor\u00edtmicas computacionais Atuar em uma equipe autogerenciada de desenvolvimento","title":"Objetivos de Aprendizagem"},{"location":"#avaliacao","text":"A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, exerc\u00edcios programa (EP) e um projeto final. Os objetivos de aprendizagem s\u00e3o distribu\u00eddos entre os instrumentos de avalia\u00e7\u00e3o da seguinte maneira: Provas EP Projeto Desenvolver programas de computador X X X Identificar e desenhar estrat\u00e9gias algor\u00edtmicas computacionais X X X Atuar em uma equipe autogerenciada de desenvolvimento X X Os pesos de cada instrumento de avalia\u00e7\u00e3o \u00e9 apresentado a seguir: Nota Individual (NI): provas compostas por exerc\u00edcios pr\u00e1ticos de programa\u00e7\u00e3o; [10%] Quiz [40%] Prova Intermedi\u00e1ria (PI) [50%] Prova Final (PF) Prova Substitutiva A prova substitutiva engloba todo o conte\u00fado e pode ser realizada apenas pelos alunos que n\u00e3o tiverem realizado a PI ou PF. O quiz N\u00c3O possui sub. Nota em Grupo (NG): ser\u00e3o avaliados por rubricas e ser\u00e1 atribu\u00eddo um conceito [20%] Exerc\u00edcios Programa (EP): exerc\u00edcios que integram os conte\u00fados das aulas. Podem ser feitos em duplas. [80%] Projeto Final: projeto em Python utilizando uma biblioteca gr\u00e1fica (PyGame) para o desenvolvimento de uma aplica\u00e7\u00e3o interativa. Reprova\u00e7\u00e3o por APS Caso o aluno n\u00e3o entregue o EP, ser\u00e1 reprovado por APS. N\u00e3o existe recupera\u00e7\u00e3o (trabalho extra, prova extra, etc.) Ser\u00e1 utilizada a tabela oficial do Blackboard para a convers\u00e3o de conceito para nota, quando necess\u00e1rio: Conceito Nota A 9 B 7 C 5 D 4 I 0 A m\u00e9dia final \u00e9 dada por M\u00e9dia Final NI <5 \u22655 NG <5 min(NI,NG) min(NI,NG) \u22655 min(NI,NG) (NI,NG)/2","title":"Avalia\u00e7\u00e3o"},{"location":"ep/","text":"Exerc\u00edcio Programa: Bacar\u00e1 Simplificado \u00b6 Data de entrega: 06/10/2020, via GitHub Este trabalho pode ser feito individualmente ou em duplas Introdu\u00e7\u00e3o \u00b6 Neste Exerc\u00edcio Programa (EP) voc\u00eas desenvolver\u00e3o um jogo de Bacar\u00e1 simplificado, que \u00e9 um jogo r\u00e1pido de cartas presente em muitos cassinos. O jogo consiste em partidas onde se pode apostar se o jogador ou o banco conseguem uma soma de cartas mais pr\u00f3xima de 9, na pr\u00e1tica n\u00e3o \u00e9 uma disputa, voc\u00ea tanto pode apostar na \u00e1rea do jogador, como na do banco. A \u00fanica intera\u00e7\u00e3o do jogador \u00e9 apostar em quem ser\u00e1 o vencedor da partida (jogador, banco ou empate). Todo o restante do jogo \u00e9 realizado pela mesa de acordo com as regras simplificadas apresentadas abaixo (elas n\u00e3o cobrem todas as possibilidades de um jogo real). As apostas ser\u00e3o sempre de n\u00fameros inteiros positivos de fichas e o jogador come\u00e7a com uma quantidade de fichas definida por voc\u00ea. Regras \u00b6 Inicialmente o jogador realiza sua aposta colocando a quantidade de fichas que quiser (no m\u00e1ximo as fichas que o jogador possui naquele momento) em quem acredita ser o vencedor (jogador, banco ou empate). A partir desse momento a mesa realiza todo o restante do jogo automaticamente. \u00c9 utilizado um baralho completo, com 52 cartas. Inicialmente a mesa embaralha as cartas e distribui duas para o jogador e duas para o banco. Se a soma das cartas ( veja as regras da soma das cartas aqui ) do jogador ou do banco for igual a 8 ou 9 o jogo termina e as apostas s\u00e3o pagas ( veja as regras do pagamento das apostas aqui ). Se a soma das cartas tanto do jogador quanto do banco forem diferentes de 8 ou 9, a mesa decide se distribuir\u00e1 uma terceira carta a cada um de acordo com as regras a seguir, come\u00e7ando pelo jogador e depois distribuindo a carta do banco: Se a soma das cartas for 6 ou 7, n\u00e3o distribui mais uma carta; Se a soma das cartas for 5 ou menos, distribui mais uma carta e a soma \u00e9 recalculada. Alguns exemplos: Se o jogador obteve as cartas: e o banco obteve as cartas: O jogador recebe mais uma carta, pois a sua soma foi 5. O banco n\u00e3o recebe nenhuma carta, pois sua soma j\u00e1 \u00e9 7. Soma das cartas \u00b6 Os valores das cartas seguem a tabela a seguir: Carta Valor A 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 0 J 0 Q 0 K 0 Importante: se a soma das cartas for maior ou igual a 10, considera-se apenas a unidade. Exemplos: Soma 7 = 1 + 6 7 = 1 + 6 : Soma 2 2 ( 8 + 0 + 4 = 12 8 + 0 + 4 = 12 , considerando apenas a unidade): Soma 7 7 : Pagamento das apostas \u00b6 O jogador perde as fichas apostadas se n\u00e3o tiver apostado no vencedor. Caso contr\u00e1rio, a quantidade de fichas recebidas depende de quem foi o vencedor da partida: Jogador : se o jogador venceu a partida (obteve a soma mais pr\u00f3xima de 9), a mesa paga a mesma quantidade de fichas apostadas. Por exemplo, se o jogador apostou 10 fichas, ele receber\u00e1 outras 10 fichas. Banco : se o banco venceu a partida, a mesa paga 95% das fichas apostadas. Por exemplo, se o jogador apostou 20 fichas, ele receber\u00e1 outras 19. Caso o numero n\u00e3o seja inteiro o jogador receber\u00e1 as fichas sempre arredondando para baixo. Por exemplo, se o jogador apostou 25 fichar, ele vai receber s\u00f3 23 a mais. Empate : se ocorreu um empate, e o jogador apostou no empate, a mesa paga 8 vezes a quantidade de fichas apostadas. Por exemplo, se o jogador apostou 10 fichas, ele receber\u00e1 outras 80.0 Mais exemplos \u00b6 Exemplo 1 \u00b6 A seguir apresentamos exemplos de uma partida completa: O jogador possui 100 fichas; Aposta 10 fichas no banco; A mesa distribui as cartas. O jogador recebe: O banco recebe: Como a soma das cartas do jogador \u00e9 igual a 8, a partida termina; O jogador perde as 10 fichas apostadas, pois apostou que o banco venceria. Nessa partida, se o jogador tivesse apostado que ele seria o vencedor, ele ganharia mais 10 fichas, ficando com 110 fichas ao final da partida. Exemplo 2 \u00b6 O jogador possui 100 fichas; Aposta 20 fichas no jogador; A mesa distribui as cartas. O jogador recebe: O banco recebe: Como a soma das cartas do jogador \u00e9 igual a 7, ele n\u00e3o recebe mais cartas; Como a soma das cartas do banco \u00e9 igual a 2, ele recebe mais uma carta. Agora o banco possui as seguintes cartas: A soma das cartas do banco \u00e9 igual a 7. Ocorreu um empate; O jogador perde as 20 fichas apostadas, pois apostou que ele venceria. Se o jogador tivesse apostado em empate, ele receberia mais 160 fichas, ficando com 260 fichas ao final da partida. Exemplo 3 \u00b6 O jogador possui 100 fichas; Aposta 40 fichas no empate; A mesa distribui as cartas. O jogador recebe: O banco recebe: Como a soma das cartas do jogador \u00e9 igual a 0, ele recebe mais uma carta. Agora o jogador possui as seguintes cartas: A soma das cartas do jogador \u00e9 igual a 5; Como a soma das cartas do banco \u00e9 igual a 3, ele recebe mais uma carta. Agora o banco possui as seguintes cartas: A soma das cartas do banco \u00e9 igual a 9. O banco venceu; O jogador perde as 40 fichas apostadas, pois apostou que ocorreria empate. Se o jogador tivesse apostado no banco, ele receberia mais 38 fichas, ficando com 138 fichas ao final da partida. Regras avan\u00e7adas \u00b6 Importante : as regras a seguir devem ser implementadas para se obter conceito maior ou igual a B. M\u00faltiplos baralhos \u00b6 Regras alternativas do Bacar\u00e1 permitem o uso de 6 ou 8 baralhos. Assim, ao inv\u00e9s de 52 cartas s\u00e3o utilizadas 312 ou 416 cartas, respectivamente. Todo o restante do jogo permanece o mesmo. M\u00faltiplos jogadores \u00b6 \u00c9 poss\u00edvel que mais de um jogador participe das apostas. Cada jogador aposta a quantidade de fichas que quiser em quem acreditar ser o vencedor. As cartas de jogador s\u00e3o as mesmas para todos. Ou seja, \u00e9 equivalente a ocorrerem diversos jogos ao mesmo tempo, um para cada jogador, mas as cartas sorteadas s\u00e3o as mesmas em todas as mesas. Ao final da partida cada jogador recebe ou paga o resultado das suas apostas. Comiss\u00e3o da casa \u00b6 Em cassinos \u00e9 comum existir uma comiss\u00e3o sobre as apostas recebidas no Bacar\u00e1. Se o jogador perde a aposta ele n\u00e3o paga nada de comiss\u00e3o nessa partida. Entretanto, se ele ganha a aposta, \u00e9 necess\u00e1rio pagar uma porcentagem do que ele for receber para a casa. Por exemplo, se a taxa de comiss\u00e3o for 1% e o jogador for receber 10 fichas por ter vencido a aposta, ele receber\u00e1 9 fichas, pois dever\u00e1 pagar 1 como comiss\u00e3o. As taxas de comiss\u00e3o dependem de quem foi o vencedor da partida (jogador, banco ou empate) e da quantidade de baralhos. A tabela a seguir resume as taxas para cada caso: Vencedor 1 baralho 6 baralhos 8 baralhos Jogador 1.29% 1.24% 1.24% Banco 1.01% 1.06% 1.06% Empate 15.75% 14.44% 14.36% Por exemplo, se o jogador apostou 10.000 10.000 fichas no banco em um jogo com 6 baralhos e o banco foi o vencedor da partida, ele receber\u00e1 10.000 - 10.000\\cdot 0,0106 = 9894 10.000 - 10.000\\cdot 0,0106 = 9894 fichas como pagamento. Mais regras para a distribui\u00e7\u00e3o da terceira carta \u00b6 As regras apresentadas anteriormente s\u00e3o simplificadas. Uma partida real de Bacar\u00e1 possui regras um pouco mais complexas para decidir se a terceira carta ser\u00e1 distribu\u00edda. Para as regras a seguir \u00e9 necess\u00e1rio assumir que a decis\u00e3o de distribuir ou n\u00e3o a terceira carta do jogador ser\u00e1 tomada antes da decis\u00e3o de distribuir a terceira carta do banco. A regra para a terceira carta do jogador n\u00e3o muda. Se a soma das suas duas cartas for igual ou menor a 5 e a soma das cartas do banco for diferente de 8 e 9, o jogador recebe a terceira carta. A regra para a terceira carta do banco depende da soma das suas duas cartas e da terceira carta do jogador: Se a soma das duas cartas do banco for igual a 6 ou mais, ele n\u00e3o recebe a terceira carta; Se o jogador n\u00e3o recebeu uma terceira carta e a soma das duas cartas do banco for menor ou igual a 5, ele recebe a terceira carta; Se o jogador recebeu uma terceira carta e a soma das duas cartas do banco for menor ou igual a 5, ele pode ou n\u00e3o receber a terceira carta e a decis\u00e3o \u00e9 tomada de acordo com a tabela a seguir (cada coluna representa o valor da terceira carta recebida pelo jogador, de 0 a 9, se o valor for S significa que a terceira carta do banco \u00e9 distribu\u00edda, se for N o banco n\u00e3o recebe uma terceira carta): Soma do banco 0 1 2 3 4 5 6 7 8 9 0 S S S S S S S S S S 1 S S S S S S S S S S 2 S S S S S S S S S S 3 S S S S S S S S N S 4 N N S S S S S S N N 5 N N N N S S S S N N 6 N N N N N N S S N N 7 N N N N N N N N N N Por exemplo, se a terceira carta do jogador foi 3 e a soma das duas cartas do banco \u00e9 5, o banco n\u00e3o recebe a terceira carta. Se a terceira carta do jogador foi 2 e a soma das duas cartas do banco \u00e9 4, o banco recebe a terceira carta. Rubricas dos Objetivos de Aprendizagem \u00b6 Os objetivos de aprendizagem e as correspondentes rubricas de avalia\u00e7\u00e3o s\u00e3o os seguintes: Objetivo: Desenvolver programas de computador I D C B at\u00e9 A+ N\u00e3o implementou nem as regras b\u00e1sicas . Implementou algumas das regras b\u00e1sicas, mas o c\u00f3digo n\u00e3o funciona (d\u00e1 erro ao executar). Implementou todas as regras b\u00e1sicas , mas n\u00e3o funciona para alguns casos. Funciona para todas as regras b\u00e1sicas e implementou as regras avan\u00e7adas . Cada regra avan\u00e7ada implementada corretamente adiciona meio conceito. Objetivo: Atuar em uma equipe gerenciada por m\u00e9todos \u00e1geis I D C B / A N\u00e3o entregou pelo git. C\u00f3digo entregue em um ou poucos commits . Caso em dupla n\u00e3o demonstraram que ambos os alunos contribu\u00edram de modo substancial. V\u00e1rios recursos no mesmo commit . Caso em dupla: balan\u00e7o de c\u00f3digo desenvolvido \u00e9 muito inclinado para um dos alunos. Commits cont\u00ednuos e caso em dupla balan\u00e7o adequado de esfor\u00e7os. Objetivo: Identificar e programar estrat\u00e9gias computacionais de resolu\u00e7\u00e3o de problemas pr\u00e1ticos I D C B A N\u00e3o entregou o EP. Reposit\u00f3rio n\u00e3o tem todos os arquivos necess\u00e1rios para executar o programa. Reposit\u00f3rio com arquivos ou c\u00f3digo desnecess\u00e1rio ou c\u00f3digo estruturado e documentado de forma confusa. C\u00f3digo com estrutura\u00e7\u00e3o e documenta\u00e7\u00e3o razo\u00e1vel. C\u00f3digo bem estruturado, modularizado e documentado. A nota do projeto ser\u00e1 dada pelo seguinte: Se a equipe obteve conceito I ou D em algum objetivo de aprendizado, o conceito final ser\u00e1 dado pelo menor conceito obtido. Por exemplo: se todos o recursos foram implementadas, e o c\u00f3digo est\u00e1 impec\u00e1vel, mas um aluno fez tudo (conforme evidenciado no git), a nota ser\u00e1 D ou I (N\u00e3o adianta argumentar que foi feito tudo no computador de um aluno s\u00f3, o objetivo aqui \u00e9 que todos saibam trabalhar de forma colaborativa usando uma ferramenta como o git). Se todos os conceitos forem iguais ou superiores a C, o conceito final ser\u00e1 obtido pela m\u00e9dia aritm\u00e9tica dos conceitos obtidos para os objetivos de aprendizado. O que voc\u00ea deve entregar \u00b6 O programa \u00b6 O seu EP consistir\u00e1 de um programa em Python que implementa o jogo Bacar\u00e1. Seu programa deve permitir que o jogador continue jogando enquanto tiver fichas. Se as fichas do jogador acabarem o jogo termina automaticamente. No in\u00edcio de cada partida o jogador pode decidir se continua jogando ou se deseja parar. Se ele decidir jogar, uma nova partida se inicia, perguntando o valor a ser apostado. Documenta\u00e7\u00e3o m\u00ednima \u00b6 Se no seu reposit\u00f3rio existem v\u00e1rios arquivos .py , voc\u00ea deve indicar claramente qual arquivo cont\u00e9m o seu programa (se seu reposit\u00f3rio tem s\u00f3 um arquivo .py voc\u00ea n\u00e3o tem com o que se preocupar). N\u00f3s n\u00e3o vamos ter como adivinhar qual \u00e9 o certo e nesse caso haver\u00e1 desconto de nota. Coloque um cabe\u00e7alho (coment\u00e1rios) no seu c\u00f3digo contendo, no m\u00ednimo o seguinte conte\u00fado (trocando o nome dos membros da equipe e a data): # EP - Design de Software # Equipe: Barbara Tieko e Evandro Romeiro # Data: DD/MM/2020 Como entregar \u00b6 A entrega dever\u00e1 ser feita via Git. O Git permite que voc\u00ea mantenha um hist\u00f3rico da evolu\u00e7\u00e3o do seu c\u00f3digo e o compartilhe com seus colegas de trabalho. N\u00e3o teremos uma aula para aprender a usar o Git. Essa \u00e9 uma oportunidade para colocarmos em pr\u00e1tica a habilidade de aprender a aprender. O v\u00eddeo a seguir apresenta o m\u00ednimo que voc\u00ea deve saber para entregar o projeto: https://youtu.be/xZI0BytK5GA Pode ser necess\u00e1rio consultar outras fontes para entender como utilizar o Git. Existem diversos recursos dispon\u00edveis na internet. Os professores estar\u00e3o dispon\u00edveis para tirar d\u00favidas sobre o uso do git durante os hor\u00e1rios de atendimento. Envie no Blackboard o endere\u00e7o do seu reposit\u00f3rio GitHub. Exerc\u00edcios copiados ou muito parecidos podem gerar notifica\u00e7\u00f5es de infra\u00e7\u00f5es do c\u00f3digo de \u00e9tica Insper, resultando em reprova\u00e7\u00e3o autom\u00e1tica da disciplina ou at\u00e9 mesmo jubilamento.","title":"Exerc\u00edcio Programa: Bacar\u00e1 Simplificado"},{"location":"ep/#exercicio-programa-bacara-simplificado","text":"Data de entrega: 06/10/2020, via GitHub Este trabalho pode ser feito individualmente ou em duplas","title":"Exerc\u00edcio Programa: Bacar\u00e1 Simplificado"},{"location":"ep/#introducao","text":"Neste Exerc\u00edcio Programa (EP) voc\u00eas desenvolver\u00e3o um jogo de Bacar\u00e1 simplificado, que \u00e9 um jogo r\u00e1pido de cartas presente em muitos cassinos. O jogo consiste em partidas onde se pode apostar se o jogador ou o banco conseguem uma soma de cartas mais pr\u00f3xima de 9, na pr\u00e1tica n\u00e3o \u00e9 uma disputa, voc\u00ea tanto pode apostar na \u00e1rea do jogador, como na do banco. A \u00fanica intera\u00e7\u00e3o do jogador \u00e9 apostar em quem ser\u00e1 o vencedor da partida (jogador, banco ou empate). Todo o restante do jogo \u00e9 realizado pela mesa de acordo com as regras simplificadas apresentadas abaixo (elas n\u00e3o cobrem todas as possibilidades de um jogo real). As apostas ser\u00e3o sempre de n\u00fameros inteiros positivos de fichas e o jogador come\u00e7a com uma quantidade de fichas definida por voc\u00ea.","title":"Introdu\u00e7\u00e3o"},{"location":"ep/#regras","text":"Inicialmente o jogador realiza sua aposta colocando a quantidade de fichas que quiser (no m\u00e1ximo as fichas que o jogador possui naquele momento) em quem acredita ser o vencedor (jogador, banco ou empate). A partir desse momento a mesa realiza todo o restante do jogo automaticamente. \u00c9 utilizado um baralho completo, com 52 cartas. Inicialmente a mesa embaralha as cartas e distribui duas para o jogador e duas para o banco. Se a soma das cartas ( veja as regras da soma das cartas aqui ) do jogador ou do banco for igual a 8 ou 9 o jogo termina e as apostas s\u00e3o pagas ( veja as regras do pagamento das apostas aqui ). Se a soma das cartas tanto do jogador quanto do banco forem diferentes de 8 ou 9, a mesa decide se distribuir\u00e1 uma terceira carta a cada um de acordo com as regras a seguir, come\u00e7ando pelo jogador e depois distribuindo a carta do banco: Se a soma das cartas for 6 ou 7, n\u00e3o distribui mais uma carta; Se a soma das cartas for 5 ou menos, distribui mais uma carta e a soma \u00e9 recalculada. Alguns exemplos: Se o jogador obteve as cartas: e o banco obteve as cartas: O jogador recebe mais uma carta, pois a sua soma foi 5. O banco n\u00e3o recebe nenhuma carta, pois sua soma j\u00e1 \u00e9 7.","title":"Regras"},{"location":"ep/#soma-das-cartas","text":"Os valores das cartas seguem a tabela a seguir: Carta Valor A 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 0 J 0 Q 0 K 0 Importante: se a soma das cartas for maior ou igual a 10, considera-se apenas a unidade. Exemplos: Soma 7 = 1 + 6 7 = 1 + 6 : Soma 2 2 ( 8 + 0 + 4 = 12 8 + 0 + 4 = 12 , considerando apenas a unidade): Soma 7 7 :","title":"Soma das cartas"},{"location":"ep/#pagamento-das-apostas","text":"O jogador perde as fichas apostadas se n\u00e3o tiver apostado no vencedor. Caso contr\u00e1rio, a quantidade de fichas recebidas depende de quem foi o vencedor da partida: Jogador : se o jogador venceu a partida (obteve a soma mais pr\u00f3xima de 9), a mesa paga a mesma quantidade de fichas apostadas. Por exemplo, se o jogador apostou 10 fichas, ele receber\u00e1 outras 10 fichas. Banco : se o banco venceu a partida, a mesa paga 95% das fichas apostadas. Por exemplo, se o jogador apostou 20 fichas, ele receber\u00e1 outras 19. Caso o numero n\u00e3o seja inteiro o jogador receber\u00e1 as fichas sempre arredondando para baixo. Por exemplo, se o jogador apostou 25 fichar, ele vai receber s\u00f3 23 a mais. Empate : se ocorreu um empate, e o jogador apostou no empate, a mesa paga 8 vezes a quantidade de fichas apostadas. Por exemplo, se o jogador apostou 10 fichas, ele receber\u00e1 outras 80.0","title":"Pagamento das apostas"},{"location":"ep/#mais-exemplos","text":"","title":"Mais exemplos"},{"location":"ep/#exemplo-1","text":"A seguir apresentamos exemplos de uma partida completa: O jogador possui 100 fichas; Aposta 10 fichas no banco; A mesa distribui as cartas. O jogador recebe: O banco recebe: Como a soma das cartas do jogador \u00e9 igual a 8, a partida termina; O jogador perde as 10 fichas apostadas, pois apostou que o banco venceria. Nessa partida, se o jogador tivesse apostado que ele seria o vencedor, ele ganharia mais 10 fichas, ficando com 110 fichas ao final da partida.","title":"Exemplo 1"},{"location":"ep/#exemplo-2","text":"O jogador possui 100 fichas; Aposta 20 fichas no jogador; A mesa distribui as cartas. O jogador recebe: O banco recebe: Como a soma das cartas do jogador \u00e9 igual a 7, ele n\u00e3o recebe mais cartas; Como a soma das cartas do banco \u00e9 igual a 2, ele recebe mais uma carta. Agora o banco possui as seguintes cartas: A soma das cartas do banco \u00e9 igual a 7. Ocorreu um empate; O jogador perde as 20 fichas apostadas, pois apostou que ele venceria. Se o jogador tivesse apostado em empate, ele receberia mais 160 fichas, ficando com 260 fichas ao final da partida.","title":"Exemplo 2"},{"location":"ep/#exemplo-3","text":"O jogador possui 100 fichas; Aposta 40 fichas no empate; A mesa distribui as cartas. O jogador recebe: O banco recebe: Como a soma das cartas do jogador \u00e9 igual a 0, ele recebe mais uma carta. Agora o jogador possui as seguintes cartas: A soma das cartas do jogador \u00e9 igual a 5; Como a soma das cartas do banco \u00e9 igual a 3, ele recebe mais uma carta. Agora o banco possui as seguintes cartas: A soma das cartas do banco \u00e9 igual a 9. O banco venceu; O jogador perde as 40 fichas apostadas, pois apostou que ocorreria empate. Se o jogador tivesse apostado no banco, ele receberia mais 38 fichas, ficando com 138 fichas ao final da partida.","title":"Exemplo 3"},{"location":"ep/#regras-avancadas","text":"Importante : as regras a seguir devem ser implementadas para se obter conceito maior ou igual a B.","title":"Regras avan\u00e7adas"},{"location":"ep/#multiplos-baralhos","text":"Regras alternativas do Bacar\u00e1 permitem o uso de 6 ou 8 baralhos. Assim, ao inv\u00e9s de 52 cartas s\u00e3o utilizadas 312 ou 416 cartas, respectivamente. Todo o restante do jogo permanece o mesmo.","title":"M\u00faltiplos baralhos"},{"location":"ep/#multiplos-jogadores","text":"\u00c9 poss\u00edvel que mais de um jogador participe das apostas. Cada jogador aposta a quantidade de fichas que quiser em quem acreditar ser o vencedor. As cartas de jogador s\u00e3o as mesmas para todos. Ou seja, \u00e9 equivalente a ocorrerem diversos jogos ao mesmo tempo, um para cada jogador, mas as cartas sorteadas s\u00e3o as mesmas em todas as mesas. Ao final da partida cada jogador recebe ou paga o resultado das suas apostas.","title":"M\u00faltiplos jogadores"},{"location":"ep/#comissao-da-casa","text":"Em cassinos \u00e9 comum existir uma comiss\u00e3o sobre as apostas recebidas no Bacar\u00e1. Se o jogador perde a aposta ele n\u00e3o paga nada de comiss\u00e3o nessa partida. Entretanto, se ele ganha a aposta, \u00e9 necess\u00e1rio pagar uma porcentagem do que ele for receber para a casa. Por exemplo, se a taxa de comiss\u00e3o for 1% e o jogador for receber 10 fichas por ter vencido a aposta, ele receber\u00e1 9 fichas, pois dever\u00e1 pagar 1 como comiss\u00e3o. As taxas de comiss\u00e3o dependem de quem foi o vencedor da partida (jogador, banco ou empate) e da quantidade de baralhos. A tabela a seguir resume as taxas para cada caso: Vencedor 1 baralho 6 baralhos 8 baralhos Jogador 1.29% 1.24% 1.24% Banco 1.01% 1.06% 1.06% Empate 15.75% 14.44% 14.36% Por exemplo, se o jogador apostou 10.000 10.000 fichas no banco em um jogo com 6 baralhos e o banco foi o vencedor da partida, ele receber\u00e1 10.000 - 10.000\\cdot 0,0106 = 9894 10.000 - 10.000\\cdot 0,0106 = 9894 fichas como pagamento.","title":"Comiss\u00e3o da casa"},{"location":"ep/#mais-regras-para-a-distribuicao-da-terceira-carta","text":"As regras apresentadas anteriormente s\u00e3o simplificadas. Uma partida real de Bacar\u00e1 possui regras um pouco mais complexas para decidir se a terceira carta ser\u00e1 distribu\u00edda. Para as regras a seguir \u00e9 necess\u00e1rio assumir que a decis\u00e3o de distribuir ou n\u00e3o a terceira carta do jogador ser\u00e1 tomada antes da decis\u00e3o de distribuir a terceira carta do banco. A regra para a terceira carta do jogador n\u00e3o muda. Se a soma das suas duas cartas for igual ou menor a 5 e a soma das cartas do banco for diferente de 8 e 9, o jogador recebe a terceira carta. A regra para a terceira carta do banco depende da soma das suas duas cartas e da terceira carta do jogador: Se a soma das duas cartas do banco for igual a 6 ou mais, ele n\u00e3o recebe a terceira carta; Se o jogador n\u00e3o recebeu uma terceira carta e a soma das duas cartas do banco for menor ou igual a 5, ele recebe a terceira carta; Se o jogador recebeu uma terceira carta e a soma das duas cartas do banco for menor ou igual a 5, ele pode ou n\u00e3o receber a terceira carta e a decis\u00e3o \u00e9 tomada de acordo com a tabela a seguir (cada coluna representa o valor da terceira carta recebida pelo jogador, de 0 a 9, se o valor for S significa que a terceira carta do banco \u00e9 distribu\u00edda, se for N o banco n\u00e3o recebe uma terceira carta): Soma do banco 0 1 2 3 4 5 6 7 8 9 0 S S S S S S S S S S 1 S S S S S S S S S S 2 S S S S S S S S S S 3 S S S S S S S S N S 4 N N S S S S S S N N 5 N N N N S S S S N N 6 N N N N N N S S N N 7 N N N N N N N N N N Por exemplo, se a terceira carta do jogador foi 3 e a soma das duas cartas do banco \u00e9 5, o banco n\u00e3o recebe a terceira carta. Se a terceira carta do jogador foi 2 e a soma das duas cartas do banco \u00e9 4, o banco recebe a terceira carta.","title":"Mais regras para a distribui\u00e7\u00e3o da terceira carta"},{"location":"ep/#rubricas-dos-objetivos-de-aprendizagem","text":"Os objetivos de aprendizagem e as correspondentes rubricas de avalia\u00e7\u00e3o s\u00e3o os seguintes: Objetivo: Desenvolver programas de computador I D C B at\u00e9 A+ N\u00e3o implementou nem as regras b\u00e1sicas . Implementou algumas das regras b\u00e1sicas, mas o c\u00f3digo n\u00e3o funciona (d\u00e1 erro ao executar). Implementou todas as regras b\u00e1sicas , mas n\u00e3o funciona para alguns casos. Funciona para todas as regras b\u00e1sicas e implementou as regras avan\u00e7adas . Cada regra avan\u00e7ada implementada corretamente adiciona meio conceito. Objetivo: Atuar em uma equipe gerenciada por m\u00e9todos \u00e1geis I D C B / A N\u00e3o entregou pelo git. C\u00f3digo entregue em um ou poucos commits . Caso em dupla n\u00e3o demonstraram que ambos os alunos contribu\u00edram de modo substancial. V\u00e1rios recursos no mesmo commit . Caso em dupla: balan\u00e7o de c\u00f3digo desenvolvido \u00e9 muito inclinado para um dos alunos. Commits cont\u00ednuos e caso em dupla balan\u00e7o adequado de esfor\u00e7os. Objetivo: Identificar e programar estrat\u00e9gias computacionais de resolu\u00e7\u00e3o de problemas pr\u00e1ticos I D C B A N\u00e3o entregou o EP. Reposit\u00f3rio n\u00e3o tem todos os arquivos necess\u00e1rios para executar o programa. Reposit\u00f3rio com arquivos ou c\u00f3digo desnecess\u00e1rio ou c\u00f3digo estruturado e documentado de forma confusa. C\u00f3digo com estrutura\u00e7\u00e3o e documenta\u00e7\u00e3o razo\u00e1vel. C\u00f3digo bem estruturado, modularizado e documentado. A nota do projeto ser\u00e1 dada pelo seguinte: Se a equipe obteve conceito I ou D em algum objetivo de aprendizado, o conceito final ser\u00e1 dado pelo menor conceito obtido. Por exemplo: se todos o recursos foram implementadas, e o c\u00f3digo est\u00e1 impec\u00e1vel, mas um aluno fez tudo (conforme evidenciado no git), a nota ser\u00e1 D ou I (N\u00e3o adianta argumentar que foi feito tudo no computador de um aluno s\u00f3, o objetivo aqui \u00e9 que todos saibam trabalhar de forma colaborativa usando uma ferramenta como o git). Se todos os conceitos forem iguais ou superiores a C, o conceito final ser\u00e1 obtido pela m\u00e9dia aritm\u00e9tica dos conceitos obtidos para os objetivos de aprendizado.","title":"Rubricas dos Objetivos de Aprendizagem"},{"location":"ep/#o-que-voce-deve-entregar","text":"","title":"O que voc\u00ea deve entregar"},{"location":"ep/#o-programa","text":"O seu EP consistir\u00e1 de um programa em Python que implementa o jogo Bacar\u00e1. Seu programa deve permitir que o jogador continue jogando enquanto tiver fichas. Se as fichas do jogador acabarem o jogo termina automaticamente. No in\u00edcio de cada partida o jogador pode decidir se continua jogando ou se deseja parar. Se ele decidir jogar, uma nova partida se inicia, perguntando o valor a ser apostado.","title":"O programa"},{"location":"ep/#documentacao-minima","text":"Se no seu reposit\u00f3rio existem v\u00e1rios arquivos .py , voc\u00ea deve indicar claramente qual arquivo cont\u00e9m o seu programa (se seu reposit\u00f3rio tem s\u00f3 um arquivo .py voc\u00ea n\u00e3o tem com o que se preocupar). N\u00f3s n\u00e3o vamos ter como adivinhar qual \u00e9 o certo e nesse caso haver\u00e1 desconto de nota. Coloque um cabe\u00e7alho (coment\u00e1rios) no seu c\u00f3digo contendo, no m\u00ednimo o seguinte conte\u00fado (trocando o nome dos membros da equipe e a data): # EP - Design de Software # Equipe: Barbara Tieko e Evandro Romeiro # Data: DD/MM/2020","title":"Documenta\u00e7\u00e3o m\u00ednima"},{"location":"ep/#como-entregar","text":"A entrega dever\u00e1 ser feita via Git. O Git permite que voc\u00ea mantenha um hist\u00f3rico da evolu\u00e7\u00e3o do seu c\u00f3digo e o compartilhe com seus colegas de trabalho. N\u00e3o teremos uma aula para aprender a usar o Git. Essa \u00e9 uma oportunidade para colocarmos em pr\u00e1tica a habilidade de aprender a aprender. O v\u00eddeo a seguir apresenta o m\u00ednimo que voc\u00ea deve saber para entregar o projeto: https://youtu.be/xZI0BytK5GA Pode ser necess\u00e1rio consultar outras fontes para entender como utilizar o Git. Existem diversos recursos dispon\u00edveis na internet. Os professores estar\u00e3o dispon\u00edveis para tirar d\u00favidas sobre o uso do git durante os hor\u00e1rios de atendimento. Envie no Blackboard o endere\u00e7o do seu reposit\u00f3rio GitHub. Exerc\u00edcios copiados ou muito parecidos podem gerar notifica\u00e7\u00f5es de infra\u00e7\u00f5es do c\u00f3digo de \u00e9tica Insper, resultando em reprova\u00e7\u00e3o autom\u00e1tica da disciplina ou at\u00e9 mesmo jubilamento.","title":"Como entregar"},{"location":"turma-a/","text":"Turma A \u00b6 Professor: Luciano Soares Hor\u00e1rios \u00b6 Aulas: SEG 15:45 - 17:45 QUA 15:45 - 17:45 Atendimento: QUA 10:00 - 11:30","title":"Turma A"},{"location":"turma-a/#turma-a","text":"Professor: Luciano Soares","title":"Turma A"},{"location":"turma-a/#horarios","text":"Aulas: SEG 15:45 - 17:45 QUA 15:45 - 17:45 Atendimento: QUA 10:00 - 11:30","title":"Hor\u00e1rios"},{"location":"turma-b/","text":"Turma B \u00b6 Professor: Andrew Kurauchi ( andrewtnk@insper.edu.br ) Hor\u00e1rios \u00b6 Aulas: SEG 09:45 - 11:45 QUA 07:30 - 09:30 Atendimento: SEX 13:30 - 15:00","title":"Turma B"},{"location":"turma-b/#turma-b","text":"Professor: Andrew Kurauchi ( andrewtnk@insper.edu.br )","title":"Turma B"},{"location":"turma-b/#horarios","text":"Aulas: SEG 09:45 - 11:45 QUA 07:30 - 09:30 Atendimento: SEX 13:30 - 15:00","title":"Hor\u00e1rios"},{"location":"aulas/01-funcoes/","text":"01 - Introdu\u00e7\u00e3o ao Python, Vari\u00e1veis, Opera\u00e7\u00f5es Matem\u00e1ticas e Fun\u00e7\u00f5es \u00b6 O Python \u00b6 O nome Python teve a sua origem no grupo humor\u00edstico brit\u00e2nico Monty Python (se tiver curiosidade, \u00e9 poss\u00edvel encontrar alguns t\u00edtulos no Netflix). A linguagem Python foi desenvolvida por Guido van Rossum no in\u00edcio da d\u00e9cada de 1990. Apesar de ser uma linguagem relativamente antiga, o seu uso apresentou um crescimento significativo nos \u00faltimos anos e \u00e9 hoje uma das linguagens de programa\u00e7\u00e3o mais populares no mundo, sendo amplamente utilizada por grandes empresas como Google, Netflix, Nasa, Dropbox, e muitos outros. Neste primeiro handout vamos desenvolver nossos primeiros programas em Python, utilizando os seguintes conceitos b\u00e1sicos de programa\u00e7\u00e3o: opera\u00e7\u00f5es matem\u00e1ticas, vari\u00e1veis e fun\u00e7\u00f5es. Instala\u00e7\u00e3o \u00b6 Existem diversas formas de instalar o Python. Recomendamos a instala\u00e7\u00e3o atrav\u00e9s do Anaconda, que j\u00e1 inclui o Python e alguns m\u00f3dulos adicionais que ser\u00e3o \u00fateis em outras disciplinas. Para isso, acesse o link de instala\u00e7\u00e3o referente ao seu sistema operacional: Windows: https://docs.anaconda.com/anaconda/install/windows/ macOS: https://docs.anaconda.com/anaconda/install/mac-os/ Linux: https://docs.anaconda.com/anaconda/install/linux/ Para escrever e editar o nosso c\u00f3digo ser\u00e1 necess\u00e1rio utilizarmos um editor de c\u00f3digo. Existem diversas alternativas, mas nesta disciplina focaremos no Visual Studio Code (VS Code), um dos editores mais populares atualmente. Veremos que o c\u00f3digo \u00e9 essencialmente texto, ent\u00e3o poder\u00edamos utilizar qualquer editor de texto dispon\u00edvel, mas editores como o VS Code possuem diversas ferramentas que facilitam o desenvolvimento. \u00c9 prov\u00e1vel que o VS Code j\u00e1 tenha sido instalado juntamente com o Anaconda. Para verificar, abra o Anaconda Navigator (um programa instalado com o Anaconda), procure pelo VS Code e clique em Launch . Se ele mostrar a op\u00e7\u00e3o de instalar, voc\u00ea pode instal\u00e1-lo pelo pr\u00f3prio Anaconda Navigator. Caso contr\u00e1rio, voc\u00ea pode fazer o download no seguinte link: https://code.visualstudio.com/Download Ol\u00e1 Mundo! \u00b6 Quando vamos aprender uma nova linguagem de programa\u00e7\u00e3o \u00e9 comum escrevermos um primeiro programa que, ao ser executado, mostra na tela o texto Hello, world! (\"Ol\u00e1, mundo!\"). Apesar de ser um programa muito simples, ele j\u00e1 nos permite come\u00e7ar a compreender dois aspectos da linguagem: Qual \u00e9 a \"cara\" da linguagem, ou seja, qual \u00e9 a estrutura b\u00e1sica do c\u00f3digo. Como executar um programa escrito nessa linguagem. Ent\u00e3o m\u00e3os \u00e0 obra! EXERC\u00cdCIO 1 \u00b6 Siga os passos a seguir para escrever e executar seu primeiro programa em Python: Abra o VS Code. Crie um novo arquivo clicando em \"File \u2192 New File\" ou utilizando o atalho Ctrl + N (Windows)/ Cmd + N (macOS). Salve o arquivo com o nome hello.py . Para isso, clique em \"File \u2192 Save\", preencha o nome, escolha uma pasta para salvar o arquivo e clique em \"Save\". Digite o c\u00f3digo print ( 'Hello, world!' ) Salve o arquivo clicando em \"File \u2192 Save\" ou usando o atalho Ctrl + S (Windows)/ Cmd + S (macOS). Execute seu programa. Para executar um programa em Python, temos quatro possibilidades: Clique em \"Run \u2192 Run Without Debugging\" Utilize o atalho Ctrl + F5 Clique na setinha verde no canto superior direito: [Avan\u00e7ado] Utilizando o terminal para ir at\u00e9 a pasta onde se encontra o arquivo e executando-o com o comando python hello.py O texto Hello, world! deve aparecer no terminal. Entendendo nosso primeiro programa \u00b6 Nosso c\u00f3digo possui apenas uma linha, mas j\u00e1 cont\u00e9m diversos conceitos importantes. N\u00e3o se preocupe se n\u00e3o entender toda a explica\u00e7\u00e3o a seguir, tudo ficar\u00e1 mais claro conforme formos aprendendo mais. A linha print ( 'Hello, world!' ) pode ser lida como: \"Python, por favor, mostre na tela o texto Hello , world ! . Vamos por partes. Comecemos pela a fun\u00e7\u00e3o print . Essa fun\u00e7\u00e3o \u00e9 utilizada para mostrar texto no terminal. Podemos entender uma fun\u00e7\u00e3o como um comando do Python, ou seja, estamos dizendo para o Python fazer algo. A a\u00e7\u00e3o de mostrar algo na tela depende de uma informa\u00e7\u00e3o adicional: o que deve ser mostrado. Essa informa\u00e7\u00e3o da qual a a\u00e7\u00e3o depende \u00e9 chamada de argumento da fun\u00e7\u00e3o . No nosso exemplo, o argumento da fun\u00e7\u00e3o print \u00e9 o texto 'Hello, world!' . Um \u00faltimo detalhe importante \u00e9 o uso das aspas. Para indicar que Hello , world ! \u00e9 um texto n\u00f3s utilizamos aspas, que podem ser simples ou duplas. Isso \u00e9 muito importante, pois o que estiver entre aspas ser\u00e1 considerado pelo Python como texto (que chamamos de string ) e n\u00e3o como um comando (por exemplo a fun\u00e7\u00e3o print ). Dica Pro: documente o c\u00f3digo! Uma li\u00e7\u00e3o a ser aprendida \u00e9 que passamos muito mais tempo lendo c\u00f3digo pr\u00e9-existente do que escrevendo c\u00f3digo novo. Por isso a documenta\u00e7\u00e3o do c\u00f3digo \u00e9 uma pr\u00e1tica extremamente importante. A documenta\u00e7\u00e3o pode ser feita por meio de coment\u00e1rios, trechos de texto que n\u00e3o afetam o comportamento do programa, que ajudam o leitor (seja algum colega de trabalho que n\u00e3o conhece o c\u00f3digo ou voc\u00ea mesmo algum tempo no futuro) a compreender o c\u00f3digo. Veja a seguir um exemplo do mesmo programa que acabamos de executar, mas com documenta\u00e7\u00e3o: \"\"\" Programa que escreve \"Hello, world!\" no console. Serve para verificar se conseguimos usar o Python pela primeira vez. @author: Profs. Design de Software \"\"\" print ( 'Hello, world!' ) O texto entre \"\"\" ser\u00e1 ignorado pelo programa. Note que nesse coment\u00e1rio podemos encontrar informa\u00e7\u00f5es como: O que o c\u00f3digo faz; Por que ele foi escrito; Quem escreveu o c\u00f3digo. Esse primeiro programa ainda \u00e9 muito simples, mas conforme formos desenvolvendo programas mais complexos os coment\u00e1rios se tornam cada vez mais relevantes. Buscando ajuda Depois de pensar e tentar resolver problemas por conta pr\u00f3pria e n\u00e3o encontrar a solu\u00e7\u00e3o, n\u00e3o tenha vergonha de procurar ajuda na internet. At\u00e9 mesmo programadores experientes fazem isso. \u00c9 importante, entretanto, saber como fazer essas buscas: que termos usar, quais respostas confiar, etc. Voc\u00ea vai desenvolver uma intui\u00e7\u00e3o conforme for ganhando experi\u00eancia, mas para te ajudar neste come\u00e7o, escrevemos um pequeno guia com algumas dicas . Opera\u00e7\u00f5es matem\u00e1ticas \u00b6 Queremos usar o Python para fazer algo al\u00e9m de s\u00f3 mostrar um texto na tela. Para isso vamos come\u00e7ar aprendendo sobre como realizar opera\u00e7\u00f5es matem\u00e1ticas. EXERC\u00cdCIO 2 \u00b6 Crie um novo arquivo chamado operadores.py no VS Code e copie o c\u00f3digo a seguir. Execute-o e tente identificar a partir dos resultados o que cada operador faz. Discuta com seus colegas. print ( 'Usando alguns operadores num\u00e9ricos:' ) print ( 2 + 3 ) print ( 2 - 3 ) print ( 2 * 3 ) print ( 2 ** 3 ) print ( 7 / 3 ) print ( 7 // 3 ) print ( 7 % 3 ) print (( 1 + 2 ) * ( - 3 - 2 )) Importante O programa em Python \u00e9 executado linha a linha, ou seja, as linhas do programa s\u00e3o executadas uma ap\u00f3s a outra de cima para baixo. Uma linha de c\u00f3digo s\u00f3 \u00e9 executada depois que a linha anterior terminou de executar. Resposta Leia a resposta apenas depois de discutir com seus colegas. O c\u00f3digo abaixo foi comentado com as respostas. Coment\u00e1rios em Python s\u00e3o iniciados com o caractere cerquilha ( # ). Tudo o que vier depois desse caractere ser\u00e1 ignorado pelo programa. \"\"\" Programa para demonstrar alguns operadores num\u00e9ricos. @author: Profs. Design de Software \"\"\" print ( 'Usando alguns operadores num\u00e9ricos:' ) print ( 2 + 3 ) # Soma. print ( 2 - 3 ) # Subtra\u00e7\u00e3o. print ( 2 * 3 ) # Multiplica\u00e7\u00e3o. print ( 2 ** 3 ) # Potencia\u00e7\u00e3o ou exponencia\u00e7\u00e3o. # Operadores de divis\u00e3o print ( 7 / 3 ) # Divis\u00e3o. print ( 7 // 3 ) # Divis\u00e3o inteira: quociente. print ( 7 % 3 ) # Resto da divis\u00e3o inteira. # \u00c9 poss\u00edvel utilizar par\u00eanteses para modificar a ordem # de aplica\u00e7\u00e3o das opera\u00e7\u00f5es. print (( 1 + 2 ) * ( - 3 - 2 )) # Par\u00eanteses. Mais alguns detalhes... No programa acima podemos observar mais alguns detalhes: A cerquilha ( # ) que inicia um coment\u00e1rio pode ser inserida no come\u00e7o de uma linha ou precedida por 2 espa\u00e7os depois de um trecho de c\u00f3digo. Esses dois espa\u00e7os antes da cerquilha n\u00e3o s\u00e3o obrigat\u00f3rios, mas s\u00e3o um padr\u00e3o adotado pela comunidade Python. Os operadores e n\u00fameros est\u00e3o separados por espa\u00e7os. Esses espa\u00e7os tamb\u00e9m n\u00e3o s\u00e3o obrigat\u00f3rios, mas facilitam na interpreta\u00e7\u00e3o visual. A ordem de prioridade dos operadores em Python segue a conven\u00e7\u00e3o matem\u00e1tica do PEMDAS: P ar\u00eanteses t\u00eam a maior prioridade e pode ser usado para for\u00e7ar uma express\u00e3o a ser avaliada na ordem que voc\u00ea quiser. E xponencia\u00e7\u00e3o tem a pr\u00f3xima preced\u00eancia mais alta. M ultiplica\u00e7\u00e3o e D ivis\u00e3o t\u00eam a mesma preced\u00eancia, que \u00e9 maior do que a A di\u00e7\u00e3o e S ubtra\u00e7\u00e3o. Al\u00e9m disso, as opera\u00e7\u00f5es de mesma prioridade s\u00e3o avaliadas da esquerda para a direita. EXERC\u00cdCIO 3 \u00b6 Escreva um programa em Python que imprime (mostra na tela com o comando print ) o resultado das seguintes express\u00f5es num\u00e9ricas: 1 + \\frac{1}{2} + \\frac{1}{2^2} + \\frac{1}{2^3} + \\frac{1}{2^4} 1 + \\frac{1}{2} + \\frac{1}{2^2} + \\frac{1}{2^3} + \\frac{1}{2^4} (resposta esperada: 1.9375 ) \\frac{3\\cdot4+5}{1+2\\cdot3} \\frac{3\\cdot4+5}{1+2\\cdot3} (resposta esperada: 2.4285714285714284 \u2192 n\u00e3o se preocupe se der alguma diferen\u00e7a nas \u00faltimas casas decimais) \\sqrt{3^2+4^2} \\sqrt{3^2+4^2} (resposta esperada: 5.0 ) Vari\u00e1veis \u00b6 Podemos armazenar valores ou resultados de express\u00f5es matem\u00e1ticas em vari\u00e1veis. Uma vari\u00e1vel \u00e9 como se fosse uma caixa com uma etiqueta com o seu nome. O conte\u00fado armazenado na caixa pode ser acessado a partir do nome em sua etiqueta. Considere o exemplo a seguir: x = 5 print ( x ) Devemos ler a primeira linha como: \"a vari\u00e1vel x recebe o valor 5\". \u00c9 como se diss\u00e9ssemos: \"interpretador Python, por favor, crie na mem\u00f3ria do computador uma caixa chamada x e guarde l\u00e1 dentro o valor 5 .\" A linha seguinte pede para o Python imprimir o conte\u00fado da vari\u00e1vel x , nesse caso, 5 . Assim, o Python vai escrever 5 no terminal. Podemos usar vari\u00e1veis dentro de outras express\u00f5es. Por exemplo: x = 3 y = 4 z = x * y print ( 'O ret\u00e2ngulo de lados {0} e {1} tem \u00e1rea {2} ' . format ( x , y , z )) Info Usamos o . format () para escrever valores no meio do texto. \u00c9 importante notar que: A sequ\u00eancia dos argumentos (conte\u00fado dentro dos par\u00eanteses do . format () ) \u00e9 importante. O primeiro argumento ( x ) ser\u00e1 inserido no lugar do { 0 } , o segundo argumento ( y ) ser\u00e1 inserido no lugar do { 1 } e o terceiro argumento ( z ) ser\u00e1 inserido no lugar do { 2 } . Em Python (e em programa\u00e7\u00e3o em geral) come\u00e7amos a contar a partir do zero, ou seja, 0 \u00e9 o primeiro, 1 \u00e9 o segundo, 2 \u00e9 o terceiro e assim por diante. O . format () \u00e9 executado primeiro, escrevendo os valores no meio do texto, e depois o resultado \u00e9 utilizado pela fun\u00e7\u00e3o print() , mostrando o resultado na tela. EXERC\u00cdCIO 4 \u00b6 Acesse o servidor de desafios ( http://softdes.insper.edu.br/ ). A sua senha \u00e9 igual ao seu login e ambos s\u00e3o iguais ao seu login do Insper. Por exemplo, se o seu login do Insper \u00e9 fulano123 , o seu login no servidor ser\u00e1 fulano123 e a sua senha tamb\u00e9m ser\u00e1 fulano123 . Se voc\u00ea n\u00e3o conseguir acessar, \u00e9 poss\u00edvel que o seu login ainda n\u00e3o tenha sido criado. Nesse caso, pe\u00e7a para o professor verificar se o seu usu\u00e1rio j\u00e1 foi criado. Resolva o [TESTE DE MESA] Vari\u00e1veis . Teste de Mesa O teste de mesa consiste em simular manualmente a execu\u00e7\u00e3o de um programa. O processo se d\u00e1 da seguinte forma: Execute as opera\u00e7\u00f5es da linha atual (no servidor de desafios a linha atual \u00e9 destacada em vermelho). No in\u00edcio da execu\u00e7\u00e3o a linha atual \u00e9 a primeira linha de c\u00f3digo. Atualize o valor das vari\u00e1veis na mem\u00f3ria. No servidor existe uma regi\u00e3o \u00e0 direita chamada \"Mem\u00f3ria\". Voc\u00ea deve atualizar as vari\u00e1veis nessa regi\u00e3o com os valores obtidos ap\u00f3s a execu\u00e7\u00e3o da linha atual. Se a linha atual n\u00e3o modificou alguma vari\u00e1vel ela deve permanecer inalterada na mem\u00f3ria. Se a fun\u00e7\u00e3o print foi utilizada na linha atual, escreva na regi\u00e3o chamada \"Sa\u00edda do terminal\" (fundo preto) o que aparecer\u00e1 no terminal. Prepare-se para a execu\u00e7\u00e3o da pr\u00f3xima linha. No servidor \u00e9 necess\u00e1rio selecionar o n\u00famero da pr\u00f3xima linha a ser executada em \"Pr\u00f3xima linha\". Clique em \"Pr\u00f3ximo passo\". \u00c9 poss\u00edvel realizar um teste de mesa apenas com papel e caneta. Voc\u00ea pode sempre utilizar esse processo para verificar se o seu programa faz o que era esperado. Podemos usar vari\u00e1veis para armazenar qualquer tipo de dados em Python: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \"\"\" Demonstra\u00e7\u00e3o de uso de vari\u00e1veis com diversos tipos de dados em Python. @author: Profs. de Design de Software. \"\"\" # Vari\u00e1veis podem armazenar texto (strings). disciplina = 'Design de Software' print ( disciplina ) # Vari\u00e1veis podem armazenar inteiros. num_alunos = 120 # Vari\u00e1veis podem armazenar os valores especiais True e False # S\u00e3o usados em express\u00f5es l\u00f3gicas, ou tamb\u00e9m chamadas # express\u00f5es booleanas. a = True b = False c = a or b # Opera\u00e7\u00e3o booleana 'OU'. # Vari\u00e1veis podem armazenar n\u00fameros reais. Em computa\u00e7\u00e3o, # estes n\u00fameros s\u00e3o chamados de n\u00fameros em ponto flutuante. base = 0.5 altura = 4.2e1 # 4.2 x 10**1 => 42.0 area = base * altura / 2.0 # Vari\u00e1veis armazenam muitos outros tipos que veremos depois. ponto = ( 3.2 , 5.7 ) # Tupla. teste = [ 5.2 , 'laranja' , False , 42 ] # Lista. notas = { 'dessoft' : 10.0 , 'gde' : 10.0 , 'modsim' : 10.0 } # dicion\u00e1rio. Warning Considere as linhas 8 e 9. Aqui vemos a import\u00e2ncia das aspas. Ao executar a linha 9 o Python mostrar\u00e1 na tela a string armazenada na vari\u00e1vel disciplina , ou seja, Design de Software . Se utiliz\u00e1ssemos aspas na linha 9 ( print ( 'disciplina' ) ) o Python mostraria o texto disciplina no terminal. EXERC\u00cdCIO 5 \u00b6 Fa\u00e7a o [TESTE DE MESA] Mais vari\u00e1veis . Fun\u00e7\u00f5es \u00b6 J\u00e1 vimos como criar valores num\u00e9ricos e de texto puro em Python (chamados em Python de \"literais\") e vari\u00e1veis. Tudo isso parece muito com a boa e velha matem\u00e1tica. E j\u00e1 que estamos vendo todas essas rela\u00e7\u00f5es, um outro conceito importante em matem\u00e1tica s\u00e3o fun\u00e7\u00f5es. Por exemplo: f(x) = 1.60934\\cdot x f(x) = 1.60934\\cdot x Essa fun\u00e7\u00e3o converte valores em milhas ( x x ) para quil\u00f4metros. Por exemplo: f(10) = 1.60934\\cdot 10 = 16.0934 f(10) = 1.60934\\cdot 10 = 16.0934 , ou seja, 10 milhas \u00e9 o mesmo que 16.0934 km. O Python tamb\u00e9m nos permite criar fun\u00e7\u00f5es! Escrevendo a mesma fun\u00e7\u00e3o acima em Python: 1 2 3 def f ( x ): y = 1.60934 * x return y Novamente temos muitas observa\u00e7\u00f5es importantes. Vamos come\u00e7ar pelos nomes: O x na linha 1 \u00e9 chamado de argumento da fun\u00e7\u00e3o. O y na linha 3 \u00e9 chamado de retorno ou resultado da fun\u00e7\u00e3o. As linhas 2 e 3 s\u00e3o chamadas de corpo ou bloco da fun\u00e7\u00e3o. O corpo da fun\u00e7\u00e3o \u00e9 identificado com os 4 espa\u00e7os no come\u00e7o da linha. Esses 4 espa\u00e7os s\u00e3o chamados de indenta\u00e7\u00e3o . Indenta\u00e7\u00e3o A indenta\u00e7\u00e3o \u00e9 crucial e Python e tem um significado especial. Ela \u00e9 utilizada para indicar blocos de c\u00f3digo. Portanto n\u00e3o se deve utilizar indenta\u00e7\u00f5es a mais ou a menos, pois isso causar\u00e1 um erro na execu\u00e7\u00e3o do programa. O uso de 4 espa\u00e7os \u00e9 outra padroniza\u00e7\u00e3o da comunidade Python. Se voc\u00ea usar 2, 3 ou qualquer outra quantidade de espa\u00e7os (ou at\u00e9 mesmo o caractere Tab ) o c\u00f3digo funcionar\u00e1 da mesma forma. Desde que seja consistente, ou seja, escolha um formato e utilize-o em todo o seu programa. Recomendamos que voc\u00ea utilize 4 espa\u00e7os para seguir o padr\u00e3o da comunidade. Se voc\u00ea executar o c\u00f3digo acima n\u00e3o vai acontecer nada. Nesse c\u00f3digo n\u00f3s estamos apenas definindo a fun\u00e7\u00e3o f (por isso a palavra def ). Podemos entender a linha 1 como: \"Python, quando eu pedir para voc\u00ea executar a fun\u00e7\u00e3o f , passando um valor para x , o que voc\u00ea deve fazer \u00e9: multiplicar o valor armazenado na vari\u00e1vel x por 1.60934 e guardar o resultado na vari\u00e1vel y e depois devolver o valor armazenado na vari\u00e1vel y como o resultado\". Em outras palavras, \u00e9 como se estiv\u00e9ssemos criando um novo comando do Python (assim como j\u00e1 temos o print , por exemplo). Chamando fun\u00e7\u00f5es em Python \u00b6 Considere novamente a fun\u00e7\u00e3o matem\u00e1tica f(x) f(x) vista acima . Note que n\u00e3o existe um valor, ou resultado, para f(x) f(x) a n\u00e3o ser que voc\u00ea defina quanto vale o x x . Da mesma forma, n\u00e3o existe um resultado, ou valor de retorno, para a fun\u00e7\u00e3o f ( x ) no Python a n\u00e3o ser que definamos um valor para x . Essa ideia \u00e9 a mesma que apresentamos sobre a fun\u00e7\u00e3o print , ou seja, precisamos de uma informa\u00e7\u00e3o adicional. Uma vez que definimos uma fun\u00e7\u00e3o \u00e9 como se ela se tornasse parte da linguagem Python. Assim, para esse contexto introdut\u00f3rio, n\u00e3o existe nenhuma diferen\u00e7a entre a fun\u00e7\u00e3o print e a fun\u00e7\u00e3o f ( x ) em termos de import\u00e2ncia. Ambas s\u00e3o comandos dispon\u00edveis no Python para o programador utilizar em seu c\u00f3digo. Vamos ent\u00e3o ver um exemplo de uso da nossa fun\u00e7\u00e3o f ( x ) . Considere o c\u00f3digo a seguir: 1 2 3 4 5 6 7 def f ( x ): y = 1.60934 * x return y a = 10 b = f ( a ) print ( b ) Nas linhas 1 a 3 a fun\u00e7\u00e3o f ( x ) \u00e9 definida, ou seja, ap\u00f3s a execu\u00e7\u00e3o dessas linhas o Python sabe o que fazer sempre que precisarmos dessa fun\u00e7\u00e3o. Na linha 5, armazenamos o n\u00famero 10 na vari\u00e1vel a . Na linha 6 ocorre a chamada da fun\u00e7\u00e3o. Vamos detalhar o que ocorre nessa linha: O valor da vari\u00e1vel a \u00e9 utilizado, o Python consulta esse valor na mem\u00f3ria e substitui na chamada da fun\u00e7\u00e3o. Agora a linha \u00e9 equivalente a b = f ( 10 ) . A fun\u00e7\u00e3o f () \u00e9 executada com o argumento 10 . A pr\u00f3xima linha executada \u00e9 a linha 1. O Python cria uma nova regi\u00e3o tempor\u00e1ria na mem\u00f3ria. Essa mem\u00f3ria s\u00f3 existir\u00e1 enquanto a fun\u00e7\u00e3o estiver sendo executada. Na linha 1 \u00e9 criada uma vari\u00e1vel chamada x nessa mem\u00f3ria tempor\u00e1ria, armazenando o valor recebido como argumento, no caso 10 . Na linha 2 o valor x \u00e9 substitu\u00eddo por 10 e o valor 16.0934 (resultado da multiplica\u00e7\u00e3o) \u00e9 armazenado na vari\u00e1vel y , tamb\u00e9m na mem\u00f3ria tempor\u00e1ria. Na linha 3 o valor guardado na vari\u00e1vel y \u00e9 devolvido como resultado. A mem\u00f3ria tempor\u00e1ria criada para a fun\u00e7\u00e3o f () \u00e9 desativada. A partir deste momento as vari\u00e1veis que estavam contidas nela ( x e y ) n\u00e3o existem mais. Voltamos para a linha 6. Agora que temos o resultado da fun\u00e7\u00e3o a linha \u00e9 equivalente a b = 16.0934 . O valor 16.0934 \u00e9 armazenado na vari\u00e1vel b Por fim, na linha 7, o valor armazenado na vari\u00e1vel b \u00e9 utilizado como argumento da fun\u00e7\u00e3o print () e o valor 16.0934 \u00e9 mostrado no terminal. EXERC\u00cdCIO 6 \u00b6 Fa\u00e7a o [TESTE DE MESA] Converte milhas para km para consolidar a sua compreens\u00e3o sobre fun\u00e7\u00f5es em Python. Dica Pro: use bons nomes! No dia seguinte voc\u00ea abre esse programa . O que faz mesmo esse c\u00f3digo? Acredite, \u00e9 mais comum do que voc\u00ea imagina. Enquanto estamos desenvolvendo o programa temos muito claro para qu\u00ea cada vari\u00e1vel serve, mas n\u00e3o precisamos de muito tempo para olhar o mesmo c\u00f3digo e n\u00e3o ter ideia do que est\u00e1 acontecendo. Por isso, use nomes que fa\u00e7am sentido para as suas vari\u00e1veis e fun\u00e7\u00f5es. Quando n\u00e3o estiver claro o suficiente, adicione coment\u00e1rios, mas as vezes boas escolhas de nomes dispensam coment\u00e1rios no c\u00f3digo. Considere a vers\u00e3o a seguir (ela faz exatamente o mesmo que o nosso c\u00f3digo anterior): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \"\"\" Programa que converte de milhas para quil\u00f4metros. Vers\u00e3o melhor documentada. @author: Profs. de Design de Software \"\"\" # Fun\u00e7\u00e3o que converte um valor de dist\u00e2ncia # dado em milhas para quil\u00f4metros. def converte_milhas_para_km ( distancia_mi ): distancia_km = 1.60934 * distancia_mi return distancia_km # Quanto \u00e9 10 mi em km? milhas = 10 km = converte_milhas_para_km ( milhas ) print ( km ) Neste exemplo os coment\u00e1rios poderiam at\u00e9 ser removidos, pois o nome da fun\u00e7\u00e3o j\u00e1 deixa claro o que ela faz. EXERC\u00cdCIO 7 \u00b6 No servidor, fa\u00e7a o exerc\u00edcio 6. Celsius para Fahrenheit . Primeiro resolva em seu pr\u00f3prio computador, fazendo testes com alguns valores espec\u00edficos (ex: 0 e 100). Depois disso, envie apenas a defini\u00e7\u00e3o da fun\u00e7\u00e3o, sem o c\u00f3digo que chama a fun\u00e7\u00e3o. Por exemplo, no programa que desenvolvemos acima , voc\u00ea enviaria apenas as linhas 1 a 3. Sempre que o exerc\u00edcio do servidor pedir uma fun\u00e7\u00e3o voc\u00ea deve enviar apenas a defini\u00e7\u00e3o da fun\u00e7\u00e3o, sem o c\u00f3digo de teste que chama a fun\u00e7\u00e3o. EXERC\u00cdCIO 8 \u00b6 Fa\u00e7a o exerc\u00edcio 7. \u00c1rea do tri\u00e2ngulo no servidor. Dica: uma fun\u00e7\u00e3o em Python, assim como uma fun\u00e7\u00e3o matem\u00e1tica multivariada, pode receber v\u00e1rios argumentos separados por v\u00edrgula. N\u00e3o esque\u00e7a de escrever c\u00f3digo de teste tamb\u00e9m. Pense em valores de teste que sejam interessantes. Por exemplo: e se a base for zero? E se a altura for zero? E se forem iguais?","title":"Handout"},{"location":"aulas/01-funcoes/#01-introducao-ao-python-variaveis-operacoes-matematicas-e-funcoes","text":"","title":"01 - Introdu\u00e7\u00e3o ao Python, Vari\u00e1veis, Opera\u00e7\u00f5es Matem\u00e1ticas e Fun\u00e7\u00f5es"},{"location":"aulas/01-funcoes/#o-python","text":"O nome Python teve a sua origem no grupo humor\u00edstico brit\u00e2nico Monty Python (se tiver curiosidade, \u00e9 poss\u00edvel encontrar alguns t\u00edtulos no Netflix). A linguagem Python foi desenvolvida por Guido van Rossum no in\u00edcio da d\u00e9cada de 1990. Apesar de ser uma linguagem relativamente antiga, o seu uso apresentou um crescimento significativo nos \u00faltimos anos e \u00e9 hoje uma das linguagens de programa\u00e7\u00e3o mais populares no mundo, sendo amplamente utilizada por grandes empresas como Google, Netflix, Nasa, Dropbox, e muitos outros. Neste primeiro handout vamos desenvolver nossos primeiros programas em Python, utilizando os seguintes conceitos b\u00e1sicos de programa\u00e7\u00e3o: opera\u00e7\u00f5es matem\u00e1ticas, vari\u00e1veis e fun\u00e7\u00f5es.","title":"O Python"},{"location":"aulas/01-funcoes/#instalacao","text":"Existem diversas formas de instalar o Python. Recomendamos a instala\u00e7\u00e3o atrav\u00e9s do Anaconda, que j\u00e1 inclui o Python e alguns m\u00f3dulos adicionais que ser\u00e3o \u00fateis em outras disciplinas. Para isso, acesse o link de instala\u00e7\u00e3o referente ao seu sistema operacional: Windows: https://docs.anaconda.com/anaconda/install/windows/ macOS: https://docs.anaconda.com/anaconda/install/mac-os/ Linux: https://docs.anaconda.com/anaconda/install/linux/ Para escrever e editar o nosso c\u00f3digo ser\u00e1 necess\u00e1rio utilizarmos um editor de c\u00f3digo. Existem diversas alternativas, mas nesta disciplina focaremos no Visual Studio Code (VS Code), um dos editores mais populares atualmente. Veremos que o c\u00f3digo \u00e9 essencialmente texto, ent\u00e3o poder\u00edamos utilizar qualquer editor de texto dispon\u00edvel, mas editores como o VS Code possuem diversas ferramentas que facilitam o desenvolvimento. \u00c9 prov\u00e1vel que o VS Code j\u00e1 tenha sido instalado juntamente com o Anaconda. Para verificar, abra o Anaconda Navigator (um programa instalado com o Anaconda), procure pelo VS Code e clique em Launch . Se ele mostrar a op\u00e7\u00e3o de instalar, voc\u00ea pode instal\u00e1-lo pelo pr\u00f3prio Anaconda Navigator. Caso contr\u00e1rio, voc\u00ea pode fazer o download no seguinte link: https://code.visualstudio.com/Download","title":"Instala\u00e7\u00e3o"},{"location":"aulas/01-funcoes/#ola-mundo","text":"Quando vamos aprender uma nova linguagem de programa\u00e7\u00e3o \u00e9 comum escrevermos um primeiro programa que, ao ser executado, mostra na tela o texto Hello, world! (\"Ol\u00e1, mundo!\"). Apesar de ser um programa muito simples, ele j\u00e1 nos permite come\u00e7ar a compreender dois aspectos da linguagem: Qual \u00e9 a \"cara\" da linguagem, ou seja, qual \u00e9 a estrutura b\u00e1sica do c\u00f3digo. Como executar um programa escrito nessa linguagem. Ent\u00e3o m\u00e3os \u00e0 obra!","title":"Ol\u00e1 Mundo!"},{"location":"aulas/01-funcoes/#exercicio-1","text":"Siga os passos a seguir para escrever e executar seu primeiro programa em Python: Abra o VS Code. Crie um novo arquivo clicando em \"File \u2192 New File\" ou utilizando o atalho Ctrl + N (Windows)/ Cmd + N (macOS). Salve o arquivo com o nome hello.py . Para isso, clique em \"File \u2192 Save\", preencha o nome, escolha uma pasta para salvar o arquivo e clique em \"Save\". Digite o c\u00f3digo print ( 'Hello, world!' ) Salve o arquivo clicando em \"File \u2192 Save\" ou usando o atalho Ctrl + S (Windows)/ Cmd + S (macOS). Execute seu programa. Para executar um programa em Python, temos quatro possibilidades: Clique em \"Run \u2192 Run Without Debugging\" Utilize o atalho Ctrl + F5 Clique na setinha verde no canto superior direito: [Avan\u00e7ado] Utilizando o terminal para ir at\u00e9 a pasta onde se encontra o arquivo e executando-o com o comando python hello.py O texto Hello, world! deve aparecer no terminal.","title":"EXERC\u00cdCIO 1"},{"location":"aulas/01-funcoes/#entendendo-nosso-primeiro-programa","text":"Nosso c\u00f3digo possui apenas uma linha, mas j\u00e1 cont\u00e9m diversos conceitos importantes. N\u00e3o se preocupe se n\u00e3o entender toda a explica\u00e7\u00e3o a seguir, tudo ficar\u00e1 mais claro conforme formos aprendendo mais. A linha print ( 'Hello, world!' ) pode ser lida como: \"Python, por favor, mostre na tela o texto Hello , world ! . Vamos por partes. Comecemos pela a fun\u00e7\u00e3o print . Essa fun\u00e7\u00e3o \u00e9 utilizada para mostrar texto no terminal. Podemos entender uma fun\u00e7\u00e3o como um comando do Python, ou seja, estamos dizendo para o Python fazer algo. A a\u00e7\u00e3o de mostrar algo na tela depende de uma informa\u00e7\u00e3o adicional: o que deve ser mostrado. Essa informa\u00e7\u00e3o da qual a a\u00e7\u00e3o depende \u00e9 chamada de argumento da fun\u00e7\u00e3o . No nosso exemplo, o argumento da fun\u00e7\u00e3o print \u00e9 o texto 'Hello, world!' . Um \u00faltimo detalhe importante \u00e9 o uso das aspas. Para indicar que Hello , world ! \u00e9 um texto n\u00f3s utilizamos aspas, que podem ser simples ou duplas. Isso \u00e9 muito importante, pois o que estiver entre aspas ser\u00e1 considerado pelo Python como texto (que chamamos de string ) e n\u00e3o como um comando (por exemplo a fun\u00e7\u00e3o print ). Dica Pro: documente o c\u00f3digo! Uma li\u00e7\u00e3o a ser aprendida \u00e9 que passamos muito mais tempo lendo c\u00f3digo pr\u00e9-existente do que escrevendo c\u00f3digo novo. Por isso a documenta\u00e7\u00e3o do c\u00f3digo \u00e9 uma pr\u00e1tica extremamente importante. A documenta\u00e7\u00e3o pode ser feita por meio de coment\u00e1rios, trechos de texto que n\u00e3o afetam o comportamento do programa, que ajudam o leitor (seja algum colega de trabalho que n\u00e3o conhece o c\u00f3digo ou voc\u00ea mesmo algum tempo no futuro) a compreender o c\u00f3digo. Veja a seguir um exemplo do mesmo programa que acabamos de executar, mas com documenta\u00e7\u00e3o: \"\"\" Programa que escreve \"Hello, world!\" no console. Serve para verificar se conseguimos usar o Python pela primeira vez. @author: Profs. Design de Software \"\"\" print ( 'Hello, world!' ) O texto entre \"\"\" ser\u00e1 ignorado pelo programa. Note que nesse coment\u00e1rio podemos encontrar informa\u00e7\u00f5es como: O que o c\u00f3digo faz; Por que ele foi escrito; Quem escreveu o c\u00f3digo. Esse primeiro programa ainda \u00e9 muito simples, mas conforme formos desenvolvendo programas mais complexos os coment\u00e1rios se tornam cada vez mais relevantes. Buscando ajuda Depois de pensar e tentar resolver problemas por conta pr\u00f3pria e n\u00e3o encontrar a solu\u00e7\u00e3o, n\u00e3o tenha vergonha de procurar ajuda na internet. At\u00e9 mesmo programadores experientes fazem isso. \u00c9 importante, entretanto, saber como fazer essas buscas: que termos usar, quais respostas confiar, etc. Voc\u00ea vai desenvolver uma intui\u00e7\u00e3o conforme for ganhando experi\u00eancia, mas para te ajudar neste come\u00e7o, escrevemos um pequeno guia com algumas dicas .","title":"Entendendo nosso primeiro programa"},{"location":"aulas/01-funcoes/#operacoes-matematicas","text":"Queremos usar o Python para fazer algo al\u00e9m de s\u00f3 mostrar um texto na tela. Para isso vamos come\u00e7ar aprendendo sobre como realizar opera\u00e7\u00f5es matem\u00e1ticas.","title":"Opera\u00e7\u00f5es matem\u00e1ticas"},{"location":"aulas/01-funcoes/#exercicio-2","text":"Crie um novo arquivo chamado operadores.py no VS Code e copie o c\u00f3digo a seguir. Execute-o e tente identificar a partir dos resultados o que cada operador faz. Discuta com seus colegas. print ( 'Usando alguns operadores num\u00e9ricos:' ) print ( 2 + 3 ) print ( 2 - 3 ) print ( 2 * 3 ) print ( 2 ** 3 ) print ( 7 / 3 ) print ( 7 // 3 ) print ( 7 % 3 ) print (( 1 + 2 ) * ( - 3 - 2 )) Importante O programa em Python \u00e9 executado linha a linha, ou seja, as linhas do programa s\u00e3o executadas uma ap\u00f3s a outra de cima para baixo. Uma linha de c\u00f3digo s\u00f3 \u00e9 executada depois que a linha anterior terminou de executar. Resposta Leia a resposta apenas depois de discutir com seus colegas. O c\u00f3digo abaixo foi comentado com as respostas. Coment\u00e1rios em Python s\u00e3o iniciados com o caractere cerquilha ( # ). Tudo o que vier depois desse caractere ser\u00e1 ignorado pelo programa. \"\"\" Programa para demonstrar alguns operadores num\u00e9ricos. @author: Profs. Design de Software \"\"\" print ( 'Usando alguns operadores num\u00e9ricos:' ) print ( 2 + 3 ) # Soma. print ( 2 - 3 ) # Subtra\u00e7\u00e3o. print ( 2 * 3 ) # Multiplica\u00e7\u00e3o. print ( 2 ** 3 ) # Potencia\u00e7\u00e3o ou exponencia\u00e7\u00e3o. # Operadores de divis\u00e3o print ( 7 / 3 ) # Divis\u00e3o. print ( 7 // 3 ) # Divis\u00e3o inteira: quociente. print ( 7 % 3 ) # Resto da divis\u00e3o inteira. # \u00c9 poss\u00edvel utilizar par\u00eanteses para modificar a ordem # de aplica\u00e7\u00e3o das opera\u00e7\u00f5es. print (( 1 + 2 ) * ( - 3 - 2 )) # Par\u00eanteses. Mais alguns detalhes... No programa acima podemos observar mais alguns detalhes: A cerquilha ( # ) que inicia um coment\u00e1rio pode ser inserida no come\u00e7o de uma linha ou precedida por 2 espa\u00e7os depois de um trecho de c\u00f3digo. Esses dois espa\u00e7os antes da cerquilha n\u00e3o s\u00e3o obrigat\u00f3rios, mas s\u00e3o um padr\u00e3o adotado pela comunidade Python. Os operadores e n\u00fameros est\u00e3o separados por espa\u00e7os. Esses espa\u00e7os tamb\u00e9m n\u00e3o s\u00e3o obrigat\u00f3rios, mas facilitam na interpreta\u00e7\u00e3o visual. A ordem de prioridade dos operadores em Python segue a conven\u00e7\u00e3o matem\u00e1tica do PEMDAS: P ar\u00eanteses t\u00eam a maior prioridade e pode ser usado para for\u00e7ar uma express\u00e3o a ser avaliada na ordem que voc\u00ea quiser. E xponencia\u00e7\u00e3o tem a pr\u00f3xima preced\u00eancia mais alta. M ultiplica\u00e7\u00e3o e D ivis\u00e3o t\u00eam a mesma preced\u00eancia, que \u00e9 maior do que a A di\u00e7\u00e3o e S ubtra\u00e7\u00e3o. Al\u00e9m disso, as opera\u00e7\u00f5es de mesma prioridade s\u00e3o avaliadas da esquerda para a direita.","title":"EXERC\u00cdCIO 2"},{"location":"aulas/01-funcoes/#exercicio-3","text":"Escreva um programa em Python que imprime (mostra na tela com o comando print ) o resultado das seguintes express\u00f5es num\u00e9ricas: 1 + \\frac{1}{2} + \\frac{1}{2^2} + \\frac{1}{2^3} + \\frac{1}{2^4} 1 + \\frac{1}{2} + \\frac{1}{2^2} + \\frac{1}{2^3} + \\frac{1}{2^4} (resposta esperada: 1.9375 ) \\frac{3\\cdot4+5}{1+2\\cdot3} \\frac{3\\cdot4+5}{1+2\\cdot3} (resposta esperada: 2.4285714285714284 \u2192 n\u00e3o se preocupe se der alguma diferen\u00e7a nas \u00faltimas casas decimais) \\sqrt{3^2+4^2} \\sqrt{3^2+4^2} (resposta esperada: 5.0 )","title":"EXERC\u00cdCIO 3"},{"location":"aulas/01-funcoes/#variaveis","text":"Podemos armazenar valores ou resultados de express\u00f5es matem\u00e1ticas em vari\u00e1veis. Uma vari\u00e1vel \u00e9 como se fosse uma caixa com uma etiqueta com o seu nome. O conte\u00fado armazenado na caixa pode ser acessado a partir do nome em sua etiqueta. Considere o exemplo a seguir: x = 5 print ( x ) Devemos ler a primeira linha como: \"a vari\u00e1vel x recebe o valor 5\". \u00c9 como se diss\u00e9ssemos: \"interpretador Python, por favor, crie na mem\u00f3ria do computador uma caixa chamada x e guarde l\u00e1 dentro o valor 5 .\" A linha seguinte pede para o Python imprimir o conte\u00fado da vari\u00e1vel x , nesse caso, 5 . Assim, o Python vai escrever 5 no terminal. Podemos usar vari\u00e1veis dentro de outras express\u00f5es. Por exemplo: x = 3 y = 4 z = x * y print ( 'O ret\u00e2ngulo de lados {0} e {1} tem \u00e1rea {2} ' . format ( x , y , z )) Info Usamos o . format () para escrever valores no meio do texto. \u00c9 importante notar que: A sequ\u00eancia dos argumentos (conte\u00fado dentro dos par\u00eanteses do . format () ) \u00e9 importante. O primeiro argumento ( x ) ser\u00e1 inserido no lugar do { 0 } , o segundo argumento ( y ) ser\u00e1 inserido no lugar do { 1 } e o terceiro argumento ( z ) ser\u00e1 inserido no lugar do { 2 } . Em Python (e em programa\u00e7\u00e3o em geral) come\u00e7amos a contar a partir do zero, ou seja, 0 \u00e9 o primeiro, 1 \u00e9 o segundo, 2 \u00e9 o terceiro e assim por diante. O . format () \u00e9 executado primeiro, escrevendo os valores no meio do texto, e depois o resultado \u00e9 utilizado pela fun\u00e7\u00e3o print() , mostrando o resultado na tela.","title":"Vari\u00e1veis"},{"location":"aulas/01-funcoes/#exercicio-4","text":"Acesse o servidor de desafios ( http://softdes.insper.edu.br/ ). A sua senha \u00e9 igual ao seu login e ambos s\u00e3o iguais ao seu login do Insper. Por exemplo, se o seu login do Insper \u00e9 fulano123 , o seu login no servidor ser\u00e1 fulano123 e a sua senha tamb\u00e9m ser\u00e1 fulano123 . Se voc\u00ea n\u00e3o conseguir acessar, \u00e9 poss\u00edvel que o seu login ainda n\u00e3o tenha sido criado. Nesse caso, pe\u00e7a para o professor verificar se o seu usu\u00e1rio j\u00e1 foi criado. Resolva o [TESTE DE MESA] Vari\u00e1veis . Teste de Mesa O teste de mesa consiste em simular manualmente a execu\u00e7\u00e3o de um programa. O processo se d\u00e1 da seguinte forma: Execute as opera\u00e7\u00f5es da linha atual (no servidor de desafios a linha atual \u00e9 destacada em vermelho). No in\u00edcio da execu\u00e7\u00e3o a linha atual \u00e9 a primeira linha de c\u00f3digo. Atualize o valor das vari\u00e1veis na mem\u00f3ria. No servidor existe uma regi\u00e3o \u00e0 direita chamada \"Mem\u00f3ria\". Voc\u00ea deve atualizar as vari\u00e1veis nessa regi\u00e3o com os valores obtidos ap\u00f3s a execu\u00e7\u00e3o da linha atual. Se a linha atual n\u00e3o modificou alguma vari\u00e1vel ela deve permanecer inalterada na mem\u00f3ria. Se a fun\u00e7\u00e3o print foi utilizada na linha atual, escreva na regi\u00e3o chamada \"Sa\u00edda do terminal\" (fundo preto) o que aparecer\u00e1 no terminal. Prepare-se para a execu\u00e7\u00e3o da pr\u00f3xima linha. No servidor \u00e9 necess\u00e1rio selecionar o n\u00famero da pr\u00f3xima linha a ser executada em \"Pr\u00f3xima linha\". Clique em \"Pr\u00f3ximo passo\". \u00c9 poss\u00edvel realizar um teste de mesa apenas com papel e caneta. Voc\u00ea pode sempre utilizar esse processo para verificar se o seu programa faz o que era esperado. Podemos usar vari\u00e1veis para armazenar qualquer tipo de dados em Python: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \"\"\" Demonstra\u00e7\u00e3o de uso de vari\u00e1veis com diversos tipos de dados em Python. @author: Profs. de Design de Software. \"\"\" # Vari\u00e1veis podem armazenar texto (strings). disciplina = 'Design de Software' print ( disciplina ) # Vari\u00e1veis podem armazenar inteiros. num_alunos = 120 # Vari\u00e1veis podem armazenar os valores especiais True e False # S\u00e3o usados em express\u00f5es l\u00f3gicas, ou tamb\u00e9m chamadas # express\u00f5es booleanas. a = True b = False c = a or b # Opera\u00e7\u00e3o booleana 'OU'. # Vari\u00e1veis podem armazenar n\u00fameros reais. Em computa\u00e7\u00e3o, # estes n\u00fameros s\u00e3o chamados de n\u00fameros em ponto flutuante. base = 0.5 altura = 4.2e1 # 4.2 x 10**1 => 42.0 area = base * altura / 2.0 # Vari\u00e1veis armazenam muitos outros tipos que veremos depois. ponto = ( 3.2 , 5.7 ) # Tupla. teste = [ 5.2 , 'laranja' , False , 42 ] # Lista. notas = { 'dessoft' : 10.0 , 'gde' : 10.0 , 'modsim' : 10.0 } # dicion\u00e1rio. Warning Considere as linhas 8 e 9. Aqui vemos a import\u00e2ncia das aspas. Ao executar a linha 9 o Python mostrar\u00e1 na tela a string armazenada na vari\u00e1vel disciplina , ou seja, Design de Software . Se utiliz\u00e1ssemos aspas na linha 9 ( print ( 'disciplina' ) ) o Python mostraria o texto disciplina no terminal.","title":"EXERC\u00cdCIO 4"},{"location":"aulas/01-funcoes/#exercicio-5","text":"Fa\u00e7a o [TESTE DE MESA] Mais vari\u00e1veis .","title":"EXERC\u00cdCIO 5"},{"location":"aulas/01-funcoes/#funcoes","text":"J\u00e1 vimos como criar valores num\u00e9ricos e de texto puro em Python (chamados em Python de \"literais\") e vari\u00e1veis. Tudo isso parece muito com a boa e velha matem\u00e1tica. E j\u00e1 que estamos vendo todas essas rela\u00e7\u00f5es, um outro conceito importante em matem\u00e1tica s\u00e3o fun\u00e7\u00f5es. Por exemplo: f(x) = 1.60934\\cdot x f(x) = 1.60934\\cdot x Essa fun\u00e7\u00e3o converte valores em milhas ( x x ) para quil\u00f4metros. Por exemplo: f(10) = 1.60934\\cdot 10 = 16.0934 f(10) = 1.60934\\cdot 10 = 16.0934 , ou seja, 10 milhas \u00e9 o mesmo que 16.0934 km. O Python tamb\u00e9m nos permite criar fun\u00e7\u00f5es! Escrevendo a mesma fun\u00e7\u00e3o acima em Python: 1 2 3 def f ( x ): y = 1.60934 * x return y Novamente temos muitas observa\u00e7\u00f5es importantes. Vamos come\u00e7ar pelos nomes: O x na linha 1 \u00e9 chamado de argumento da fun\u00e7\u00e3o. O y na linha 3 \u00e9 chamado de retorno ou resultado da fun\u00e7\u00e3o. As linhas 2 e 3 s\u00e3o chamadas de corpo ou bloco da fun\u00e7\u00e3o. O corpo da fun\u00e7\u00e3o \u00e9 identificado com os 4 espa\u00e7os no come\u00e7o da linha. Esses 4 espa\u00e7os s\u00e3o chamados de indenta\u00e7\u00e3o . Indenta\u00e7\u00e3o A indenta\u00e7\u00e3o \u00e9 crucial e Python e tem um significado especial. Ela \u00e9 utilizada para indicar blocos de c\u00f3digo. Portanto n\u00e3o se deve utilizar indenta\u00e7\u00f5es a mais ou a menos, pois isso causar\u00e1 um erro na execu\u00e7\u00e3o do programa. O uso de 4 espa\u00e7os \u00e9 outra padroniza\u00e7\u00e3o da comunidade Python. Se voc\u00ea usar 2, 3 ou qualquer outra quantidade de espa\u00e7os (ou at\u00e9 mesmo o caractere Tab ) o c\u00f3digo funcionar\u00e1 da mesma forma. Desde que seja consistente, ou seja, escolha um formato e utilize-o em todo o seu programa. Recomendamos que voc\u00ea utilize 4 espa\u00e7os para seguir o padr\u00e3o da comunidade. Se voc\u00ea executar o c\u00f3digo acima n\u00e3o vai acontecer nada. Nesse c\u00f3digo n\u00f3s estamos apenas definindo a fun\u00e7\u00e3o f (por isso a palavra def ). Podemos entender a linha 1 como: \"Python, quando eu pedir para voc\u00ea executar a fun\u00e7\u00e3o f , passando um valor para x , o que voc\u00ea deve fazer \u00e9: multiplicar o valor armazenado na vari\u00e1vel x por 1.60934 e guardar o resultado na vari\u00e1vel y e depois devolver o valor armazenado na vari\u00e1vel y como o resultado\". Em outras palavras, \u00e9 como se estiv\u00e9ssemos criando um novo comando do Python (assim como j\u00e1 temos o print , por exemplo).","title":"Fun\u00e7\u00f5es"},{"location":"aulas/01-funcoes/#chamando-funcoes-em-python","text":"Considere novamente a fun\u00e7\u00e3o matem\u00e1tica f(x) f(x) vista acima . Note que n\u00e3o existe um valor, ou resultado, para f(x) f(x) a n\u00e3o ser que voc\u00ea defina quanto vale o x x . Da mesma forma, n\u00e3o existe um resultado, ou valor de retorno, para a fun\u00e7\u00e3o f ( x ) no Python a n\u00e3o ser que definamos um valor para x . Essa ideia \u00e9 a mesma que apresentamos sobre a fun\u00e7\u00e3o print , ou seja, precisamos de uma informa\u00e7\u00e3o adicional. Uma vez que definimos uma fun\u00e7\u00e3o \u00e9 como se ela se tornasse parte da linguagem Python. Assim, para esse contexto introdut\u00f3rio, n\u00e3o existe nenhuma diferen\u00e7a entre a fun\u00e7\u00e3o print e a fun\u00e7\u00e3o f ( x ) em termos de import\u00e2ncia. Ambas s\u00e3o comandos dispon\u00edveis no Python para o programador utilizar em seu c\u00f3digo. Vamos ent\u00e3o ver um exemplo de uso da nossa fun\u00e7\u00e3o f ( x ) . Considere o c\u00f3digo a seguir: 1 2 3 4 5 6 7 def f ( x ): y = 1.60934 * x return y a = 10 b = f ( a ) print ( b ) Nas linhas 1 a 3 a fun\u00e7\u00e3o f ( x ) \u00e9 definida, ou seja, ap\u00f3s a execu\u00e7\u00e3o dessas linhas o Python sabe o que fazer sempre que precisarmos dessa fun\u00e7\u00e3o. Na linha 5, armazenamos o n\u00famero 10 na vari\u00e1vel a . Na linha 6 ocorre a chamada da fun\u00e7\u00e3o. Vamos detalhar o que ocorre nessa linha: O valor da vari\u00e1vel a \u00e9 utilizado, o Python consulta esse valor na mem\u00f3ria e substitui na chamada da fun\u00e7\u00e3o. Agora a linha \u00e9 equivalente a b = f ( 10 ) . A fun\u00e7\u00e3o f () \u00e9 executada com o argumento 10 . A pr\u00f3xima linha executada \u00e9 a linha 1. O Python cria uma nova regi\u00e3o tempor\u00e1ria na mem\u00f3ria. Essa mem\u00f3ria s\u00f3 existir\u00e1 enquanto a fun\u00e7\u00e3o estiver sendo executada. Na linha 1 \u00e9 criada uma vari\u00e1vel chamada x nessa mem\u00f3ria tempor\u00e1ria, armazenando o valor recebido como argumento, no caso 10 . Na linha 2 o valor x \u00e9 substitu\u00eddo por 10 e o valor 16.0934 (resultado da multiplica\u00e7\u00e3o) \u00e9 armazenado na vari\u00e1vel y , tamb\u00e9m na mem\u00f3ria tempor\u00e1ria. Na linha 3 o valor guardado na vari\u00e1vel y \u00e9 devolvido como resultado. A mem\u00f3ria tempor\u00e1ria criada para a fun\u00e7\u00e3o f () \u00e9 desativada. A partir deste momento as vari\u00e1veis que estavam contidas nela ( x e y ) n\u00e3o existem mais. Voltamos para a linha 6. Agora que temos o resultado da fun\u00e7\u00e3o a linha \u00e9 equivalente a b = 16.0934 . O valor 16.0934 \u00e9 armazenado na vari\u00e1vel b Por fim, na linha 7, o valor armazenado na vari\u00e1vel b \u00e9 utilizado como argumento da fun\u00e7\u00e3o print () e o valor 16.0934 \u00e9 mostrado no terminal.","title":"Chamando fun\u00e7\u00f5es em Python"},{"location":"aulas/01-funcoes/#exercicio-6","text":"Fa\u00e7a o [TESTE DE MESA] Converte milhas para km para consolidar a sua compreens\u00e3o sobre fun\u00e7\u00f5es em Python. Dica Pro: use bons nomes! No dia seguinte voc\u00ea abre esse programa . O que faz mesmo esse c\u00f3digo? Acredite, \u00e9 mais comum do que voc\u00ea imagina. Enquanto estamos desenvolvendo o programa temos muito claro para qu\u00ea cada vari\u00e1vel serve, mas n\u00e3o precisamos de muito tempo para olhar o mesmo c\u00f3digo e n\u00e3o ter ideia do que est\u00e1 acontecendo. Por isso, use nomes que fa\u00e7am sentido para as suas vari\u00e1veis e fun\u00e7\u00f5es. Quando n\u00e3o estiver claro o suficiente, adicione coment\u00e1rios, mas as vezes boas escolhas de nomes dispensam coment\u00e1rios no c\u00f3digo. Considere a vers\u00e3o a seguir (ela faz exatamente o mesmo que o nosso c\u00f3digo anterior): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \"\"\" Programa que converte de milhas para quil\u00f4metros. Vers\u00e3o melhor documentada. @author: Profs. de Design de Software \"\"\" # Fun\u00e7\u00e3o que converte um valor de dist\u00e2ncia # dado em milhas para quil\u00f4metros. def converte_milhas_para_km ( distancia_mi ): distancia_km = 1.60934 * distancia_mi return distancia_km # Quanto \u00e9 10 mi em km? milhas = 10 km = converte_milhas_para_km ( milhas ) print ( km ) Neste exemplo os coment\u00e1rios poderiam at\u00e9 ser removidos, pois o nome da fun\u00e7\u00e3o j\u00e1 deixa claro o que ela faz.","title":"EXERC\u00cdCIO 6"},{"location":"aulas/01-funcoes/#exercicio-7","text":"No servidor, fa\u00e7a o exerc\u00edcio 6. Celsius para Fahrenheit . Primeiro resolva em seu pr\u00f3prio computador, fazendo testes com alguns valores espec\u00edficos (ex: 0 e 100). Depois disso, envie apenas a defini\u00e7\u00e3o da fun\u00e7\u00e3o, sem o c\u00f3digo que chama a fun\u00e7\u00e3o. Por exemplo, no programa que desenvolvemos acima , voc\u00ea enviaria apenas as linhas 1 a 3. Sempre que o exerc\u00edcio do servidor pedir uma fun\u00e7\u00e3o voc\u00ea deve enviar apenas a defini\u00e7\u00e3o da fun\u00e7\u00e3o, sem o c\u00f3digo de teste que chama a fun\u00e7\u00e3o.","title":"EXERC\u00cdCIO 7"},{"location":"aulas/01-funcoes/#exercicio-8","text":"Fa\u00e7a o exerc\u00edcio 7. \u00c1rea do tri\u00e2ngulo no servidor. Dica: uma fun\u00e7\u00e3o em Python, assim como uma fun\u00e7\u00e3o matem\u00e1tica multivariada, pode receber v\u00e1rios argumentos separados por v\u00edrgula. N\u00e3o esque\u00e7a de escrever c\u00f3digo de teste tamb\u00e9m. Pense em valores de teste que sejam interessantes. Por exemplo: e se a base for zero? E se a altura for zero? E se forem iguais?","title":"EXERC\u00cdCIO 8"},{"location":"aulas/02-io/","text":"02 - Input e String \u00b6 Relembrando a aula passada... \u00b6 Vamos come\u00e7ar relembrando o que aprendemos na aula passada com um exerc\u00edcio. Exerc\u00edcio 1 \u00b6 Fa\u00e7a uma fun\u00e7\u00e3o que recebe um n\u00famero e calcula: f(x) = (-1)^x f(x) = (-1)^x Para testar, fa\u00e7a um programa que chama a sua fun\u00e7\u00e3o com argumentos diferentes. Mesmo que voc\u00ea tenha certeza que o seu programa est\u00e1 funcionando, \u00e9 importante test\u00e1-lo. Por exemplo, qual \u00e9 o resultado de f(0) f(0) ? E f(1) f(1) , f(2) f(2) , f(-1) f(-1) ? Quantos testes voc\u00ea deve fazer para garantir que sua fun\u00e7\u00e3o est\u00e1 correta? Reflita: o que a sua fun\u00e7\u00e3o faz? Qual seria um nome melhor para esta fun\u00e7\u00e3o? Se voc\u00ea teve dificuldades para resolver este exerc\u00edcio, fa\u00e7a tamb\u00e9m o [TESTE DE MESA] Verifica par ou \u00edmpar . Exerc\u00edcios adicionais \u00b6 Caso voc\u00ea termine o programa acima antes da discuss\u00e3o com a sala, resolva os seguintes exerc\u00edcios no servidor : Exerc\u00edcio 8: Movimento retil\u00edneo uniforme Exerc\u00edcio 9: Volume de uma esfera Exerc\u00edcio 14: Lan\u00e7amento de proj\u00e9til Pedindo dados para o usu\u00e1rio \u00b6 At\u00e9 agora fizemos programas que, ao serem executados, sempre fazem exatamente a mesma coisa. Seria interessante permitir algum tipo de intera\u00e7\u00e3o com o usu\u00e1rio. Por enquanto estamos desenvolvendo programas que imprimem valores no terminal, ent\u00e3o tamb\u00e9m vamos utilizar o terminal para receber dados digitados pelo usu\u00e1rio. Em Python, a fun\u00e7\u00e3o input () pede um texto para o usu\u00e1rio e retorna este texto ao programa. Voc\u00ea pode, por exemplo, guardar esse texto em uma vari\u00e1vel para usar em seguida. Teste o seguinte programa no seu computador: # Pede a cor favorita para o usu\u00e1rio. cor_favorita = input ( 'Qual a sua cor favorita? ' ) # Imprime a cor favorita do usu\u00e1rio. print ( cor_favorita ) O programa acima deve imprimir Qual a sua cor favorita? (note que existe um espa\u00e7o ap\u00f3s a interroga\u00e7\u00e3o) no terminal e parar. Nesse momento ele est\u00e1 esperando que o usu\u00e1rio digite algo no terminal. At\u00e9 que isso aconte\u00e7a, o programa fica parado na chamada da fun\u00e7\u00e3o input () . Praticando o uso do input \u00b6 Considere a seguinte fun\u00e7\u00e3o: # Fun\u00e7\u00e3o que soma dois n\u00fameros. def soma ( x , y ): z = x + y return z Se criarmos um arquivo .py contendo somente esta fun\u00e7\u00e3o, o que voc\u00ea espera que aconte\u00e7a? Rode seu programa. Ele fez o que voc\u00ea esperava? O programa acima n\u00e3o vai fazer nada. N\u00f3s s\u00f3 estamos definindo a fun\u00e7\u00e3o soma , mas n\u00e3o estamos pedindo para o Python execut\u00e1-la (ou seja, n\u00e3o estamos chamando a fun\u00e7\u00e3o). O programa a seguir deve imprimir a soma dos n\u00fameros 14 e 28: # Fun\u00e7\u00e3o que soma dois n\u00fameros. def soma ( x , y ): z = x + y return z # Testando nossa fun\u00e7\u00e3o resultado = soma ( 14 , 28 ) print ( resultado ) Teste o programa acima e verifique se ele faz o que era esperado. EXERC\u00cdCIO 2 \u00b6 Ao inv\u00e9s de deixarmos n\u00fameros fixos para testar a fun\u00e7\u00e3o, vamos perguntar para o usu\u00e1rio quais n\u00fameros ele quer somar. Teste o seguinte programa: # Fun\u00e7\u00e3o que soma dois n\u00fameros. def soma ( x , y ): z = x + y return z # Lendo os dois n\u00fameros. a = input ( 'Entre com o primeiro n\u00famero: ' ) b = input ( 'Entre com o segundo n\u00famero: ' ) # Somando os dois n\u00fameros. c = soma ( a , b ) print ( c ) Seu programa funcionou? Deu algum erro? Fez o que voc\u00ea esperava? Vamos tentar entender o que est\u00e1 acontecendo. Lembre-se que a fun\u00e7\u00e3o input () devolve o texto digitado pelo usu\u00e1rio. Na nossa soma, queremos adicionar n\u00fameros , n\u00e3o texto . Vamos tentar entender melhor o que est\u00e1 acontecendo. Tipos de dados em Python \u00b6 Vimos na aula passada que podemos guardar qualquer coisa em vari\u00e1veis no Python. O que n\u00f3s n\u00e3o discutimos foi que essas \"coisas\" que podemos guardar nas vari\u00e1veis possuem tipos espec\u00edficos. No in\u00edcio vamos trabalhar com 4 tipos b\u00e1sicos: Inteiro ( int ) : um n\u00famero sem casa decimal. Ex: 34 , 96 , - 123 , 45 ; Float ( float ) : um n\u00famero real, com \"ponto decimal\" (tamb\u00e9m chamamos de \"ponto flutuante\"). Ex: 3.14 , - 25.1 , 5.0 , 5e-1 ; String ( str ) : texto puro (\u00e9 representado necessariamente com aspas simples ou duplas). Ex: \"Hello, world!\" , 'Insper' , '3.14' , '\"oi\"' ; Booleano ( bool ) : representam \"verdadeiro\" ( True ) e \"falso\" ( False ). EXERC\u00cdCIO 3: Convers\u00e3o entre tipos \u00b6 O Python disponibiliza algumas fun\u00e7\u00f5es que convertem um valor de um tipo para outro. Teste o seguinte programa: # Converte para inteiro. print ( int ( 3.14 )) # Converte para float. print ( float ( 4 )) # Converte para string. print ( str ( 123 )) # Converte de string para int. print ( int ( '42' )) # Converte de string para float. print ( float ( '1.625' )) # What ?!? print ( float ( 'banana' )) Erros na execu\u00e7\u00e3o Seu programa deve ter apresentado um erro parecido com o seguinte: ValueError : could not convert string to float : 'banana' . Ser\u00e1 muito comum encontrarmos erros em nosso programa. A primeira dica \u00e9: n\u00e3o entre em p\u00e2nico. A segunda \u00e9: leia a mensagem de erro com aten\u00e7\u00e3o. Exerc\u00edcio adicional \u00b6 O comando int ( 3.14 ) gerou o n\u00famero inteiro 3 . Mas ser\u00e1 que ele arredondou o valor? Teste o comando int ( 2.718 ) . Assumindo que a fun\u00e7\u00e3o int () arredonda o valor, o resultado esperado seria 3 . Rode seu programa. Qual foi o resultado? O que isso diz sobre a fun\u00e7\u00e3o int ? EXERC\u00cdCIO 4: Agora vai! \u00b6 Corrija o programa do exerc\u00edcio 3 sabendo que o input () sempre devolve uma string , ou seja, o texto digitado pelo usu\u00e1rio e a nossa fun\u00e7\u00e3o soma ( x , y ) recebe dois n\u00fameros . Formata\u00e7\u00e3o de strings \u00b6 Na aula passada vimos que podemos formatar uma string utilizando a fun\u00e7\u00e3o . format () para incluir os valores armazenados em vari\u00e1veis. Por exemplo: a = 10 b = 7 texto = 'a vale {0} , b vale {1} e a + b = {2} ' . format ( a , b , a + b ) print ( texto ) Esse programa vai imprimir a vale 10 , b vale 7 e a + b = 17 no terminal. Agora, o que acontece se o valor da vari\u00e1vel for um float ? Teste o programa a seguir. import math print ( 'pi \u00e9 {0} mais ou menos' . format ( math . pi )) Quantas casas decimais do n\u00famero pi foram apresentadas? E se quisermos mostrar apenas as 3 primeiras? Para isso podemos usar diretivas de formata\u00e7\u00e3o , que podem ser especificadas com um \" : \" (dois pontos) depois do \u00edndice. Por exemplo ' {0:.1f} , {1:.4f} ' . format ( 1.23456 , 7.89123 ) vai gerar a string '1.2, 7.8912' . Vamos por partes: EXERC\u00cdCIO 5 \u00b6 Modifique o programa que imprime o valor de pi para que ele mostre somente as 3 primeiras casas decimais. Maneiras antigas de formatar strings em Python Se voc\u00ea procurar na internet por \"formata\u00e7\u00e3o de strings em Python\" ou algum termo an\u00e1logo, \u00e9 bastante prov\u00e1vel que voc\u00ea encontre formas diferentes da que apresentamos acima. Por exemplo: nome = \"Mateus\" texto = \"Meu nome \u00e9 %s \" % nome print ( texto ) N\u00e3o se preocupe se n\u00e3o entender esse trecho de c\u00f3digo. Essa \u00e9 a maneira antiga de formatar strings em Python. Procure utilizar a maneira nova que ensinamos, pois ela \u00e9 mais flex\u00edvel. Opera\u00e7\u00f5es com strings \u00b6 No programa do exerc\u00edcio 2 n\u00f3s obtivemos um comportamento diferente do que esper\u00e1vamos (se precisar, execute o programa novamente para relembrar). Nessa vers\u00e3o do programa, se o usu\u00e1rio digitar 4 e 2 o programa vai imprimir que a soma vale 42 . Vimos que isso ocorre porque a fun\u00e7\u00e3o input () sempre devolve uma string, ent\u00e3o o que o programa fez foi juntar a string '4' com a string '2' , obtendo a string '42' . Essa opera\u00e7\u00e3o de \"juntar strings\" \u00e9 o que chamamos de concatena\u00e7\u00e3o . EXERC\u00cdCIO 6 \u00b6 Antes de executar o programa a seguir, reflita: o que voc\u00ea espera que seja a sa\u00edda dele, ou seja, o que voc\u00ea espera que apare\u00e7a no terminal? Depois que tiver sua hip\u00f3tese, execute o programa. s1 = 'Ins' s2 = 'per' s = s1 + s2 print ( s ) t = s2 + s1 print ( t ) Se o programa n\u00e3o fez o que voc\u00ea esperava, discuta com seus colegas. Se n\u00e3o conseguirem resolver, converse com algum dos professores. EXERC\u00cdCIO 7 \u00b6 Vamos voltar por um instante para o contexto num\u00e9rico. Sabe-se que uma multiplica\u00e7\u00e3o \u00e9 equivalente \u00e0 adi\u00e7\u00e3o sucessiva de um mesmo n\u00famero. Por exemplo: 3 * 4 = 4 + 4 + 4 = 12 . Sabendo disso e considerando o que acabamos de aprender sobre concatena\u00e7\u00e3o ( + ) de strings, qual voc\u00ea espera que seja a sa\u00edda do programa a seguir? Execute-o para validar sua hip\u00f3tese. s1 = 'Ins' s2 = 'per' s = 3 * s1 + s2 print ( s ) Exerc\u00edcios adicionais \u00b6 Exerc\u00edcio 21: Total em segundos Exerc\u00edcio 22: Redu\u00e7\u00e3o no tempo de vida de um fumante Exerc\u00edcio 59: Repete asteriscos Se terminar os exerc\u00edcios acima, fa\u00e7a os outros exerc\u00edcios do servidor. Desafio \u00b6 Fa\u00e7a um programa que pergunta ao usu\u00e1rio um numero n entre 1 e 20 e imprime um quadrado de asteriscos n x n. Exemplo de uso: Digite n: 3 *** *** *** Para cumprir essa miss\u00e3o voc\u00ea precisa saber que a string \" \\n \" significa \"pule para a pr\u00f3xima linha\" . Por exemplo: print ( \"abc \\n de\" ) imprime abc de Refer\u00eancias \u00b6 https://docs.python.org/3.7/tutorial/inputoutput.html https://docs.python.org/3.7/library/string.html#formatspec","title":"Handout"},{"location":"aulas/02-io/#02-input-e-string","text":"","title":"02 - Input e String"},{"location":"aulas/02-io/#relembrando-a-aula-passada","text":"Vamos come\u00e7ar relembrando o que aprendemos na aula passada com um exerc\u00edcio.","title":"Relembrando a aula passada..."},{"location":"aulas/02-io/#exercicio-1","text":"Fa\u00e7a uma fun\u00e7\u00e3o que recebe um n\u00famero e calcula: f(x) = (-1)^x f(x) = (-1)^x Para testar, fa\u00e7a um programa que chama a sua fun\u00e7\u00e3o com argumentos diferentes. Mesmo que voc\u00ea tenha certeza que o seu programa est\u00e1 funcionando, \u00e9 importante test\u00e1-lo. Por exemplo, qual \u00e9 o resultado de f(0) f(0) ? E f(1) f(1) , f(2) f(2) , f(-1) f(-1) ? Quantos testes voc\u00ea deve fazer para garantir que sua fun\u00e7\u00e3o est\u00e1 correta? Reflita: o que a sua fun\u00e7\u00e3o faz? Qual seria um nome melhor para esta fun\u00e7\u00e3o? Se voc\u00ea teve dificuldades para resolver este exerc\u00edcio, fa\u00e7a tamb\u00e9m o [TESTE DE MESA] Verifica par ou \u00edmpar .","title":"Exerc\u00edcio 1"},{"location":"aulas/02-io/#exercicios-adicionais","text":"Caso voc\u00ea termine o programa acima antes da discuss\u00e3o com a sala, resolva os seguintes exerc\u00edcios no servidor : Exerc\u00edcio 8: Movimento retil\u00edneo uniforme Exerc\u00edcio 9: Volume de uma esfera Exerc\u00edcio 14: Lan\u00e7amento de proj\u00e9til","title":"Exerc\u00edcios adicionais"},{"location":"aulas/02-io/#pedindo-dados-para-o-usuario","text":"At\u00e9 agora fizemos programas que, ao serem executados, sempre fazem exatamente a mesma coisa. Seria interessante permitir algum tipo de intera\u00e7\u00e3o com o usu\u00e1rio. Por enquanto estamos desenvolvendo programas que imprimem valores no terminal, ent\u00e3o tamb\u00e9m vamos utilizar o terminal para receber dados digitados pelo usu\u00e1rio. Em Python, a fun\u00e7\u00e3o input () pede um texto para o usu\u00e1rio e retorna este texto ao programa. Voc\u00ea pode, por exemplo, guardar esse texto em uma vari\u00e1vel para usar em seguida. Teste o seguinte programa no seu computador: # Pede a cor favorita para o usu\u00e1rio. cor_favorita = input ( 'Qual a sua cor favorita? ' ) # Imprime a cor favorita do usu\u00e1rio. print ( cor_favorita ) O programa acima deve imprimir Qual a sua cor favorita? (note que existe um espa\u00e7o ap\u00f3s a interroga\u00e7\u00e3o) no terminal e parar. Nesse momento ele est\u00e1 esperando que o usu\u00e1rio digite algo no terminal. At\u00e9 que isso aconte\u00e7a, o programa fica parado na chamada da fun\u00e7\u00e3o input () .","title":"Pedindo dados para o usu\u00e1rio"},{"location":"aulas/02-io/#praticando-o-uso-do-input","text":"Considere a seguinte fun\u00e7\u00e3o: # Fun\u00e7\u00e3o que soma dois n\u00fameros. def soma ( x , y ): z = x + y return z Se criarmos um arquivo .py contendo somente esta fun\u00e7\u00e3o, o que voc\u00ea espera que aconte\u00e7a? Rode seu programa. Ele fez o que voc\u00ea esperava? O programa acima n\u00e3o vai fazer nada. N\u00f3s s\u00f3 estamos definindo a fun\u00e7\u00e3o soma , mas n\u00e3o estamos pedindo para o Python execut\u00e1-la (ou seja, n\u00e3o estamos chamando a fun\u00e7\u00e3o). O programa a seguir deve imprimir a soma dos n\u00fameros 14 e 28: # Fun\u00e7\u00e3o que soma dois n\u00fameros. def soma ( x , y ): z = x + y return z # Testando nossa fun\u00e7\u00e3o resultado = soma ( 14 , 28 ) print ( resultado ) Teste o programa acima e verifique se ele faz o que era esperado.","title":"Praticando o uso do input"},{"location":"aulas/02-io/#exercicio-2","text":"Ao inv\u00e9s de deixarmos n\u00fameros fixos para testar a fun\u00e7\u00e3o, vamos perguntar para o usu\u00e1rio quais n\u00fameros ele quer somar. Teste o seguinte programa: # Fun\u00e7\u00e3o que soma dois n\u00fameros. def soma ( x , y ): z = x + y return z # Lendo os dois n\u00fameros. a = input ( 'Entre com o primeiro n\u00famero: ' ) b = input ( 'Entre com o segundo n\u00famero: ' ) # Somando os dois n\u00fameros. c = soma ( a , b ) print ( c ) Seu programa funcionou? Deu algum erro? Fez o que voc\u00ea esperava? Vamos tentar entender o que est\u00e1 acontecendo. Lembre-se que a fun\u00e7\u00e3o input () devolve o texto digitado pelo usu\u00e1rio. Na nossa soma, queremos adicionar n\u00fameros , n\u00e3o texto . Vamos tentar entender melhor o que est\u00e1 acontecendo.","title":"EXERC\u00cdCIO 2"},{"location":"aulas/02-io/#tipos-de-dados-em-python","text":"Vimos na aula passada que podemos guardar qualquer coisa em vari\u00e1veis no Python. O que n\u00f3s n\u00e3o discutimos foi que essas \"coisas\" que podemos guardar nas vari\u00e1veis possuem tipos espec\u00edficos. No in\u00edcio vamos trabalhar com 4 tipos b\u00e1sicos: Inteiro ( int ) : um n\u00famero sem casa decimal. Ex: 34 , 96 , - 123 , 45 ; Float ( float ) : um n\u00famero real, com \"ponto decimal\" (tamb\u00e9m chamamos de \"ponto flutuante\"). Ex: 3.14 , - 25.1 , 5.0 , 5e-1 ; String ( str ) : texto puro (\u00e9 representado necessariamente com aspas simples ou duplas). Ex: \"Hello, world!\" , 'Insper' , '3.14' , '\"oi\"' ; Booleano ( bool ) : representam \"verdadeiro\" ( True ) e \"falso\" ( False ).","title":"Tipos de dados em Python"},{"location":"aulas/02-io/#exercicio-3-conversao-entre-tipos","text":"O Python disponibiliza algumas fun\u00e7\u00f5es que convertem um valor de um tipo para outro. Teste o seguinte programa: # Converte para inteiro. print ( int ( 3.14 )) # Converte para float. print ( float ( 4 )) # Converte para string. print ( str ( 123 )) # Converte de string para int. print ( int ( '42' )) # Converte de string para float. print ( float ( '1.625' )) # What ?!? print ( float ( 'banana' )) Erros na execu\u00e7\u00e3o Seu programa deve ter apresentado um erro parecido com o seguinte: ValueError : could not convert string to float : 'banana' . Ser\u00e1 muito comum encontrarmos erros em nosso programa. A primeira dica \u00e9: n\u00e3o entre em p\u00e2nico. A segunda \u00e9: leia a mensagem de erro com aten\u00e7\u00e3o.","title":"EXERC\u00cdCIO 3: Convers\u00e3o entre tipos"},{"location":"aulas/02-io/#exercicio-adicional","text":"O comando int ( 3.14 ) gerou o n\u00famero inteiro 3 . Mas ser\u00e1 que ele arredondou o valor? Teste o comando int ( 2.718 ) . Assumindo que a fun\u00e7\u00e3o int () arredonda o valor, o resultado esperado seria 3 . Rode seu programa. Qual foi o resultado? O que isso diz sobre a fun\u00e7\u00e3o int ?","title":"Exerc\u00edcio adicional"},{"location":"aulas/02-io/#exercicio-4-agora-vai","text":"Corrija o programa do exerc\u00edcio 3 sabendo que o input () sempre devolve uma string , ou seja, o texto digitado pelo usu\u00e1rio e a nossa fun\u00e7\u00e3o soma ( x , y ) recebe dois n\u00fameros .","title":"EXERC\u00cdCIO 4: Agora vai!"},{"location":"aulas/02-io/#formatacao-de-strings","text":"Na aula passada vimos que podemos formatar uma string utilizando a fun\u00e7\u00e3o . format () para incluir os valores armazenados em vari\u00e1veis. Por exemplo: a = 10 b = 7 texto = 'a vale {0} , b vale {1} e a + b = {2} ' . format ( a , b , a + b ) print ( texto ) Esse programa vai imprimir a vale 10 , b vale 7 e a + b = 17 no terminal. Agora, o que acontece se o valor da vari\u00e1vel for um float ? Teste o programa a seguir. import math print ( 'pi \u00e9 {0} mais ou menos' . format ( math . pi )) Quantas casas decimais do n\u00famero pi foram apresentadas? E se quisermos mostrar apenas as 3 primeiras? Para isso podemos usar diretivas de formata\u00e7\u00e3o , que podem ser especificadas com um \" : \" (dois pontos) depois do \u00edndice. Por exemplo ' {0:.1f} , {1:.4f} ' . format ( 1.23456 , 7.89123 ) vai gerar a string '1.2, 7.8912' . Vamos por partes:","title":"Formata\u00e7\u00e3o de strings"},{"location":"aulas/02-io/#exercicio-5","text":"Modifique o programa que imprime o valor de pi para que ele mostre somente as 3 primeiras casas decimais. Maneiras antigas de formatar strings em Python Se voc\u00ea procurar na internet por \"formata\u00e7\u00e3o de strings em Python\" ou algum termo an\u00e1logo, \u00e9 bastante prov\u00e1vel que voc\u00ea encontre formas diferentes da que apresentamos acima. Por exemplo: nome = \"Mateus\" texto = \"Meu nome \u00e9 %s \" % nome print ( texto ) N\u00e3o se preocupe se n\u00e3o entender esse trecho de c\u00f3digo. Essa \u00e9 a maneira antiga de formatar strings em Python. Procure utilizar a maneira nova que ensinamos, pois ela \u00e9 mais flex\u00edvel.","title":"EXERC\u00cdCIO 5"},{"location":"aulas/02-io/#operacoes-com-strings","text":"No programa do exerc\u00edcio 2 n\u00f3s obtivemos um comportamento diferente do que esper\u00e1vamos (se precisar, execute o programa novamente para relembrar). Nessa vers\u00e3o do programa, se o usu\u00e1rio digitar 4 e 2 o programa vai imprimir que a soma vale 42 . Vimos que isso ocorre porque a fun\u00e7\u00e3o input () sempre devolve uma string, ent\u00e3o o que o programa fez foi juntar a string '4' com a string '2' , obtendo a string '42' . Essa opera\u00e7\u00e3o de \"juntar strings\" \u00e9 o que chamamos de concatena\u00e7\u00e3o .","title":"Opera\u00e7\u00f5es com strings"},{"location":"aulas/02-io/#exercicio-6","text":"Antes de executar o programa a seguir, reflita: o que voc\u00ea espera que seja a sa\u00edda dele, ou seja, o que voc\u00ea espera que apare\u00e7a no terminal? Depois que tiver sua hip\u00f3tese, execute o programa. s1 = 'Ins' s2 = 'per' s = s1 + s2 print ( s ) t = s2 + s1 print ( t ) Se o programa n\u00e3o fez o que voc\u00ea esperava, discuta com seus colegas. Se n\u00e3o conseguirem resolver, converse com algum dos professores.","title":"EXERC\u00cdCIO 6"},{"location":"aulas/02-io/#exercicio-7","text":"Vamos voltar por um instante para o contexto num\u00e9rico. Sabe-se que uma multiplica\u00e7\u00e3o \u00e9 equivalente \u00e0 adi\u00e7\u00e3o sucessiva de um mesmo n\u00famero. Por exemplo: 3 * 4 = 4 + 4 + 4 = 12 . Sabendo disso e considerando o que acabamos de aprender sobre concatena\u00e7\u00e3o ( + ) de strings, qual voc\u00ea espera que seja a sa\u00edda do programa a seguir? Execute-o para validar sua hip\u00f3tese. s1 = 'Ins' s2 = 'per' s = 3 * s1 + s2 print ( s )","title":"EXERC\u00cdCIO 7"},{"location":"aulas/02-io/#exercicios-adicionais_1","text":"Exerc\u00edcio 21: Total em segundos Exerc\u00edcio 22: Redu\u00e7\u00e3o no tempo de vida de um fumante Exerc\u00edcio 59: Repete asteriscos Se terminar os exerc\u00edcios acima, fa\u00e7a os outros exerc\u00edcios do servidor.","title":"Exerc\u00edcios adicionais"},{"location":"aulas/02-io/#desafio","text":"Fa\u00e7a um programa que pergunta ao usu\u00e1rio um numero n entre 1 e 20 e imprime um quadrado de asteriscos n x n. Exemplo de uso: Digite n: 3 *** *** *** Para cumprir essa miss\u00e3o voc\u00ea precisa saber que a string \" \\n \" significa \"pule para a pr\u00f3xima linha\" . Por exemplo: print ( \"abc \\n de\" ) imprime abc de","title":"Desafio"},{"location":"aulas/02-io/#referencias","text":"https://docs.python.org/3.7/tutorial/inputoutput.html https://docs.python.org/3.7/library/string.html#formatspec","title":"Refer\u00eancias"},{"location":"aulas/03-if/","text":"03 - Desvios Condicionais (if) \u00b6 Nas aulas anteriores desenvolvemos programas que funcionam mais ou menos como uma linha de produ\u00e7\u00e3o: uma s\u00e9rie de comandos s\u00e3o executados um ap\u00f3s o outro, sem op\u00e7\u00e3o de seguir por um caminho diferente. Voc\u00ea pode argumentar que o input () , visto na aula passada, permite que o programa se comporte de formas diferentes dependendo do que o usu\u00e1rio digitar no teclado. Mas se olharmos o programa em si, a sequ\u00eancia de opera\u00e7\u00f5es executadas \u00e9 sempre a mesma. Na aula de hoje veremos como desenvolver programas que, dada uma condi\u00e7\u00e3o, executam, ou n\u00e3o, um determinado bloco de c\u00f3digo. Suponha que queremos desenvolver uma fun\u00e7\u00e3o que recebe dois n\u00fameros, x e y como argumento e devolve 1 se x for maior do que y e 0, caso contr\u00e1rio. A n\u00e3o ser que exista uma f\u00f3rmula fechada (existe, para alguns casos), precisamos de alguma forma de executar um trecho de c\u00f3digo somente se x for maior que y e outro trecho de c\u00f3digo somente se essa condi\u00e7\u00e3o n\u00e3o for verdadeira. Nossa fun\u00e7\u00e3o deve fazer algo parecido com o seguinte: Para isso vamos precisar do operador if . Vamos come\u00e7ar com um exemplo curto para entender como ele funciona. EXERC\u00cdCIO 1 \u00b6 Teste o seguinte programa: print ( 'Come\u00e7ando o programa' ) if True : print ( 'Entrou no primeiro if' ) if False : print ( 'Entrou no segundo if' ) print ( 'Saindo do programa' ) O que foi mostrado no terminal? A sa\u00edda do terminal est\u00e1 de acordo com o que voc\u00ea esperava que acontecesse? O operador if \u00b6 O operador if funciona da seguinte maneira: No caso de if True : o bloco do if \u00e9 executado; No caso de if False : o bloco do if n\u00e3o \u00e9 executado. Importante: o operador if sempre deve ser procedido por um valor True ou False . Mas ent\u00e3o, para que serve o if ? Ele parece bastante limitado... Para isso precisamos abrir mais um par\u00eanteses. Operadores relacionais \u00b6 EXERC\u00cdCIO 2 \u00b6 Teste o programa a seguir: # Testa as desigualdades. menor = 1 < 2 print ( menor ) print ( 1 < 2 ) maior_ou_igual = 1 >= 2 print ( maior_ou_igual ) print ( 1 >= 2 ) # Isso sim \u00e9 um igual e n\u00e3o uma atribui\u00e7\u00e3o. igual = 1 == 2 print ( igual ) print ( 1 == 2 ) # Testa se \u00e9 diferente. diferente = 1 != 2 print ( diferente ) print ( 1 != 2 ) # Testa se cont\u00e9m. contem_i = 'i' in 'Insper' print ( contem_i ) print ( 'i' in 'Insper' ) contem_I = 'I' in 'Insper' print ( contem_I ) print ( 'I' in 'Insper' ) EXERC\u00cdCIO 3 \u00b6 Fa\u00e7a o exerc\u00edcio [TESTE DE MESA] Operadores relacionais . Todas as express\u00f5es no c\u00f3digo acima resultam em um valor booleano ( True ou False ). Vimos que o if s\u00f3 pode ser seguido de um valor booleano. Como as express\u00f5es acima resultam em um valor booleano, elas tamb\u00e9m podem ser utilizadas com o if ! EXERC\u00cdCIO 4 \u00b6 Considere o programa a seguir. Antes de testar, discuta com um colega qual voc\u00ea espera que seja a sa\u00edda no terminal. Depois disso, teste o programa e valide a sua hip\u00f3tese. print ( 'Come\u00e7ando o programa' ) if 1 >= 2 : print ( 'Entrou no primeiro if' ) if 'I' in 'Insper' : print ( 'Entrou no segundo if' ) print ( 'Saindo do programa' ) As express\u00f5es acima utilizam operadores relacionais para comparar valores e o resultado dessas opera\u00e7\u00f5es sempre \u00e9 um valor booleano. A tabela a seguir resume os principais operadores relacionais: Operador Opera\u00e7\u00e3o == Igual != Diferente > Maior < Menor >= Maior ou Igual <= Menor ou Igual Voltando para o problema inicial \u00b6 Agora podemos voltar para o problema inicial: fa\u00e7a uma fun\u00e7\u00e3o que recebe dois n\u00fameros x e y e devolve 1, caso x seja maior que y , ou zero, caso contr\u00e1rio. EXERC\u00cdCIO 5 \u00b6 Teste o programa a seguir: def testa_x_y ( x , y ): if x > y : resultado = 1 return resultado print ( testa_x_y ( 10 , 5 )) Caso o programa acima n\u00e3o tenha funcionado, tente resolver o problema com a ajuda dos seus colegas. Se n\u00e3o conseguirem resolver, conversem com o professor. EXERC\u00cdCIO 6 \u00b6 Acrescente a seguinte linha ao final do programa acima: print ( testa_x_y ( 5 , 10 )) . Teste o programa novamente. Erro de vari\u00e1vel n\u00e3o definida Um erro semelhante a este deve ter ocorrido: UnboundLocalError : local variable 'resultado' referenced before assignment . Ele indica que a vari\u00e1vel resultado foi referenciada antes de receber um valor. Antes de ler o pr\u00f3ximo par\u00e1grafo, tente identificar por conta pr\u00f3pria por que esse erro aconteceu. Os valores 5 e 10 s\u00e3o recebidos pela fun\u00e7\u00e3o nas vari\u00e1veis x e y respectivamente. Na linha seguinte, x > y \u00e9 avaliado como 5 > 10 , ou seja, False . Nesse caso, o bloco do if n\u00e3o \u00e9 executado e a pr\u00f3xima linha \u00e9 return resultado , mas qual valor est\u00e1 guardado em resultado ? Como a vari\u00e1vel resultado n\u00e3o foi inicializada nesta execu\u00e7\u00e3o da fun\u00e7\u00e3o , o erro UnboundLocalError ocorre. E o \"caso contr\u00e1rio\"? \u00b6 Para corrigir o erro na nossa fun\u00e7\u00e3o, vamos voltar \u00e0 descri\u00e7\u00e3o do problema inicial: uma fun\u00e7\u00e3o que devolve 1 caso x seja maior que y ou zero, caso contr\u00e1rio. Precisamos tratar esse \"caso contr\u00e1rio\" . Para isso existe o operador else , que significa, literalmente, \"caso contr\u00e1rio\" . EXERC\u00cdCIO 7 \u00b6 Teste o programa a seguir: numero = int ( input ( 'Digite um n\u00famero: ' )) if numero == 42 : print ( 'Resposta para a vida, o universo e tudo mais' ) else : print ( 'Um n\u00famero qualquer' ) Aten\u00e7\u00e3o Se voc\u00ea n\u00e3o sabe o que a primeira linha do c\u00f3digo acima faz, revise o handout da aula passada antes de prosseguir. Fa\u00e7a alguns testes variando a entrada para verificar se o programa faz o que voc\u00ea espera. O operador else captura todos os casos para os quais a condi\u00e7\u00e3o do if \u00e9 falsa. Agora vai! \u00b6 EXERC\u00cdCIO 8 \u00b6 Agora sim, podemos terminar nossa fun\u00e7\u00e3o. Modifique a fun\u00e7\u00e3o do exerc\u00edcio 6 para que o programa volte a funcionar. Encadeando condicionais \u00b6 \u00c9 poss\u00edvel testar uma nova condi\u00e7\u00e3o caso a anterior falhe, utilizando o operador elif . Ele pode ser lido como \"sen\u00e3o, se\" . Vamos trabalhar com um exemplo. EXERC\u00cdCIO 9 \u00b6 Teste o programa a seguir: numero = int ( input ( 'Digite um n\u00famero: ' )) if numero == 0 : print ( '0 n\u00e3o \u00e9 nem par, nem \u00edmpar' ) elif numero % 2 == 0 : # Resto da divis\u00e3o de n\u00famero por 2 print ( ' {0} \u00e9 par' . format ( numero )) else : print ( ' {0} \u00e9 \u00edmpar' . format ( numero )) O que deve acontecer se o n\u00famero 0 for digitado? E o n\u00famero 11 ? E o n\u00famero 10000 ? EXERC\u00cdCIO 10 \u00b6 Se numero for igual a zero, numero % 2 == 0 \u00e9 True . Discuta com algum colega e valide com o professor: por que quando o usu\u00e1rio digita o n\u00famero zero o programa n\u00e3o imprime 0 \u00e9 par ? EXERC\u00cdCIO 11 \u00b6 Discuta com um colega: por que podemos utilizar o else para imprimir que o n\u00famero \u00e9 \u00edmpar? Em outra palavras, por que n\u00e3o precisamos de um elif numero % 2 != 0 : ? EXERC\u00cdCIO 12 \u00b6 Altere a fun\u00e7\u00e3o do exerc\u00edcio 8 para que ela devolva 1 se x for maior do que y , 0 se x for igual a y ou - 1 , se x for menor do que y . If's encadeados \u00b6 Dentro do bloco de um if , elif ou else , podemos ter qualquer c\u00f3digo Python v\u00e1lido. Inclusive outros if 's. Considere a fun\u00e7\u00e3o a seguir, que, dada a idade de uma pessoa, devolve uma string que indica em que pa\u00edses essa pessoa \u00e9 considerada maior de idade. def testa_maioridade ( idade ): if idade >= 21 : return 'Maior nos EUA e BRASIL' else : if idade >= 18 : return 'Maior no BRASIL' else : return 'Menor de idade' print ( testa_maioridade ( 17 )) print ( testa_maioridade ( 20 )) print ( testa_maioridade ( 21 )) EXERC\u00cdCIO 13 \u00b6 Fa\u00e7a o teste de mesa no exerc\u00edcio [TESTE DE MESA] Testa maioridade . EXERC\u00cdCIO 14 \u00b6 Modifique a fun\u00e7\u00e3o acima para utilizar exatamente um if , um elif e um else . Operadores l\u00f3gicos \u00b6 Operador and \u00b6 Nos exerc\u00edcios anteriores vimos como testar uma \u00fanica condi\u00e7\u00e3o, mas em muitos casos pode ser \u00fatil testar mais do que uma condi\u00e7\u00e3o de uma vez. Por exemplo, um arco-\u00edris ocorre se est\u00e1 chovendo e fazendo sol , simultaneamente. Ou seja: esta_chovendo = True faz_sol = True if esta_chovendo and faz_sol : print ( 'Arco-\u00edris!' ) else : print ( 'Sem arco-\u00edris. Alguma das condi\u00e7\u00f5es n\u00e3o foi satisfeita.' ) EXERC\u00cdCIO 15 \u00b6 Teste o programa acima, modificando os valores de esta_chovendo e faz_sol . Existem 4 combina\u00e7\u00f5es poss\u00edveis. Teste todas e verifique se a sa\u00edda no terminal corresponde ao que voc\u00ea esperava. Operador or \u00b6 Em outros casos \u00e9 suficiente que pelo menos uma das condi\u00e7\u00f5es for satisfeita . Por exemplo: uma pessoa paga meia entrada no teatro se for estudante ou for idosa . Ou seja: estudante = True idoso = False if estudante or idoso : print ( 'Paga meia!' ) else : print ( 'Paga inteira...' ) EXERC\u00cdCIO 6 \u00b6 Teste o programa acima, modificando os valores de estudante e idoso . Existem 4 combina\u00e7\u00f5es poss\u00edveis. Teste todas e verifique se a sa\u00edda no terminal corresponde ao que voc\u00ea esperava. Operador not \u00b6 Tamb\u00e9m existe a possibilidade de querermos considerar os casos em que uma condi\u00e7\u00e3o \u00e9 falsa. Por exemplo: sempre tomo sopa quando o dia n\u00e3o est\u00e1 quente. esta_quente = False if not esta_quente : print ( 'Vou tomar sopa' ) EXERC\u00cdCIO 17 \u00b6 Teste o programa acima, modificando os valores de esta_quente . Existem 2 possibilidades. Teste ambas e verifique se a sa\u00edda no terminal corresponde ao que voc\u00ea esperava. Resumindo \u00b6 Vamos resumir o comportamento dos operadores and , or e not : and : devolve True se AMBOS os valores forem verdadeiros; or : devolve True se PELO MENOS UM dos valores forem verdadeiros; not : inverte de True para False e vice-versa. EXERC\u00cdCIO 18 \u00b6 Fa\u00e7a uma fun\u00e7\u00e3o que recebe os lados de um tri\u00e2ngulo e retorna se ele \u00e9 equil\u00e1tero, is\u00f3sceles ou escaleno (se n\u00e3o sabe alguma dessas defini\u00e7\u00f5es, procure na internet). Teste sua resposta no exerc\u00edcio 19 do servidor. Voc\u00ea pode implementar essa fun\u00e7\u00e3o de diversas maneiras diferentes. Implemente as seguintes vers\u00f5es e compare o c\u00f3digo gerado para cada uma: Teste se o tri\u00e2ngulo \u00e9 equil\u00e1tero, depois se \u00e9 is\u00f3sceles e depois se \u00e9 escaleno; Teste se o tri\u00e2ngulo \u00e9 equil\u00e1tero, depois se \u00e9 escaleno e depois se \u00e9 is\u00f3sceles; Teste se o tri\u00e2ngulo \u00e9 is\u00f3sceles, depois se \u00e9 equil\u00e1tero e depois se \u00e9 escaleno; Erro comum Assuma que as vari\u00e1veis lado1 , lado2 e lado3 guardam as medidas dos lados do tri\u00e2ngulo. Um erro comum neste exerc\u00edcio \u00e9 tentar combinar duas compara\u00e7\u00f5es de maneira incompleta. Por exemplo, para verificar se um tri\u00e2ngulo \u00e9 is\u00f3sceles: if lado1 == lado2 and != lado3 Apesar de ser razo\u00e1vel achar que esse c\u00f3digo seria v\u00e1lido ele n\u00e3o funciona . Lembre-se que os operadores l\u00f3gicos ( and e or ) combinam dois valores booleanos, portanto cada lado do operador deve ser uma express\u00e3o completa . Assim, o correto seria: if lado1 == lado2 and lado1 != lado3 EXERC\u00cdCIOS ADICIONAIS \u00b6 Se acabar os exerc\u00edcios propostos neste handout, resolva os outros exerc\u00edcios dispon\u00edveis no servidor .","title":"Handout"},{"location":"aulas/03-if/#03-desvios-condicionais-if","text":"Nas aulas anteriores desenvolvemos programas que funcionam mais ou menos como uma linha de produ\u00e7\u00e3o: uma s\u00e9rie de comandos s\u00e3o executados um ap\u00f3s o outro, sem op\u00e7\u00e3o de seguir por um caminho diferente. Voc\u00ea pode argumentar que o input () , visto na aula passada, permite que o programa se comporte de formas diferentes dependendo do que o usu\u00e1rio digitar no teclado. Mas se olharmos o programa em si, a sequ\u00eancia de opera\u00e7\u00f5es executadas \u00e9 sempre a mesma. Na aula de hoje veremos como desenvolver programas que, dada uma condi\u00e7\u00e3o, executam, ou n\u00e3o, um determinado bloco de c\u00f3digo. Suponha que queremos desenvolver uma fun\u00e7\u00e3o que recebe dois n\u00fameros, x e y como argumento e devolve 1 se x for maior do que y e 0, caso contr\u00e1rio. A n\u00e3o ser que exista uma f\u00f3rmula fechada (existe, para alguns casos), precisamos de alguma forma de executar um trecho de c\u00f3digo somente se x for maior que y e outro trecho de c\u00f3digo somente se essa condi\u00e7\u00e3o n\u00e3o for verdadeira. Nossa fun\u00e7\u00e3o deve fazer algo parecido com o seguinte: Para isso vamos precisar do operador if . Vamos come\u00e7ar com um exemplo curto para entender como ele funciona.","title":"03 - Desvios Condicionais (if)"},{"location":"aulas/03-if/#exercicio-1","text":"Teste o seguinte programa: print ( 'Come\u00e7ando o programa' ) if True : print ( 'Entrou no primeiro if' ) if False : print ( 'Entrou no segundo if' ) print ( 'Saindo do programa' ) O que foi mostrado no terminal? A sa\u00edda do terminal est\u00e1 de acordo com o que voc\u00ea esperava que acontecesse?","title":"EXERC\u00cdCIO 1"},{"location":"aulas/03-if/#o-operador-if","text":"O operador if funciona da seguinte maneira: No caso de if True : o bloco do if \u00e9 executado; No caso de if False : o bloco do if n\u00e3o \u00e9 executado. Importante: o operador if sempre deve ser procedido por um valor True ou False . Mas ent\u00e3o, para que serve o if ? Ele parece bastante limitado... Para isso precisamos abrir mais um par\u00eanteses.","title":"O operador if"},{"location":"aulas/03-if/#operadores-relacionais","text":"","title":"Operadores relacionais"},{"location":"aulas/03-if/#exercicio-2","text":"Teste o programa a seguir: # Testa as desigualdades. menor = 1 < 2 print ( menor ) print ( 1 < 2 ) maior_ou_igual = 1 >= 2 print ( maior_ou_igual ) print ( 1 >= 2 ) # Isso sim \u00e9 um igual e n\u00e3o uma atribui\u00e7\u00e3o. igual = 1 == 2 print ( igual ) print ( 1 == 2 ) # Testa se \u00e9 diferente. diferente = 1 != 2 print ( diferente ) print ( 1 != 2 ) # Testa se cont\u00e9m. contem_i = 'i' in 'Insper' print ( contem_i ) print ( 'i' in 'Insper' ) contem_I = 'I' in 'Insper' print ( contem_I ) print ( 'I' in 'Insper' )","title":"EXERC\u00cdCIO 2"},{"location":"aulas/03-if/#exercicio-3","text":"Fa\u00e7a o exerc\u00edcio [TESTE DE MESA] Operadores relacionais . Todas as express\u00f5es no c\u00f3digo acima resultam em um valor booleano ( True ou False ). Vimos que o if s\u00f3 pode ser seguido de um valor booleano. Como as express\u00f5es acima resultam em um valor booleano, elas tamb\u00e9m podem ser utilizadas com o if !","title":"EXERC\u00cdCIO 3"},{"location":"aulas/03-if/#exercicio-4","text":"Considere o programa a seguir. Antes de testar, discuta com um colega qual voc\u00ea espera que seja a sa\u00edda no terminal. Depois disso, teste o programa e valide a sua hip\u00f3tese. print ( 'Come\u00e7ando o programa' ) if 1 >= 2 : print ( 'Entrou no primeiro if' ) if 'I' in 'Insper' : print ( 'Entrou no segundo if' ) print ( 'Saindo do programa' ) As express\u00f5es acima utilizam operadores relacionais para comparar valores e o resultado dessas opera\u00e7\u00f5es sempre \u00e9 um valor booleano. A tabela a seguir resume os principais operadores relacionais: Operador Opera\u00e7\u00e3o == Igual != Diferente > Maior < Menor >= Maior ou Igual <= Menor ou Igual","title":"EXERC\u00cdCIO 4"},{"location":"aulas/03-if/#voltando-para-o-problema-inicial","text":"Agora podemos voltar para o problema inicial: fa\u00e7a uma fun\u00e7\u00e3o que recebe dois n\u00fameros x e y e devolve 1, caso x seja maior que y , ou zero, caso contr\u00e1rio.","title":"Voltando para o problema inicial"},{"location":"aulas/03-if/#exercicio-5","text":"Teste o programa a seguir: def testa_x_y ( x , y ): if x > y : resultado = 1 return resultado print ( testa_x_y ( 10 , 5 )) Caso o programa acima n\u00e3o tenha funcionado, tente resolver o problema com a ajuda dos seus colegas. Se n\u00e3o conseguirem resolver, conversem com o professor.","title":"EXERC\u00cdCIO 5"},{"location":"aulas/03-if/#exercicio-6","text":"Acrescente a seguinte linha ao final do programa acima: print ( testa_x_y ( 5 , 10 )) . Teste o programa novamente. Erro de vari\u00e1vel n\u00e3o definida Um erro semelhante a este deve ter ocorrido: UnboundLocalError : local variable 'resultado' referenced before assignment . Ele indica que a vari\u00e1vel resultado foi referenciada antes de receber um valor. Antes de ler o pr\u00f3ximo par\u00e1grafo, tente identificar por conta pr\u00f3pria por que esse erro aconteceu. Os valores 5 e 10 s\u00e3o recebidos pela fun\u00e7\u00e3o nas vari\u00e1veis x e y respectivamente. Na linha seguinte, x > y \u00e9 avaliado como 5 > 10 , ou seja, False . Nesse caso, o bloco do if n\u00e3o \u00e9 executado e a pr\u00f3xima linha \u00e9 return resultado , mas qual valor est\u00e1 guardado em resultado ? Como a vari\u00e1vel resultado n\u00e3o foi inicializada nesta execu\u00e7\u00e3o da fun\u00e7\u00e3o , o erro UnboundLocalError ocorre.","title":"EXERC\u00cdCIO 6"},{"location":"aulas/03-if/#e-o-caso-contrario","text":"Para corrigir o erro na nossa fun\u00e7\u00e3o, vamos voltar \u00e0 descri\u00e7\u00e3o do problema inicial: uma fun\u00e7\u00e3o que devolve 1 caso x seja maior que y ou zero, caso contr\u00e1rio. Precisamos tratar esse \"caso contr\u00e1rio\" . Para isso existe o operador else , que significa, literalmente, \"caso contr\u00e1rio\" .","title":"E o \"caso contr\u00e1rio\"?"},{"location":"aulas/03-if/#exercicio-7","text":"Teste o programa a seguir: numero = int ( input ( 'Digite um n\u00famero: ' )) if numero == 42 : print ( 'Resposta para a vida, o universo e tudo mais' ) else : print ( 'Um n\u00famero qualquer' ) Aten\u00e7\u00e3o Se voc\u00ea n\u00e3o sabe o que a primeira linha do c\u00f3digo acima faz, revise o handout da aula passada antes de prosseguir. Fa\u00e7a alguns testes variando a entrada para verificar se o programa faz o que voc\u00ea espera. O operador else captura todos os casos para os quais a condi\u00e7\u00e3o do if \u00e9 falsa.","title":"EXERC\u00cdCIO 7"},{"location":"aulas/03-if/#agora-vai","text":"","title":"Agora vai!"},{"location":"aulas/03-if/#exercicio-8","text":"Agora sim, podemos terminar nossa fun\u00e7\u00e3o. Modifique a fun\u00e7\u00e3o do exerc\u00edcio 6 para que o programa volte a funcionar.","title":"EXERC\u00cdCIO 8"},{"location":"aulas/03-if/#encadeando-condicionais","text":"\u00c9 poss\u00edvel testar uma nova condi\u00e7\u00e3o caso a anterior falhe, utilizando o operador elif . Ele pode ser lido como \"sen\u00e3o, se\" . Vamos trabalhar com um exemplo.","title":"Encadeando condicionais"},{"location":"aulas/03-if/#exercicio-9","text":"Teste o programa a seguir: numero = int ( input ( 'Digite um n\u00famero: ' )) if numero == 0 : print ( '0 n\u00e3o \u00e9 nem par, nem \u00edmpar' ) elif numero % 2 == 0 : # Resto da divis\u00e3o de n\u00famero por 2 print ( ' {0} \u00e9 par' . format ( numero )) else : print ( ' {0} \u00e9 \u00edmpar' . format ( numero )) O que deve acontecer se o n\u00famero 0 for digitado? E o n\u00famero 11 ? E o n\u00famero 10000 ?","title":"EXERC\u00cdCIO 9"},{"location":"aulas/03-if/#exercicio-10","text":"Se numero for igual a zero, numero % 2 == 0 \u00e9 True . Discuta com algum colega e valide com o professor: por que quando o usu\u00e1rio digita o n\u00famero zero o programa n\u00e3o imprime 0 \u00e9 par ?","title":"EXERC\u00cdCIO 10"},{"location":"aulas/03-if/#exercicio-11","text":"Discuta com um colega: por que podemos utilizar o else para imprimir que o n\u00famero \u00e9 \u00edmpar? Em outra palavras, por que n\u00e3o precisamos de um elif numero % 2 != 0 : ?","title":"EXERC\u00cdCIO 11"},{"location":"aulas/03-if/#exercicio-12","text":"Altere a fun\u00e7\u00e3o do exerc\u00edcio 8 para que ela devolva 1 se x for maior do que y , 0 se x for igual a y ou - 1 , se x for menor do que y .","title":"EXERC\u00cdCIO 12"},{"location":"aulas/03-if/#ifs-encadeados","text":"Dentro do bloco de um if , elif ou else , podemos ter qualquer c\u00f3digo Python v\u00e1lido. Inclusive outros if 's. Considere a fun\u00e7\u00e3o a seguir, que, dada a idade de uma pessoa, devolve uma string que indica em que pa\u00edses essa pessoa \u00e9 considerada maior de idade. def testa_maioridade ( idade ): if idade >= 21 : return 'Maior nos EUA e BRASIL' else : if idade >= 18 : return 'Maior no BRASIL' else : return 'Menor de idade' print ( testa_maioridade ( 17 )) print ( testa_maioridade ( 20 )) print ( testa_maioridade ( 21 ))","title":"If's encadeados"},{"location":"aulas/03-if/#exercicio-13","text":"Fa\u00e7a o teste de mesa no exerc\u00edcio [TESTE DE MESA] Testa maioridade .","title":"EXERC\u00cdCIO 13"},{"location":"aulas/03-if/#exercicio-14","text":"Modifique a fun\u00e7\u00e3o acima para utilizar exatamente um if , um elif e um else .","title":"EXERC\u00cdCIO 14"},{"location":"aulas/03-if/#operadores-logicos","text":"","title":"Operadores l\u00f3gicos"},{"location":"aulas/03-if/#operador-and","text":"Nos exerc\u00edcios anteriores vimos como testar uma \u00fanica condi\u00e7\u00e3o, mas em muitos casos pode ser \u00fatil testar mais do que uma condi\u00e7\u00e3o de uma vez. Por exemplo, um arco-\u00edris ocorre se est\u00e1 chovendo e fazendo sol , simultaneamente. Ou seja: esta_chovendo = True faz_sol = True if esta_chovendo and faz_sol : print ( 'Arco-\u00edris!' ) else : print ( 'Sem arco-\u00edris. Alguma das condi\u00e7\u00f5es n\u00e3o foi satisfeita.' )","title":"Operador and"},{"location":"aulas/03-if/#exercicio-15","text":"Teste o programa acima, modificando os valores de esta_chovendo e faz_sol . Existem 4 combina\u00e7\u00f5es poss\u00edveis. Teste todas e verifique se a sa\u00edda no terminal corresponde ao que voc\u00ea esperava.","title":"EXERC\u00cdCIO 15"},{"location":"aulas/03-if/#operador-or","text":"Em outros casos \u00e9 suficiente que pelo menos uma das condi\u00e7\u00f5es for satisfeita . Por exemplo: uma pessoa paga meia entrada no teatro se for estudante ou for idosa . Ou seja: estudante = True idoso = False if estudante or idoso : print ( 'Paga meia!' ) else : print ( 'Paga inteira...' )","title":"Operador or"},{"location":"aulas/03-if/#exercicio-6_1","text":"Teste o programa acima, modificando os valores de estudante e idoso . Existem 4 combina\u00e7\u00f5es poss\u00edveis. Teste todas e verifique se a sa\u00edda no terminal corresponde ao que voc\u00ea esperava.","title":"EXERC\u00cdCIO 6"},{"location":"aulas/03-if/#operador-not","text":"Tamb\u00e9m existe a possibilidade de querermos considerar os casos em que uma condi\u00e7\u00e3o \u00e9 falsa. Por exemplo: sempre tomo sopa quando o dia n\u00e3o est\u00e1 quente. esta_quente = False if not esta_quente : print ( 'Vou tomar sopa' )","title":"Operador not"},{"location":"aulas/03-if/#exercicio-17","text":"Teste o programa acima, modificando os valores de esta_quente . Existem 2 possibilidades. Teste ambas e verifique se a sa\u00edda no terminal corresponde ao que voc\u00ea esperava.","title":"EXERC\u00cdCIO 17"},{"location":"aulas/03-if/#resumindo","text":"Vamos resumir o comportamento dos operadores and , or e not : and : devolve True se AMBOS os valores forem verdadeiros; or : devolve True se PELO MENOS UM dos valores forem verdadeiros; not : inverte de True para False e vice-versa.","title":"Resumindo"},{"location":"aulas/03-if/#exercicio-18","text":"Fa\u00e7a uma fun\u00e7\u00e3o que recebe os lados de um tri\u00e2ngulo e retorna se ele \u00e9 equil\u00e1tero, is\u00f3sceles ou escaleno (se n\u00e3o sabe alguma dessas defini\u00e7\u00f5es, procure na internet). Teste sua resposta no exerc\u00edcio 19 do servidor. Voc\u00ea pode implementar essa fun\u00e7\u00e3o de diversas maneiras diferentes. Implemente as seguintes vers\u00f5es e compare o c\u00f3digo gerado para cada uma: Teste se o tri\u00e2ngulo \u00e9 equil\u00e1tero, depois se \u00e9 is\u00f3sceles e depois se \u00e9 escaleno; Teste se o tri\u00e2ngulo \u00e9 equil\u00e1tero, depois se \u00e9 escaleno e depois se \u00e9 is\u00f3sceles; Teste se o tri\u00e2ngulo \u00e9 is\u00f3sceles, depois se \u00e9 equil\u00e1tero e depois se \u00e9 escaleno; Erro comum Assuma que as vari\u00e1veis lado1 , lado2 e lado3 guardam as medidas dos lados do tri\u00e2ngulo. Um erro comum neste exerc\u00edcio \u00e9 tentar combinar duas compara\u00e7\u00f5es de maneira incompleta. Por exemplo, para verificar se um tri\u00e2ngulo \u00e9 is\u00f3sceles: if lado1 == lado2 and != lado3 Apesar de ser razo\u00e1vel achar que esse c\u00f3digo seria v\u00e1lido ele n\u00e3o funciona . Lembre-se que os operadores l\u00f3gicos ( and e or ) combinam dois valores booleanos, portanto cada lado do operador deve ser uma express\u00e3o completa . Assim, o correto seria: if lado1 == lado2 and lado1 != lado3","title":"EXERC\u00cdCIO 18"},{"location":"aulas/03-if/#exercicios-adicionais","text":"Se acabar os exerc\u00edcios propostos neste handout, resolva os outros exerc\u00edcios dispon\u00edveis no servidor .","title":"EXERC\u00cdCIOS ADICIONAIS"},{"location":"aulas/04-while/","text":"04 - La\u00e7os de Repeti\u00e7\u00e3o (while) \u00b6 O objetivo de aprendizado deste handout \u00e9 que, ao final da atividade, voc\u00ea seja capaz de utilizar la\u00e7os de repeti\u00e7\u00e3o (n\u00e3o se preocupe, vamos explicar o que \u00e9 isso) em seus programas em conjunto com as estruturas que vimos nas aulas anteriores ( if , input , etc.) Para isso, vamos trabalhar com o exemplo de um jogo simples: o programa escolhe um n\u00famero aleat\u00f3rio e o jogador precisa descobrir qual foi o n\u00famero escolhido. Importante Sempre valide a resposta com o professor ou algum colega que j\u00e1 tenha validado a pr\u00f3pria resposta antes de seguir para o pr\u00f3ximo exerc\u00edcio . Aquecimento \u00b6 Para come\u00e7ar, vamos implementar uma vers\u00e3o do jogo na qual o jogador s\u00f3 tem uma chance para acertar (sim, completamente na sorte). EXERC\u00cdCIO 1 \u00b6 Fa\u00e7a um programa que: Sorteia um n\u00famero aleat\u00f3rio entre 1 e 20 e guarda numa vari\u00e1vel; Use a fun\u00e7\u00e3o randint da biblioteca random ( dica : procure a documenta\u00e7\u00e3o na internet) Pede ao jogador um n\u00famero entre 1 e 20 D\u00ea o feedback da resposta do jogador: Se o n\u00famero digitado for menor que o n\u00famero sorteado, escreva \"Muito baixo\" ; Caso contr\u00e1rio, se o n\u00famero digitado for maior que o n\u00famero sorteado, escreva \"Muito alto\" ; Caso contr\u00e1rio, escreva \"Acertou\" . Repetindo o if \u00b6 Vamos fazer uma breve reflex\u00e3o. O que seria necess\u00e1rio alterar no c\u00f3digo do exerc\u00edcio 1 para que o jogador tivesse 2 chances? Uma solu\u00e7\u00e3o r\u00e1pida seria copiar o bloco do if , elif , else e colar no final do programa. Mas e se o jogador tivesse 5 chances? E 100? E se pudesse continuar tentando enquanto n\u00e3o tivesse adivinhado o n\u00famero ? EXERC\u00cdCIO 2 \u00b6 O nosso jogo possui muitas condi\u00e7\u00f5es, ent\u00e3o, para introduzir o pr\u00f3ximo conceito, vamos considerar um exemplo menor. Fa\u00e7a um programa que pergunta ao aluno se ele tem d\u00favidas na disciplina. Se o aluno responder qualquer coisa diferente de 'n\u00e3o' , escreva 'Pratique mais' . Uma poss\u00edvel solu\u00e7\u00e3o para esse exerc\u00edcio pode ser encontrada em: https://youtu.be/80jQUj6JmYY . Aten\u00e7\u00e3o : consulte o v\u00eddeo somente depois de tentar resolver o exerc\u00edcio. Compreender o v\u00eddeo n\u00e3o \u00e9 garantia de que voc\u00ea sabe resolver o problema. Caso voc\u00ea n\u00e3o tenha conseguido resolver o exerc\u00edcio, assista ao v\u00eddeo e depois tente novamente sem consultar o v\u00eddeo novamente . Resposta Seu c\u00f3digo deveria ser similar a este: resposta_do_aluno = input ( 'Voc\u00ea est\u00e1 com d\u00favidas? ' ) if resposta_do_aluno == 'n\u00e3o' : print ( 'Parab\u00e9ns!' ) else : print ( 'Pratique mais' ) Exerc\u00edcio 3 \u00b6 Vamos preparar nosso c\u00f3digo para que seja poss\u00edvel perguntar novamente se o aluno tem d\u00favidas caso ele j\u00e1 tenha respondido antes que sim. Adicione uma vari\u00e1vel tem_duvidas logo no come\u00e7o do programa . Inicialize essa vari\u00e1vel com (ou seja, fa\u00e7a ela receber inicialmente) o valor True . Coloque todo o seu c\u00f3digo original dentro de um if tem_duvidas : . Al\u00e9m disso, se o aluno responder 'n\u00e3o' , mude o valor da vari\u00e1vel tem_duvidas para False , pois o aluno n\u00e3o tem mais d\u00favidas. Info Essa modifica\u00e7\u00e3o n\u00e3o deve alterar o comportamento do seu programa. Teste-o para garantir que ainda est\u00e1 funcionando. Note que, como inicialmente tem_duvidas = True , o programa sempre vai entrar no if . Antes de prosseguir, compare o seu c\u00f3digo com a resposta abaixo. Para os pr\u00f3ximos passos fazerem sentido \u00e9 importante que o seu c\u00f3digo siga a mesma estrutura. Resposta Com a modifica\u00e7\u00e3o acima seu c\u00f3digo deve ficar semelhante a: tem_duvidas = True if tem_duvidas : resposta_do_aluno = input ( 'Voc\u00ea est\u00e1 com d\u00favidas? ' ) if resposta_do_aluno == 'n\u00e3o' : print ( 'Parab\u00e9ns!' ) tem_duvidas = False else : print ( 'Pratique mais' ) Considere a seguinte vers\u00e3o modificada do seu programa: tem_duvidas = True if tem_duvidas : resposta_do_aluno = input ( 'Voc\u00ea est\u00e1 com d\u00favidas? ' ) if resposta_do_aluno == 'n\u00e3o' : print ( 'Parab\u00e9ns!' ) tem_duvidas = False else : print ( 'Pratique mais' ) if tem_duvidas : resposta_do_aluno = input ( 'Voc\u00ea est\u00e1 com d\u00favidas? ' ) if resposta_do_aluno == 'n\u00e3o' : print ( 'Parab\u00e9ns!' ) tem_duvidas = False else : print ( 'Pratique mais' ) Existem duas possibilidades: Se o usu\u00e1rio responder 'n\u00e3o' na primeira vez, a vari\u00e1vel tem_duvidas ser\u00e1 atualizada com False . Assim, o bloco do segundo if tem_duvidas n\u00e3o ser\u00e1 executado . Se o usu\u00e1rio responder qualquer coisa diferente de 'n\u00e3o' , a vari\u00e1vel tem_duvidas continuar\u00e1 valendo True . Assim, o bloco do segundo if tem_duvidas ser\u00e1 executado e o programa perguntar\u00e1 novamente se o aluno tem d\u00favidas. Exerc\u00edcio 4 \u00b6 Modifique o programa acima para que o aluno tenha 5 chances para responder que n\u00e3o tem mais d\u00favidas. Depois disso, mesmo que ele ainda tenha d\u00favidas , escreva 'At\u00e9 a pr\u00f3xima' . Dica : a ideia deste exerc\u00edcio \u00e9 copiar e colar c\u00f3digo e adicionar um print no fim. Se voc\u00ea fez algo al\u00e9m disso, provavelmente n\u00e3o \u00e9 o que est\u00e1vamos esperando neste ponto. Resposta Com a modifica\u00e7\u00e3o acima seu c\u00f3digo deve ficar semelhante a: tem_duvidas = True if tem_duvidas : resposta_do_aluno = input ( 'Voc\u00ea est\u00e1 com d\u00favidas? ' ) if resposta_do_aluno == 'n\u00e3o' : print ( 'Parab\u00e9ns!' ) tem_duvidas = False else : print ( 'Pratique mais' ) if tem_duvidas : resposta_do_aluno = input ( 'Voc\u00ea est\u00e1 com d\u00favidas? ' ) if resposta_do_aluno == 'n\u00e3o' : print ( 'Parab\u00e9ns!' ) tem_duvidas = False else : print ( 'Pratique mais' ) if tem_duvidas : resposta_do_aluno = input ( 'Voc\u00ea est\u00e1 com d\u00favidas? ' ) if resposta_do_aluno == 'n\u00e3o' : print ( 'Parab\u00e9ns!' ) tem_duvidas = False else : print ( 'Pratique mais' ) if tem_duvidas : resposta_do_aluno = input ( 'Voc\u00ea est\u00e1 com d\u00favidas? ' ) if resposta_do_aluno == 'n\u00e3o' : print ( 'Parab\u00e9ns!' ) tem_duvidas = False else : print ( 'Pratique mais' ) if tem_duvidas : resposta_do_aluno = input ( 'Voc\u00ea est\u00e1 com d\u00favidas? ' ) if resposta_do_aluno == 'n\u00e3o' : print ( 'Parab\u00e9ns!' ) tem_duvidas = False else : print ( 'Pratique mais' ) O operador while \u00b6 Se quis\u00e9ssemos repetir a pergunta mais 100 vezes, poder\u00edamos continuar copiando e colando o c\u00f3digo. Um problema \u00e9 que o c\u00f3digo ficaria cada vez mais dif\u00edcil de manter. Imagine que voc\u00ea decidiu aceitar a resposta 'n\u00e3o tenho' ao inv\u00e9s de somente 'n\u00e3o' . Agora voc\u00ea teria pelo menos 100 linhas diferentes para alterar no seu c\u00f3digo. Ok, \u00e9 chato e pode dar bastante trabalho, mas ainda d\u00e1 para fazer. Agora, o que precisar\u00edamos fazer para que o programa continuasse perguntando enquanto o usu\u00e1rio n\u00e3o respondesse \"n\u00e3o\" . Se copi\u00e1ssemos o mesmo bloco de c\u00f3digo 1000 vezes ele poderia responder 'sim' nas 1001 primeiras vezes. Se fiz\u00e9ssemos o mesmo 100000 de vezes, o usu\u00e1rio ainda poderia (por mais que improv\u00e1vel) responder 'sim' nas 100001 primeiras vezes. Assim, vemos que \u00e9 necess\u00e1rio utilizar alguma outra estrutura, no caso, o operador while . Vamos come\u00e7ar relembrando o que o if faz: O while funciona de maneira similar, mas ao final da execu\u00e7\u00e3o do bloco, a condi\u00e7\u00e3o \u00e9 reavaliada e, caso seja verdadeira, o bloco \u00e9 executado novamente enquanto a condi\u00e7\u00e3o for verdadeira : EXERC\u00cdCIO 5 \u00b6 Modifique o programa do exerc\u00edcio 3 para que ele continue perguntando se o usu\u00e1rio tem d\u00favidas enquanto ele responder qualquer coisa diferente de 'n\u00e3o' . Dica : basta trocar um dos if s por um while . EXERC\u00cdCIO 6 \u00b6 Fa\u00e7a o exerc\u00edcio [TESTE DE MESA] Aluno com d\u00favidas . O v\u00eddeo a seguir apresenta uma poss\u00edvel solu\u00e7\u00e3o para o exerc\u00edcio anterior e explica o conceito de while : https://youtu.be/vNspAsXabxY . EXERC\u00cdCIO 7 \u00b6 Agora podemos voltar para o nosso jogo. Modifique o seu programa do exerc\u00edcio 1 para que o jogador possa continuar chutando um valor enquanto o usu\u00e1rio n\u00e3o acertar. Em outras palavras, modifique o programa para que o jogador tenha tentativas infinitas. O v\u00eddeo a seguir apresenta algumas poss\u00edveis solu\u00e7\u00f5es: https://youtu.be/Z-N5kzXHHO0 . Novamente, consulte o v\u00eddeo somente depois de tentar resolver o exerc\u00edcio por conta pr\u00f3pria . Alguns padr\u00f5es de uso do while \u00b6 Vamos trabalhar agora com alguns padr\u00f5es comuns de uso do while . Procure entender a l\u00f3gica dos programas a seguir. De modo geral sempre ser\u00e1 necess\u00e1rio adaptar o padr\u00e3o para a sua aplica\u00e7\u00e3o espec\u00edfica. EXERC\u00cdCIO 8 \u00b6 Fa\u00e7a o exerc\u00edcio [TESTE DE MESA] Padr\u00f5es de uso do while: contagem . Padr\u00f5es de uso do while : contagem \u00b6 Podemos utilizar o while para fazer contagens. No exemplo do exerc\u00edcio anterior, n\u00f3s contamos quantas vezes o bloco do while \u00e9 executado (lembrando que em programa\u00e7\u00e3o come\u00e7amos a contar do 0). Essa informa\u00e7\u00e3o \u00e9 armazenada na vari\u00e1vel contador . Voc\u00ea pode usar qualquer nome de vari\u00e1vel para o contador. No nosso exemplo n\u00f3s utilizamos contador para deixar o seu objetivo expl\u00edcito. Entretanto, o uso de contadores \u00e9 t\u00e3o comum, que \u00e9 normal encontrar vari\u00e1veis que servem como contadores com nomes curtos, como i ou j . Independentemente do nome da vari\u00e1vel, um contador \u00e9 uma vari\u00e1vel utilizada para guardar o resultado da contagem. EXERC\u00cdCIO 9 \u00b6 Modifique o c\u00f3digo do exerc\u00edcio 7 para mostrar ao final do jogo a quantidade de tentativas do jogador at\u00e9 ele descobrir o n\u00famero correto. O v\u00eddeo a seguir explica o padr\u00e3o de uso do while com contadores e apresenta uma poss\u00edvel solu\u00e7\u00e3o para este exerc\u00edcio: https://youtu.be/wBjnd2RaJKE . Como sempre, consulte somente depois de tentar resolver o exerc\u00edcio . EXERC\u00cdCIO 10 \u00b6 Fa\u00e7a o exerc\u00edcio [TESTE DE MESA] Padr\u00f5es de uso do while: valida\u00e7\u00e3o . Padr\u00f5es de uso do while : valida\u00e7\u00e3o \u00b6 No exerc\u00edcio 8 temos um exemplo de como usar o while para validar uma entrada. Nesse caso, o programa vai ficar \"preso\" no while at\u00e9 que o usu\u00e1rio digite um n\u00famero v\u00e1lido (no exemplo, um n\u00famero par). EXERC\u00cdCIO 11 \u00b6 Modifique o jogo de adivinha ( exerc\u00edcio 9 ) para validar que a entrada do usu\u00e1rio \u00e9 um n\u00famero inteiro entre 1 e 20 (inclusive). Ou seja, antes de verificar se o jogador acertou o n\u00famero \u00e9 necess\u00e1rio validar a entrada. Entradas inv\u00e1lidas n\u00e3o devem ser contabilizadas . Para uma poss\u00edvel solu\u00e7\u00e3o, consulte o v\u00eddeo a seguir: https://youtu.be/5IQDVYPi9As . EXERC\u00cdCIO 12 \u00b6 Modifique o jogo de adivinha para que ele tenha no m\u00e1ximo cinco tentativas. Caso o jogo termine por exceder o limite de tentativas, uma mensagem adequada deve ser impressa (e.g. 'Que pena, voc\u00ea perdeu!' ). Uma solu\u00e7\u00e3o \u00e9 apresentada em: https://youtu.be/GfsmrVnLdws EXERC\u00cdCIO ADICIONAL 1 \u00b6 Assista o v\u00eddeo a seguir com uma discuss\u00e3o sobre a qualidade do c\u00f3digo: https://youtu.be/XCb8jSUcfsc . MAIS EXERC\u00cdCIOS ADICIONAIS \u00b6 Como sempre, se acabar os exerc\u00edcios deste handout, continue praticando com os exerc\u00edcios dispon\u00edveis no servidor .","title":"Handout"},{"location":"aulas/04-while/#04-lacos-de-repeticao-while","text":"O objetivo de aprendizado deste handout \u00e9 que, ao final da atividade, voc\u00ea seja capaz de utilizar la\u00e7os de repeti\u00e7\u00e3o (n\u00e3o se preocupe, vamos explicar o que \u00e9 isso) em seus programas em conjunto com as estruturas que vimos nas aulas anteriores ( if , input , etc.) Para isso, vamos trabalhar com o exemplo de um jogo simples: o programa escolhe um n\u00famero aleat\u00f3rio e o jogador precisa descobrir qual foi o n\u00famero escolhido. Importante Sempre valide a resposta com o professor ou algum colega que j\u00e1 tenha validado a pr\u00f3pria resposta antes de seguir para o pr\u00f3ximo exerc\u00edcio .","title":"04 - La\u00e7os de Repeti\u00e7\u00e3o (while)"},{"location":"aulas/04-while/#aquecimento","text":"Para come\u00e7ar, vamos implementar uma vers\u00e3o do jogo na qual o jogador s\u00f3 tem uma chance para acertar (sim, completamente na sorte).","title":"Aquecimento"},{"location":"aulas/04-while/#exercicio-1","text":"Fa\u00e7a um programa que: Sorteia um n\u00famero aleat\u00f3rio entre 1 e 20 e guarda numa vari\u00e1vel; Use a fun\u00e7\u00e3o randint da biblioteca random ( dica : procure a documenta\u00e7\u00e3o na internet) Pede ao jogador um n\u00famero entre 1 e 20 D\u00ea o feedback da resposta do jogador: Se o n\u00famero digitado for menor que o n\u00famero sorteado, escreva \"Muito baixo\" ; Caso contr\u00e1rio, se o n\u00famero digitado for maior que o n\u00famero sorteado, escreva \"Muito alto\" ; Caso contr\u00e1rio, escreva \"Acertou\" .","title":"EXERC\u00cdCIO 1"},{"location":"aulas/04-while/#repetindo-o-if","text":"Vamos fazer uma breve reflex\u00e3o. O que seria necess\u00e1rio alterar no c\u00f3digo do exerc\u00edcio 1 para que o jogador tivesse 2 chances? Uma solu\u00e7\u00e3o r\u00e1pida seria copiar o bloco do if , elif , else e colar no final do programa. Mas e se o jogador tivesse 5 chances? E 100? E se pudesse continuar tentando enquanto n\u00e3o tivesse adivinhado o n\u00famero ?","title":"Repetindo o if"},{"location":"aulas/04-while/#exercicio-2","text":"O nosso jogo possui muitas condi\u00e7\u00f5es, ent\u00e3o, para introduzir o pr\u00f3ximo conceito, vamos considerar um exemplo menor. Fa\u00e7a um programa que pergunta ao aluno se ele tem d\u00favidas na disciplina. Se o aluno responder qualquer coisa diferente de 'n\u00e3o' , escreva 'Pratique mais' . Uma poss\u00edvel solu\u00e7\u00e3o para esse exerc\u00edcio pode ser encontrada em: https://youtu.be/80jQUj6JmYY . Aten\u00e7\u00e3o : consulte o v\u00eddeo somente depois de tentar resolver o exerc\u00edcio. Compreender o v\u00eddeo n\u00e3o \u00e9 garantia de que voc\u00ea sabe resolver o problema. Caso voc\u00ea n\u00e3o tenha conseguido resolver o exerc\u00edcio, assista ao v\u00eddeo e depois tente novamente sem consultar o v\u00eddeo novamente . Resposta Seu c\u00f3digo deveria ser similar a este: resposta_do_aluno = input ( 'Voc\u00ea est\u00e1 com d\u00favidas? ' ) if resposta_do_aluno == 'n\u00e3o' : print ( 'Parab\u00e9ns!' ) else : print ( 'Pratique mais' )","title":"EXERC\u00cdCIO 2"},{"location":"aulas/04-while/#exercicio-3","text":"Vamos preparar nosso c\u00f3digo para que seja poss\u00edvel perguntar novamente se o aluno tem d\u00favidas caso ele j\u00e1 tenha respondido antes que sim. Adicione uma vari\u00e1vel tem_duvidas logo no come\u00e7o do programa . Inicialize essa vari\u00e1vel com (ou seja, fa\u00e7a ela receber inicialmente) o valor True . Coloque todo o seu c\u00f3digo original dentro de um if tem_duvidas : . Al\u00e9m disso, se o aluno responder 'n\u00e3o' , mude o valor da vari\u00e1vel tem_duvidas para False , pois o aluno n\u00e3o tem mais d\u00favidas. Info Essa modifica\u00e7\u00e3o n\u00e3o deve alterar o comportamento do seu programa. Teste-o para garantir que ainda est\u00e1 funcionando. Note que, como inicialmente tem_duvidas = True , o programa sempre vai entrar no if . Antes de prosseguir, compare o seu c\u00f3digo com a resposta abaixo. Para os pr\u00f3ximos passos fazerem sentido \u00e9 importante que o seu c\u00f3digo siga a mesma estrutura. Resposta Com a modifica\u00e7\u00e3o acima seu c\u00f3digo deve ficar semelhante a: tem_duvidas = True if tem_duvidas : resposta_do_aluno = input ( 'Voc\u00ea est\u00e1 com d\u00favidas? ' ) if resposta_do_aluno == 'n\u00e3o' : print ( 'Parab\u00e9ns!' ) tem_duvidas = False else : print ( 'Pratique mais' ) Considere a seguinte vers\u00e3o modificada do seu programa: tem_duvidas = True if tem_duvidas : resposta_do_aluno = input ( 'Voc\u00ea est\u00e1 com d\u00favidas? ' ) if resposta_do_aluno == 'n\u00e3o' : print ( 'Parab\u00e9ns!' ) tem_duvidas = False else : print ( 'Pratique mais' ) if tem_duvidas : resposta_do_aluno = input ( 'Voc\u00ea est\u00e1 com d\u00favidas? ' ) if resposta_do_aluno == 'n\u00e3o' : print ( 'Parab\u00e9ns!' ) tem_duvidas = False else : print ( 'Pratique mais' ) Existem duas possibilidades: Se o usu\u00e1rio responder 'n\u00e3o' na primeira vez, a vari\u00e1vel tem_duvidas ser\u00e1 atualizada com False . Assim, o bloco do segundo if tem_duvidas n\u00e3o ser\u00e1 executado . Se o usu\u00e1rio responder qualquer coisa diferente de 'n\u00e3o' , a vari\u00e1vel tem_duvidas continuar\u00e1 valendo True . Assim, o bloco do segundo if tem_duvidas ser\u00e1 executado e o programa perguntar\u00e1 novamente se o aluno tem d\u00favidas.","title":"Exerc\u00edcio 3"},{"location":"aulas/04-while/#exercicio-4","text":"Modifique o programa acima para que o aluno tenha 5 chances para responder que n\u00e3o tem mais d\u00favidas. Depois disso, mesmo que ele ainda tenha d\u00favidas , escreva 'At\u00e9 a pr\u00f3xima' . Dica : a ideia deste exerc\u00edcio \u00e9 copiar e colar c\u00f3digo e adicionar um print no fim. Se voc\u00ea fez algo al\u00e9m disso, provavelmente n\u00e3o \u00e9 o que est\u00e1vamos esperando neste ponto. Resposta Com a modifica\u00e7\u00e3o acima seu c\u00f3digo deve ficar semelhante a: tem_duvidas = True if tem_duvidas : resposta_do_aluno = input ( 'Voc\u00ea est\u00e1 com d\u00favidas? ' ) if resposta_do_aluno == 'n\u00e3o' : print ( 'Parab\u00e9ns!' ) tem_duvidas = False else : print ( 'Pratique mais' ) if tem_duvidas : resposta_do_aluno = input ( 'Voc\u00ea est\u00e1 com d\u00favidas? ' ) if resposta_do_aluno == 'n\u00e3o' : print ( 'Parab\u00e9ns!' ) tem_duvidas = False else : print ( 'Pratique mais' ) if tem_duvidas : resposta_do_aluno = input ( 'Voc\u00ea est\u00e1 com d\u00favidas? ' ) if resposta_do_aluno == 'n\u00e3o' : print ( 'Parab\u00e9ns!' ) tem_duvidas = False else : print ( 'Pratique mais' ) if tem_duvidas : resposta_do_aluno = input ( 'Voc\u00ea est\u00e1 com d\u00favidas? ' ) if resposta_do_aluno == 'n\u00e3o' : print ( 'Parab\u00e9ns!' ) tem_duvidas = False else : print ( 'Pratique mais' ) if tem_duvidas : resposta_do_aluno = input ( 'Voc\u00ea est\u00e1 com d\u00favidas? ' ) if resposta_do_aluno == 'n\u00e3o' : print ( 'Parab\u00e9ns!' ) tem_duvidas = False else : print ( 'Pratique mais' )","title":"Exerc\u00edcio 4"},{"location":"aulas/04-while/#o-operador-while","text":"Se quis\u00e9ssemos repetir a pergunta mais 100 vezes, poder\u00edamos continuar copiando e colando o c\u00f3digo. Um problema \u00e9 que o c\u00f3digo ficaria cada vez mais dif\u00edcil de manter. Imagine que voc\u00ea decidiu aceitar a resposta 'n\u00e3o tenho' ao inv\u00e9s de somente 'n\u00e3o' . Agora voc\u00ea teria pelo menos 100 linhas diferentes para alterar no seu c\u00f3digo. Ok, \u00e9 chato e pode dar bastante trabalho, mas ainda d\u00e1 para fazer. Agora, o que precisar\u00edamos fazer para que o programa continuasse perguntando enquanto o usu\u00e1rio n\u00e3o respondesse \"n\u00e3o\" . Se copi\u00e1ssemos o mesmo bloco de c\u00f3digo 1000 vezes ele poderia responder 'sim' nas 1001 primeiras vezes. Se fiz\u00e9ssemos o mesmo 100000 de vezes, o usu\u00e1rio ainda poderia (por mais que improv\u00e1vel) responder 'sim' nas 100001 primeiras vezes. Assim, vemos que \u00e9 necess\u00e1rio utilizar alguma outra estrutura, no caso, o operador while . Vamos come\u00e7ar relembrando o que o if faz: O while funciona de maneira similar, mas ao final da execu\u00e7\u00e3o do bloco, a condi\u00e7\u00e3o \u00e9 reavaliada e, caso seja verdadeira, o bloco \u00e9 executado novamente enquanto a condi\u00e7\u00e3o for verdadeira :","title":"O operador while"},{"location":"aulas/04-while/#exercicio-5","text":"Modifique o programa do exerc\u00edcio 3 para que ele continue perguntando se o usu\u00e1rio tem d\u00favidas enquanto ele responder qualquer coisa diferente de 'n\u00e3o' . Dica : basta trocar um dos if s por um while .","title":"EXERC\u00cdCIO 5"},{"location":"aulas/04-while/#exercicio-6","text":"Fa\u00e7a o exerc\u00edcio [TESTE DE MESA] Aluno com d\u00favidas . O v\u00eddeo a seguir apresenta uma poss\u00edvel solu\u00e7\u00e3o para o exerc\u00edcio anterior e explica o conceito de while : https://youtu.be/vNspAsXabxY .","title":"EXERC\u00cdCIO 6"},{"location":"aulas/04-while/#exercicio-7","text":"Agora podemos voltar para o nosso jogo. Modifique o seu programa do exerc\u00edcio 1 para que o jogador possa continuar chutando um valor enquanto o usu\u00e1rio n\u00e3o acertar. Em outras palavras, modifique o programa para que o jogador tenha tentativas infinitas. O v\u00eddeo a seguir apresenta algumas poss\u00edveis solu\u00e7\u00f5es: https://youtu.be/Z-N5kzXHHO0 . Novamente, consulte o v\u00eddeo somente depois de tentar resolver o exerc\u00edcio por conta pr\u00f3pria .","title":"EXERC\u00cdCIO 7"},{"location":"aulas/04-while/#alguns-padroes-de-uso-do-while","text":"Vamos trabalhar agora com alguns padr\u00f5es comuns de uso do while . Procure entender a l\u00f3gica dos programas a seguir. De modo geral sempre ser\u00e1 necess\u00e1rio adaptar o padr\u00e3o para a sua aplica\u00e7\u00e3o espec\u00edfica.","title":"Alguns padr\u00f5es de uso do while"},{"location":"aulas/04-while/#exercicio-8","text":"Fa\u00e7a o exerc\u00edcio [TESTE DE MESA] Padr\u00f5es de uso do while: contagem .","title":"EXERC\u00cdCIO 8"},{"location":"aulas/04-while/#padroes-de-uso-do-while-contagem","text":"Podemos utilizar o while para fazer contagens. No exemplo do exerc\u00edcio anterior, n\u00f3s contamos quantas vezes o bloco do while \u00e9 executado (lembrando que em programa\u00e7\u00e3o come\u00e7amos a contar do 0). Essa informa\u00e7\u00e3o \u00e9 armazenada na vari\u00e1vel contador . Voc\u00ea pode usar qualquer nome de vari\u00e1vel para o contador. No nosso exemplo n\u00f3s utilizamos contador para deixar o seu objetivo expl\u00edcito. Entretanto, o uso de contadores \u00e9 t\u00e3o comum, que \u00e9 normal encontrar vari\u00e1veis que servem como contadores com nomes curtos, como i ou j . Independentemente do nome da vari\u00e1vel, um contador \u00e9 uma vari\u00e1vel utilizada para guardar o resultado da contagem.","title":"Padr\u00f5es de uso do while: contagem"},{"location":"aulas/04-while/#exercicio-9","text":"Modifique o c\u00f3digo do exerc\u00edcio 7 para mostrar ao final do jogo a quantidade de tentativas do jogador at\u00e9 ele descobrir o n\u00famero correto. O v\u00eddeo a seguir explica o padr\u00e3o de uso do while com contadores e apresenta uma poss\u00edvel solu\u00e7\u00e3o para este exerc\u00edcio: https://youtu.be/wBjnd2RaJKE . Como sempre, consulte somente depois de tentar resolver o exerc\u00edcio .","title":"EXERC\u00cdCIO 9"},{"location":"aulas/04-while/#exercicio-10","text":"Fa\u00e7a o exerc\u00edcio [TESTE DE MESA] Padr\u00f5es de uso do while: valida\u00e7\u00e3o .","title":"EXERC\u00cdCIO 10"},{"location":"aulas/04-while/#padroes-de-uso-do-while-validacao","text":"No exerc\u00edcio 8 temos um exemplo de como usar o while para validar uma entrada. Nesse caso, o programa vai ficar \"preso\" no while at\u00e9 que o usu\u00e1rio digite um n\u00famero v\u00e1lido (no exemplo, um n\u00famero par).","title":"Padr\u00f5es de uso do while: valida\u00e7\u00e3o"},{"location":"aulas/04-while/#exercicio-11","text":"Modifique o jogo de adivinha ( exerc\u00edcio 9 ) para validar que a entrada do usu\u00e1rio \u00e9 um n\u00famero inteiro entre 1 e 20 (inclusive). Ou seja, antes de verificar se o jogador acertou o n\u00famero \u00e9 necess\u00e1rio validar a entrada. Entradas inv\u00e1lidas n\u00e3o devem ser contabilizadas . Para uma poss\u00edvel solu\u00e7\u00e3o, consulte o v\u00eddeo a seguir: https://youtu.be/5IQDVYPi9As .","title":"EXERC\u00cdCIO 11"},{"location":"aulas/04-while/#exercicio-12","text":"Modifique o jogo de adivinha para que ele tenha no m\u00e1ximo cinco tentativas. Caso o jogo termine por exceder o limite de tentativas, uma mensagem adequada deve ser impressa (e.g. 'Que pena, voc\u00ea perdeu!' ). Uma solu\u00e7\u00e3o \u00e9 apresentada em: https://youtu.be/GfsmrVnLdws","title":"EXERC\u00cdCIO 12"},{"location":"aulas/04-while/#exercicio-adicional-1","text":"Assista o v\u00eddeo a seguir com uma discuss\u00e3o sobre a qualidade do c\u00f3digo: https://youtu.be/XCb8jSUcfsc .","title":"EXERC\u00cdCIO ADICIONAL 1"},{"location":"aulas/04-while/#mais-exercicios-adicionais","text":"Como sempre, se acabar os exerc\u00edcios deste handout, continue praticando com os exerc\u00edcios dispon\u00edveis no servidor .","title":"MAIS EXERC\u00cdCIOS ADICIONAIS"},{"location":"aulas/05-listas/","text":"05 - Listas \u00b6 O objetivo de aprendizado deste handout \u00e9 que, ao final da atividade, voc\u00ea seja capaz de utilizar listas em seus programas em conjunto com as estruturas que vimos nas aulas anteriores ( input , if , while , etc.). Vamos come\u00e7ar com um aquecimento. EXERC\u00cdCIO 1 \u00b6 Utilizando apenas o que j\u00e1 vimos sobre Python, implemente um programa que pergunta para o usu\u00e1rio a nota de 3 alunos e armazena cada nota em uma vari\u00e1vel. Depois de receber os 3 valores, imprima as notas e a m\u00e9dia. Para o usu\u00e1rio, seu programa deve se comportar da seguinte maneira caso ele digite 8 , 2 e 8 (esse \u00e9 um exemplo de sa\u00edda do terminal): Digite a nota 1: 8 Digite a nota 2: 2 Digite a nota 3: 8 Notas digitadas: 8 2 8 M\u00e9dia: 6 EXERC\u00cdCIO 2 \u00b6 Altere seu programa do exerc\u00edcio 1 para que ele pergunte 6 notas ao inv\u00e9s de 3. Note que ser\u00e1 necess\u00e1rio alterar seu c\u00f3digo que imprime todas as notas digitadas e a m\u00e9dia. Dica: a solu\u00e7\u00e3o envolve basicamente copiar e colar c\u00f3digo. E se fosse um MOOC (Massive Open Online Course)? \u00b6 O que aconteceria se ao inv\u00e9s de 6 notas tiv\u00e9ssemos 10000 notas? Ainda seria poss\u00edvel (mas definitivamente n\u00e3o recomend\u00e1vel) copiar e colar as mesmas linhas para adaptar o c\u00f3digo para essa nova situa\u00e7\u00e3o. Pior, sempre \u00e9 poss\u00edvel que o usu\u00e1rio precise de 1 nota a mais e voc\u00ea teria que alterar o seu programa novamente. O problema \u00e9 que o programa escrito dessa forma pode armazenar uma quantidade fixa de notas. Seria interessante termos alguma forma de armazenar uma quantidade vari\u00e1vel de notas, que fosse aumentando conforme a demanda. \u00c9 a\u00ed que entram as listas em Python. O tipo list \u00b6 Listas s\u00e3o uma das mais formas mais comuns de se organizar uma sequ\u00eancia de dados em Python. Para acessar um dado armazenado em uma lista utilizamos a sua posi\u00e7\u00e3o, ou \u00edndice. Por exemplo, o c\u00f3digo a seguir cria uma lista com os n\u00fameros 3 , 5 , 2 , 4 e 9 e a armazena em uma vari\u00e1vel chamada a : a = [ 3 , 5 , 2 , 4 , 9 ] Lembrando que em programa\u00e7\u00e3o come\u00e7amos a contar a partir de zero, o elemento no \u00edndice 0 (zero) \u00e9 o primeiro elemento (n\u00famero 3 ), no \u00edndice 1 \u00e9 o segundo elemento (n\u00famero 5 ), no \u00edndice 2 \u00e9 o terceiro elemento (n\u00famero 2 ) e assim por diante. Note que o \u00faltimo \u00edndice poss\u00edvel \u00e9 igual ao tamanho da lista subtra\u00eddo por 1 . No nosso exemplo, o \u00edndice do \u00faltimo elemento \u00e9 4 e a lista tem tamanho 5. Cabe tudo em uma lista! \u00b6 Uma caracter\u00edstica importante de listas \u00e9 que elas podem guardar qualquer tipo de dados dispon\u00edvel no Python. Basta colocar os itens entre colchetes e separ\u00e1-los por v\u00edrgulas . Por exemplo: lista_de_strings = [ 'banana' , 'abobora' , 'ma\u00e7\u00e3' , 'jaca' ] lista_de_ints = [ 3 , 5 , 2 , 1 , 3 ] # Sim, pode ter elementos repetidos lista_de_floats = [ 3.14 , 2.7 , 1.00001 ] Podemos inclusive criar listas vazias: sacola_de_compras = [] Mas qual \u00e9 a utilidade de criar uma lista vazia? Voc\u00ea se lembra que comentamos acima sobre armazenar uma quantidade vari\u00e1vel de elementos? Em uma lista \u00e9 poss\u00edvel adicionar novos elementos conforme a necessidade. Acessando elementos de uma lista \u00b6 Para acessar um elemento de uma lista utilizamos a sua posi\u00e7\u00e3o (\u00edndice) entre colchetes. Por exemplo, para acessar o terceiro elemento da lista a = [ 3 , 5 , 2 , 4 , 9 ] utilizamos o comando a [ 2 ] . EXERC\u00cdCIO 3 \u00b6 Fa\u00e7a o [TESTE DE MESA] Imprimindo elementos de uma lista . Descobrindo o n\u00famero de elementos em uma lista \u00b6 Podemos utilizar a fun\u00e7\u00e3o len () para descobrir o tamanho de uma lista, ou seja, quantos elementos est\u00e3o dispon\u00edveis nessa lista. EXERC\u00cdCIO 4 \u00b6 Sabendo disso, utilize seus conhecimentos de while da aula passada para resolver o [TESTE DE MESA] Imprimindo elementos de uma lista com while . EXERC\u00cdCIO 5 \u00b6 Resolva o exerc\u00edcio 40 do servidor . Dica: ser\u00e1 necess\u00e1rio criar pelo menos duas vari\u00e1veis auxiliares, uma para guardar o \u00edndice e outra para guardar a soma. Substituindo elementos em uma lista \u00b6 Podemos tamb\u00e9m substituir o elemento em um \u00edndice espec\u00edfico da lista. Por exemplo, na lista a = [ 1 , 2 , 5 , 7 ] podemos substituir o segundo elemento pelo n\u00famero 3 da seguinte maneira: a = [ 1 , 2 , 5 , 7 ] a [ 1 ] = 3 # O print a seguir vai imprimir a lista corrigida print ( a ) EXERC\u00cdCIO 6 \u00b6 Sabendo disso, resolva o [TESTE DE MESA] Corrigindo a lista de primos . EXERC\u00cdCIO 7 \u00b6 Resolva o exerc\u00edcio 41 do servidor . Adicionando e removendo elementos em uma lista \u00b6 Comentamos anteriormente que a lista pode guardar uma quantidade arbitr\u00e1ria de elementos. Essa quantidade pode, inclusive, mudar ao longo do tempo. Podemos adicionar e remover elementos a uma lista com o operador del e a fun\u00e7\u00e3o . append () . EXERC\u00cdCIO 8 \u00b6 Para entender como esses comandos funcionam, fa\u00e7a o [TESTE DE MESA] Adicionando e removendo elementos de uma lista . EXERC\u00cdCIO 9 \u00b6 Resolva o exerc\u00edcio 42 do servidor . Soma e multiplica\u00e7\u00e3o de listas? \u00b6 Existe a op\u00e7\u00e3o de somarmos uma lista a outra. O resultado \u00e9 uma nova lista com os elementos de ambas. Por exemplo: lista_1 = [ 1 , 2 , 3 ] lista_2 = [ 4 , 5 , 6 ] lista_1_e_2 = lista_1 + lista_2 print ( lista_1_e_2 ) # Vai imprimir [1, 2, 3, 4, 5, 6] lista_2_e_1 = lista_2 + lista_1 print ( lista_2_e_1 ) # Vai imprimir [4, 5, 6, 1, 2, 3] Al\u00e9m disso, tamb\u00e9m temos a op\u00e7\u00e3o de multiplicar uma lista por um n\u00famero inteiro. Lembrando da matem\u00e1tica, multiplicar um n\u00famero m m por outro n\u00famero n n \u00e9 o mesmo que somar m m com ele mesmo n n vezes. Ao multiplicarmos uma lista por um n\u00famero temos um resultado an\u00e1logo: numeros = [ 1 , 2 , 3 ] numeros_vezes_3 = numeros * 3 # An\u00e1logo a: numeros + numeros + numeros print ( numeros_vezes_3 ) # Vai imprimir [1, 2, 3, 1, 2, 3, 1, 2, 3] Observa\u00e7\u00e3o: esse comportamento \u00e9 muito semelhante \u00e0s somas e multiplica\u00e7\u00f5es de strings . EXERC\u00cdCIO 10 \u00b6 Fa\u00e7a o [TESTE DE MESA] Soma e multiplica\u00e7\u00e3o de listas . EXERC\u00cdCIOS ADICIONAIS \u00b6 Como sempre, resolva os outros exerc\u00edcios dispon\u00edveis no servidor .","title":"Handout"},{"location":"aulas/05-listas/#05-listas","text":"O objetivo de aprendizado deste handout \u00e9 que, ao final da atividade, voc\u00ea seja capaz de utilizar listas em seus programas em conjunto com as estruturas que vimos nas aulas anteriores ( input , if , while , etc.). Vamos come\u00e7ar com um aquecimento.","title":"05 - Listas"},{"location":"aulas/05-listas/#exercicio-1","text":"Utilizando apenas o que j\u00e1 vimos sobre Python, implemente um programa que pergunta para o usu\u00e1rio a nota de 3 alunos e armazena cada nota em uma vari\u00e1vel. Depois de receber os 3 valores, imprima as notas e a m\u00e9dia. Para o usu\u00e1rio, seu programa deve se comportar da seguinte maneira caso ele digite 8 , 2 e 8 (esse \u00e9 um exemplo de sa\u00edda do terminal): Digite a nota 1: 8 Digite a nota 2: 2 Digite a nota 3: 8 Notas digitadas: 8 2 8 M\u00e9dia: 6","title":"EXERC\u00cdCIO 1"},{"location":"aulas/05-listas/#exercicio-2","text":"Altere seu programa do exerc\u00edcio 1 para que ele pergunte 6 notas ao inv\u00e9s de 3. Note que ser\u00e1 necess\u00e1rio alterar seu c\u00f3digo que imprime todas as notas digitadas e a m\u00e9dia. Dica: a solu\u00e7\u00e3o envolve basicamente copiar e colar c\u00f3digo.","title":"EXERC\u00cdCIO 2"},{"location":"aulas/05-listas/#e-se-fosse-um-mooc-massive-open-online-course","text":"O que aconteceria se ao inv\u00e9s de 6 notas tiv\u00e9ssemos 10000 notas? Ainda seria poss\u00edvel (mas definitivamente n\u00e3o recomend\u00e1vel) copiar e colar as mesmas linhas para adaptar o c\u00f3digo para essa nova situa\u00e7\u00e3o. Pior, sempre \u00e9 poss\u00edvel que o usu\u00e1rio precise de 1 nota a mais e voc\u00ea teria que alterar o seu programa novamente. O problema \u00e9 que o programa escrito dessa forma pode armazenar uma quantidade fixa de notas. Seria interessante termos alguma forma de armazenar uma quantidade vari\u00e1vel de notas, que fosse aumentando conforme a demanda. \u00c9 a\u00ed que entram as listas em Python.","title":"E se fosse um MOOC (Massive Open Online Course)?"},{"location":"aulas/05-listas/#o-tipo-list","text":"Listas s\u00e3o uma das mais formas mais comuns de se organizar uma sequ\u00eancia de dados em Python. Para acessar um dado armazenado em uma lista utilizamos a sua posi\u00e7\u00e3o, ou \u00edndice. Por exemplo, o c\u00f3digo a seguir cria uma lista com os n\u00fameros 3 , 5 , 2 , 4 e 9 e a armazena em uma vari\u00e1vel chamada a : a = [ 3 , 5 , 2 , 4 , 9 ] Lembrando que em programa\u00e7\u00e3o come\u00e7amos a contar a partir de zero, o elemento no \u00edndice 0 (zero) \u00e9 o primeiro elemento (n\u00famero 3 ), no \u00edndice 1 \u00e9 o segundo elemento (n\u00famero 5 ), no \u00edndice 2 \u00e9 o terceiro elemento (n\u00famero 2 ) e assim por diante. Note que o \u00faltimo \u00edndice poss\u00edvel \u00e9 igual ao tamanho da lista subtra\u00eddo por 1 . No nosso exemplo, o \u00edndice do \u00faltimo elemento \u00e9 4 e a lista tem tamanho 5.","title":"O tipo list"},{"location":"aulas/05-listas/#cabe-tudo-em-uma-lista","text":"Uma caracter\u00edstica importante de listas \u00e9 que elas podem guardar qualquer tipo de dados dispon\u00edvel no Python. Basta colocar os itens entre colchetes e separ\u00e1-los por v\u00edrgulas . Por exemplo: lista_de_strings = [ 'banana' , 'abobora' , 'ma\u00e7\u00e3' , 'jaca' ] lista_de_ints = [ 3 , 5 , 2 , 1 , 3 ] # Sim, pode ter elementos repetidos lista_de_floats = [ 3.14 , 2.7 , 1.00001 ] Podemos inclusive criar listas vazias: sacola_de_compras = [] Mas qual \u00e9 a utilidade de criar uma lista vazia? Voc\u00ea se lembra que comentamos acima sobre armazenar uma quantidade vari\u00e1vel de elementos? Em uma lista \u00e9 poss\u00edvel adicionar novos elementos conforme a necessidade.","title":"Cabe tudo em uma lista!"},{"location":"aulas/05-listas/#acessando-elementos-de-uma-lista","text":"Para acessar um elemento de uma lista utilizamos a sua posi\u00e7\u00e3o (\u00edndice) entre colchetes. Por exemplo, para acessar o terceiro elemento da lista a = [ 3 , 5 , 2 , 4 , 9 ] utilizamos o comando a [ 2 ] .","title":"Acessando elementos de uma lista"},{"location":"aulas/05-listas/#exercicio-3","text":"Fa\u00e7a o [TESTE DE MESA] Imprimindo elementos de uma lista .","title":"EXERC\u00cdCIO 3"},{"location":"aulas/05-listas/#descobrindo-o-numero-de-elementos-em-uma-lista","text":"Podemos utilizar a fun\u00e7\u00e3o len () para descobrir o tamanho de uma lista, ou seja, quantos elementos est\u00e3o dispon\u00edveis nessa lista.","title":"Descobrindo o n\u00famero de elementos em uma lista"},{"location":"aulas/05-listas/#exercicio-4","text":"Sabendo disso, utilize seus conhecimentos de while da aula passada para resolver o [TESTE DE MESA] Imprimindo elementos de uma lista com while .","title":"EXERC\u00cdCIO 4"},{"location":"aulas/05-listas/#exercicio-5","text":"Resolva o exerc\u00edcio 40 do servidor . Dica: ser\u00e1 necess\u00e1rio criar pelo menos duas vari\u00e1veis auxiliares, uma para guardar o \u00edndice e outra para guardar a soma.","title":"EXERC\u00cdCIO 5"},{"location":"aulas/05-listas/#substituindo-elementos-em-uma-lista","text":"Podemos tamb\u00e9m substituir o elemento em um \u00edndice espec\u00edfico da lista. Por exemplo, na lista a = [ 1 , 2 , 5 , 7 ] podemos substituir o segundo elemento pelo n\u00famero 3 da seguinte maneira: a = [ 1 , 2 , 5 , 7 ] a [ 1 ] = 3 # O print a seguir vai imprimir a lista corrigida print ( a )","title":"Substituindo elementos em uma lista"},{"location":"aulas/05-listas/#exercicio-6","text":"Sabendo disso, resolva o [TESTE DE MESA] Corrigindo a lista de primos .","title":"EXERC\u00cdCIO 6"},{"location":"aulas/05-listas/#exercicio-7","text":"Resolva o exerc\u00edcio 41 do servidor .","title":"EXERC\u00cdCIO 7"},{"location":"aulas/05-listas/#adicionando-e-removendo-elementos-em-uma-lista","text":"Comentamos anteriormente que a lista pode guardar uma quantidade arbitr\u00e1ria de elementos. Essa quantidade pode, inclusive, mudar ao longo do tempo. Podemos adicionar e remover elementos a uma lista com o operador del e a fun\u00e7\u00e3o . append () .","title":"Adicionando e removendo elementos em uma lista"},{"location":"aulas/05-listas/#exercicio-8","text":"Para entender como esses comandos funcionam, fa\u00e7a o [TESTE DE MESA] Adicionando e removendo elementos de uma lista .","title":"EXERC\u00cdCIO 8"},{"location":"aulas/05-listas/#exercicio-9","text":"Resolva o exerc\u00edcio 42 do servidor .","title":"EXERC\u00cdCIO 9"},{"location":"aulas/05-listas/#soma-e-multiplicacao-de-listas","text":"Existe a op\u00e7\u00e3o de somarmos uma lista a outra. O resultado \u00e9 uma nova lista com os elementos de ambas. Por exemplo: lista_1 = [ 1 , 2 , 3 ] lista_2 = [ 4 , 5 , 6 ] lista_1_e_2 = lista_1 + lista_2 print ( lista_1_e_2 ) # Vai imprimir [1, 2, 3, 4, 5, 6] lista_2_e_1 = lista_2 + lista_1 print ( lista_2_e_1 ) # Vai imprimir [4, 5, 6, 1, 2, 3] Al\u00e9m disso, tamb\u00e9m temos a op\u00e7\u00e3o de multiplicar uma lista por um n\u00famero inteiro. Lembrando da matem\u00e1tica, multiplicar um n\u00famero m m por outro n\u00famero n n \u00e9 o mesmo que somar m m com ele mesmo n n vezes. Ao multiplicarmos uma lista por um n\u00famero temos um resultado an\u00e1logo: numeros = [ 1 , 2 , 3 ] numeros_vezes_3 = numeros * 3 # An\u00e1logo a: numeros + numeros + numeros print ( numeros_vezes_3 ) # Vai imprimir [1, 2, 3, 1, 2, 3, 1, 2, 3] Observa\u00e7\u00e3o: esse comportamento \u00e9 muito semelhante \u00e0s somas e multiplica\u00e7\u00f5es de strings .","title":"Soma e multiplica\u00e7\u00e3o de listas?"},{"location":"aulas/05-listas/#exercicio-10","text":"Fa\u00e7a o [TESTE DE MESA] Soma e multiplica\u00e7\u00e3o de listas .","title":"EXERC\u00cdCIO 10"},{"location":"aulas/05-listas/#exercicios-adicionais","text":"Como sempre, resolva os outros exerc\u00edcios dispon\u00edveis no servidor .","title":"EXERC\u00cdCIOS ADICIONAIS"},{"location":"aulas/06-for/","text":"06 - For \u00b6 O objetivo de aprendizado deste handout \u00e9 que, ao final da atividade, voc\u00ea seja capaz de utilizar o for para percorrer listas e intervalos ( range ) em seus programas em conjunto com as estruturas que vimos nas aulas anteriores ( input , if , while , etc.). Vamos come\u00e7ar com um exemplo. Percorrendo listas com while \u00b6 Considere a fun\u00e7\u00e3o a seguir, que recebe uma lista de n\u00fameros como argumento: def soma_elementos ( lista ): soma = 0 i = 0 while i < len ( lista ): n = lista [ i ] soma += n i += 1 return soma O que ela faz? Ela inicializa uma vari\u00e1vel soma com o valor zero e, para cada elemento n da lista , adiciona o valor guardado em n na vari\u00e1vel soma e vai para o pr\u00f3ximo elemento . Depois disso, devolve o resultado da soma de todos os elementos. Depois de fazer muitos exerc\u00edcios voc\u00ea pode ter percebido que em muitos casos temos uma estrutura muito parecida com essa quando estamos percorrendo uma lista: # Faz algumas inicializa\u00e7\u00f5es i = 0 while i < len ( lista ): elemento = lista [ i ] # Faz alguma coisa com o elemento i += 1 Com essa estrutura podemos, por exemplo, imprimir ou somar todos os elementos de uma lista. Nesses casos, a l\u00f3gica \u00e9 sempre parecida: executa alguma a\u00e7\u00e3o para cada elemento da lista . Na verdade esse tipo de procedimento \u00e9 t\u00e3o comum que existe uma maneira mais sucinta de fazer isso em Python: a repeti\u00e7\u00e3o for . A repeti\u00e7\u00e3o for \u00b6 O for percorre automaticamente todos os elementos em uma lista, caracteres em uma string, e outras estruturas que veremos no futuro: Ele se comporta de forma semelhante ao while se considerarmos que ele executa o bloco de c\u00f3digo m\u00faltiplas vezes, mas uma diferen\u00e7a importante \u00e9 que o for n\u00e3o possui condi\u00e7\u00e3o . Ele percorre todos os elementos e depois termina. Podemos ler o c\u00f3digo abaixo: como: Assim, podemos reescrever o c\u00f3digo a seguir: utilizando o for: Cada vez que o Python for executar o bloco dentro do for a vari\u00e1vel e ser\u00e1 automaticamente atualizada com o valor do pr\u00f3ximo elemento da lista. EXERC\u00cdCIO 1 \u00b6 Fa\u00e7a o [TESTE DE MESA] Percorrendo uma lista com for . EXERC\u00cdCIO 2 \u00b6 Quando utilizamos o for com uma string, o Python executa o bloco para cada caractere dessa string. Sabendo disso, fa\u00e7a o [TESTE DE MESA] Percorrendo uma string com for . O range \u00b6 Outra estrat\u00e9gia bastante comum em programa\u00e7\u00e3o \u00e9 o uso de contadores para percorrer n\u00fameros em um intervalo. Executamos uma determinada opera\u00e7\u00e3o para o valor 0, depois para o valor 1, depois para o valor 2, e assim por diante. O Python possui uma fun\u00e7\u00e3o chamada range que gera essa sequ\u00eancia de n\u00fameros naturais. Existem 3 maneiras de utilizar o range : range com um argumento: os n\u00fameros gerados v\u00e3o desde o zero at\u00e9 o antes do argumento. Exemplo: range ( 3 ) gera a sequ\u00eancia 0 , 1 , 2 (note que o 3 n\u00e3o pertence \u00e0 sequ\u00eancia gerada); range com dois argumentos: os n\u00fameros gerados v\u00e3o desde o primeiro argument at\u00e9 antes do segundo argumento. Exemplo: range ( 13 , 17 ) gera a sequ\u00eancia 13 , 14 , 15 , 16 (note que o 13 pertence \u00e0 sequ\u00eancia, mas o 17 , n\u00e3o); range com tr\u00eas argumentos: os n\u00fameros gerados v\u00e3o desde o primeiro argument at\u00e9 antes do segundo argumento e o terceiro argumento \u00e9 o salto de um elemento gerado para o pr\u00f3ximo. Exemplo: range ( 2 , 13 , 3 ) gera a sequ\u00eancia 2 , 5 , 8 , 11 (note que o 2 pertence \u00e0 sequ\u00eancia, mas o pr\u00f3ximo elemento da sequ\u00eancia, o 14 , n\u00e3o). EXERC\u00cdCIO 3 \u00b6 Fa\u00e7a o exerc\u00edcio [TESTE DE MESA] Percorrendo um range com for . EXERC\u00cdCIOS ADICIONAIS \u00b6 Refa\u00e7a os exerc\u00edcios a seguir utilizando for e, quando necess\u00e1rio range : 28. Soma dos 100 primeiros termos 36. Calcula fatorial 40. Soma valores da lista 46. N\u00famero igual ao \u00edndice 53. Soma dos n\u00famero \u00edmpares Para praticar mais, refa\u00e7a os outros exerc\u00edcios que resolveu com while agora utilizando o for . Importante Nem todos os exerc\u00edcios podem ser resolvidos com o for .","title":"Handout"},{"location":"aulas/06-for/#06-for","text":"O objetivo de aprendizado deste handout \u00e9 que, ao final da atividade, voc\u00ea seja capaz de utilizar o for para percorrer listas e intervalos ( range ) em seus programas em conjunto com as estruturas que vimos nas aulas anteriores ( input , if , while , etc.). Vamos come\u00e7ar com um exemplo.","title":"06 - For"},{"location":"aulas/06-for/#percorrendo-listas-com-while","text":"Considere a fun\u00e7\u00e3o a seguir, que recebe uma lista de n\u00fameros como argumento: def soma_elementos ( lista ): soma = 0 i = 0 while i < len ( lista ): n = lista [ i ] soma += n i += 1 return soma O que ela faz? Ela inicializa uma vari\u00e1vel soma com o valor zero e, para cada elemento n da lista , adiciona o valor guardado em n na vari\u00e1vel soma e vai para o pr\u00f3ximo elemento . Depois disso, devolve o resultado da soma de todos os elementos. Depois de fazer muitos exerc\u00edcios voc\u00ea pode ter percebido que em muitos casos temos uma estrutura muito parecida com essa quando estamos percorrendo uma lista: # Faz algumas inicializa\u00e7\u00f5es i = 0 while i < len ( lista ): elemento = lista [ i ] # Faz alguma coisa com o elemento i += 1 Com essa estrutura podemos, por exemplo, imprimir ou somar todos os elementos de uma lista. Nesses casos, a l\u00f3gica \u00e9 sempre parecida: executa alguma a\u00e7\u00e3o para cada elemento da lista . Na verdade esse tipo de procedimento \u00e9 t\u00e3o comum que existe uma maneira mais sucinta de fazer isso em Python: a repeti\u00e7\u00e3o for .","title":"Percorrendo listas com while"},{"location":"aulas/06-for/#a-repeticao-for","text":"O for percorre automaticamente todos os elementos em uma lista, caracteres em uma string, e outras estruturas que veremos no futuro: Ele se comporta de forma semelhante ao while se considerarmos que ele executa o bloco de c\u00f3digo m\u00faltiplas vezes, mas uma diferen\u00e7a importante \u00e9 que o for n\u00e3o possui condi\u00e7\u00e3o . Ele percorre todos os elementos e depois termina. Podemos ler o c\u00f3digo abaixo: como: Assim, podemos reescrever o c\u00f3digo a seguir: utilizando o for: Cada vez que o Python for executar o bloco dentro do for a vari\u00e1vel e ser\u00e1 automaticamente atualizada com o valor do pr\u00f3ximo elemento da lista.","title":"A repeti\u00e7\u00e3o for"},{"location":"aulas/06-for/#exercicio-1","text":"Fa\u00e7a o [TESTE DE MESA] Percorrendo uma lista com for .","title":"EXERC\u00cdCIO 1"},{"location":"aulas/06-for/#exercicio-2","text":"Quando utilizamos o for com uma string, o Python executa o bloco para cada caractere dessa string. Sabendo disso, fa\u00e7a o [TESTE DE MESA] Percorrendo uma string com for .","title":"EXERC\u00cdCIO 2"},{"location":"aulas/06-for/#o-range","text":"Outra estrat\u00e9gia bastante comum em programa\u00e7\u00e3o \u00e9 o uso de contadores para percorrer n\u00fameros em um intervalo. Executamos uma determinada opera\u00e7\u00e3o para o valor 0, depois para o valor 1, depois para o valor 2, e assim por diante. O Python possui uma fun\u00e7\u00e3o chamada range que gera essa sequ\u00eancia de n\u00fameros naturais. Existem 3 maneiras de utilizar o range : range com um argumento: os n\u00fameros gerados v\u00e3o desde o zero at\u00e9 o antes do argumento. Exemplo: range ( 3 ) gera a sequ\u00eancia 0 , 1 , 2 (note que o 3 n\u00e3o pertence \u00e0 sequ\u00eancia gerada); range com dois argumentos: os n\u00fameros gerados v\u00e3o desde o primeiro argument at\u00e9 antes do segundo argumento. Exemplo: range ( 13 , 17 ) gera a sequ\u00eancia 13 , 14 , 15 , 16 (note que o 13 pertence \u00e0 sequ\u00eancia, mas o 17 , n\u00e3o); range com tr\u00eas argumentos: os n\u00fameros gerados v\u00e3o desde o primeiro argument at\u00e9 antes do segundo argumento e o terceiro argumento \u00e9 o salto de um elemento gerado para o pr\u00f3ximo. Exemplo: range ( 2 , 13 , 3 ) gera a sequ\u00eancia 2 , 5 , 8 , 11 (note que o 2 pertence \u00e0 sequ\u00eancia, mas o pr\u00f3ximo elemento da sequ\u00eancia, o 14 , n\u00e3o).","title":"O range"},{"location":"aulas/06-for/#exercicio-3","text":"Fa\u00e7a o exerc\u00edcio [TESTE DE MESA] Percorrendo um range com for .","title":"EXERC\u00cdCIO 3"},{"location":"aulas/06-for/#exercicios-adicionais","text":"Refa\u00e7a os exerc\u00edcios a seguir utilizando for e, quando necess\u00e1rio range : 28. Soma dos 100 primeiros termos 36. Calcula fatorial 40. Soma valores da lista 46. N\u00famero igual ao \u00edndice 53. Soma dos n\u00famero \u00edmpares Para praticar mais, refa\u00e7a os outros exerc\u00edcios que resolveu com while agora utilizando o for . Importante Nem todos os exerc\u00edcios podem ser resolvidos com o for .","title":"EXERC\u00cdCIOS ADICIONAIS"},{"location":"aulas/07-dicionarios/","text":"07 - Dicion\u00e1rios \u00b6 O objetivo de aprendizado deste handout \u00e9 que, ao final da atividade, voc\u00ea seja capaz de utilizar dicion\u00e1rios em seus programas em conjunto com as estruturas que vimos nas aulas anteriores ( input , if , while , for , list , etc.). Vamos come\u00e7ar com um aquecimento. Exemplo com listas \u00b6 Analise o c\u00f3digo abaixo: lista = [[ \"Fulano\" , \"99999-1111\" ], [ \"Sicrano\" , \"99999-2222\" ], [ \"Beltrano\" , \"99999-3333\" ]] nome_selecionado = input ( \"Digite um nome: \" ) for nome_e_telefone in lista : nome = nome_e_telefone [ 0 ] if nome == nome_selecionado : telefone = nome_e_telefone [ 1 ] print ( \"Telefone de {0} \u00e9: {1} \" . format ( nome , telefone )) EXERC\u00cdCIO 1 \u00b6 Discuta o c\u00f3digo acima com um colega. Apresentem suas interpreta\u00e7\u00f5es e depois validem a compreens\u00e3o com a descri\u00e7\u00e3o a seguir: Abra apenas para validar a sua compreens\u00e3o Come\u00e7amos o c\u00f3digo criando uma lista na qual cada elemento \u00e9 uma outra lista contendo dois elementos. O primeiro desses elementos \u00e9 sempre um nome e o segundo \u00e9 sempre o seu respectivo telefone; O usu\u00e1rio digita um nome; Para cada elemento nome_e_telefone da lista repetimos o bloco a seguir (note que a vari\u00e1vel nome_e_telefone sempre vai guardar uma lista com exatamente dois elementos, o nome e o telefone): Armazenamos o primeiro elemento (o nome) de nome_e_telefone em uma vari\u00e1vel nome ; Se o nome for igual ao nome digitado pelo usu\u00e1rio executamos o bloco a seguir: Armazenamos o segundo elemento (o telefone) de nome_e_telefone em uma vari\u00e1vel telefone ; Imprimimos o telefone da pessoa selecionada Importante Mesmo depois de imprimir o telefone da pessoa selecionada, o c\u00f3digo continua percorrendo os pr\u00f3ximos elementos da lista at\u00e9 o fim. Acabamos de implementar uma lista de contatos! No c\u00f3digo acima, n\u00e3o seria mais f\u00e1cil se eu pudesse acessar elementos de uma lista utilizando palavras ao inv\u00e9s de n\u00fameros (\u00edndices)? Assim eu poderia acessar, por exemplo, o telefone de \"Fulano\" com o c\u00f3digo lista [ \"Fulano\" ] ao inv\u00e9s de ter que procurar por todos os elementos da lista. Para isso temos os dicion\u00e1rios! Dicion\u00e1rios \u00b6 Um dicion\u00e1rio pode armazenar uma quantidade arbitr\u00e1ria de elementos, assim como uma lista. A diferen\u00e7a \u00e9 que n\u00e3o estamos limitados a utilizar n\u00fameros como os \u00edndices, em dicion\u00e1rios podemos indexar os elementos por quase qualquer coisa (floats, strings, etc.)! No exemplo da lista de contatos, poder\u00edamos ter ao inv\u00e9s de uma lista de nomes e telefones indexados por n\u00fameros, uma lista de telefones indexada por nomes: O problema disso \u00e9 que na lista a posi\u00e7\u00e3o de cada elemento est\u00e1 claramente associada a um n\u00famero: o primeiro elemento da lista \u00e9 o 0, o segundo \u00e9 o 1, o terceiro \u00e9 o 2 e assim por diante. No dicion\u00e1rio essa associa\u00e7\u00e3o entre o \u00edndice (no exemplo, o nome) e a localiza\u00e7\u00e3o de um valor (o telefone) n\u00e3o \u00e9 igualmente clara. Independente da ordem dos elementos no dicion\u00e1rio queremos utilizar os nomes para acessar os telefones. Por isso, ao criar um dicion\u00e1rio precisamos ser expl\u00edcitos sobre qual \u00e9 o \"\u00edndice\" de cada valor adicionado. Fazemos isso utilizando o seguinte c\u00f3digo (ainda utilizando o exemplo acima): dicionario = { \"Fulano\" : \"99999-1111\" , \"Sicrano\" : \"99999-2222\" , \"Beltrano\" : \"99999-3333\" } A princ\u00edpio pode parecer um pouco assustador, mas n\u00e3o se preocupe, com um pouco de pr\u00e1tica voc\u00ea vai se acostumar. Vamos entender o que a linha acima est\u00e1 fazendo. Assim como definimos listas utilizando os colchetes [] , os dicion\u00e1rios s\u00e3o definidos com chaves {} . Ent\u00e3o definimos os pares de \"\u00edndice\" e valor do elemento separados por dois pontos (\" : \"). Chaves e valores \u00b6 Talvez voc\u00ea tenha reparado que utilizamos aspas quando nos refer\u00edamos aos \"\u00edndices\" do dicion\u00e1rio. Na verdade, no dicion\u00e1rio chamamos os \u00edndices de chaves (em ingl\u00eas: \" keys \") e os elementos armazenados de valores (em ingl\u00eas: \" values \"). Vimos tamb\u00e9m que as chaves e valores est\u00e3o associados. Esse par chave-valor \u00e9 chamado de item (em ingl\u00eas... tamb\u00e9m \u00e9 \" item \"). Por exemplo, em: idades = { 'Sicrano' : 18 , 'Beltrano' : 20 } As chaves s\u00e3o 'Sicrano' e 'Beltrano' , os valores s\u00e3o 18 e 20 e os itens s\u00e3o ( 'Sicrano' , 18 ) e ( 'Beltrano' , 20 ) . Acessando valores em um dicion\u00e1rio \u00b6 Vimos que podemos criar um dicion\u00e1rio colocando os pares de chaves e valores entre { e } . Para acessa um valor em uma determinada chave utilizamos o mesmo formato utilizado em listas. No nosso exemplo, dicionario [ 'Sicrano' ] devolve o valor armazenado na chave 'Sicrano' , ou seja, '99999-2222' . EXERC\u00cdCIO 2 \u00b6 Reescreva o c\u00f3digo da lista de contatos (no come\u00e7o do handout) para utilizar dicion\u00e1rios. Dica: o for n\u00e3o ser\u00e1 mais necess\u00e1rio. \u00c9 poss\u00edvel substitu\u00ed-lo por uma \u00fanica linha. EXERC\u00cdCIO 3 \u00b6 Uma poss\u00edvel solu\u00e7\u00e3o para o exerc\u00edcio 2 pode ser encontrada no [TESTE DE MESA] Lista de contatos . Fa\u00e7a esse teste de mesa para consolidar sua compreens\u00e3o. Inicializa\u00e7\u00e3o de dicion\u00e1rios \u00b6 J\u00e1 vimos que podemos criar um dicion\u00e1rio indicando a chave e o valor separados por dois pontos: precos = { 'chocolate' : 5.0 , 'suco' : 4.0 } E que podemos guardar qualquer coisa em dicion\u00e1rios, inclusive listas ou at\u00e9 outros dicion\u00e1rios: colecao = { 'Felipe' : [ 'brontossauro' , 'T-Rex' ], 'Julia' : [ 'Euro' , 'Dolar' , 'Bitcoin' ]} Podemos tamb\u00e9m criar dicion\u00e1rios vazios de maneira similar \u00e0s listas: dicionario_vazio = {} # Tamb\u00e9m podemos criar da seguinte maneira outro_dicionario_vazio = dict () Tem append ? \u00b6 Em uma lista temos que usar o m\u00e9todo . append () para colocar um elemento extra (criando uma posi\u00e7\u00e3o nova): minha_lista = [] minha_lista . append ( 42 ) Em um dicion\u00e1rio isso n\u00e3o \u00e9 necess\u00e1rio : basta colocar o novo elemento na nova posi\u00e7\u00e3o (como fazemos quando queremos substituir um elemento em uma lista): meu_dicionario = {} meu_dicionario [ 'vida universo e tudo mais' ] = 42 EXERC\u00cdCIO 4 \u00b6 Resolva o exerc\u00edcio 79. Lista para dicion\u00e1rio . Verificando se uma chave existe \u00b6 EXERC\u00cdCIO 5 \u00b6 Teste o programa a seguir ( se der um erro \u00e9 porque est\u00e1 certo ): port2eng = { 'couve' : 'kale' , 'repolho' : 'cabbage' , 'brocolis' : 'broccoli' } port = 'alface' eng = port2eng [ port ] print ( ' {0} em ingl\u00eas \u00e9 {1} ' . format ( port , eng )) O resultado esperado do programa acima \u00e9 o erro KeyError . Por qu\u00ea? A chave 'alface' n\u00e3o existe no dicion\u00e1rio, ent\u00e3o o dicion\u00e1rio n\u00e3o tem um valor para devolver. Por esse motivo \u00e9 importante verificarmos se uma chave existe no dicion\u00e1rio antes de tentar acessar seu valor. Para isso utilizamos o operador in : port2eng = { 'couve' : 'kale' , 'repolho' : 'cabbage' , 'brocolis' : 'broccoli' } port = 'alface' if port in port2eng : eng = port2eng [ port ] print ( ' {0} em ingl\u00eas \u00e9 {1} ' . format ( port , eng )) else : print ( 'A palavra {0} n\u00e3o existe no dicion\u00e1rio' . format ( port )) Nesse caso, o programa vai imprimir: A palavra alface n\u00e3o existe no dicion\u00e1rio . EXERC\u00cdCIO 6 \u00b6 Resolva o exerc\u00edcio 44. M\u00eas para n\u00famero . Mesmo se voc\u00ea j\u00e1 o tiver resolvido, resolva novamente utilizando um dicion\u00e1rio, sem while ou for . Percorrendo um dicion\u00e1rio \u00b6 Para percorrer os elementos de um dicion\u00e1rio vamos utilizar exclusivamente o for . Existem 3 maneiras de percorrer um dicion\u00e1rio utilizando o for . Para compreender as 3 maneiras, precisamos conhecer alguns m\u00e9todos dispon\u00edveis em dicion\u00e1rios: O m\u00e9todo . keys () (usado como dicionario . keys () ) devolve todas as chaves do dicion\u00e1rio; O m\u00e9todo . values () (usado como dicionario . values () ) devolve todos os valores do dicion\u00e1rio; O m\u00e9todo . items () (usado como dicionario . items () ) devolve todos os itens (pares chave-valor) do dicion\u00e1rio. Op\u00e7\u00e3o 1 \u00b6 A primeira op\u00e7\u00e3o para percorrer um dicion\u00e1rio utilizando for \u00e9: port2eng = { 'couve' : 'kale' , 'repolho' : 'cabbage' , 'brocolis' : 'broccoli' } for port in port2eng : eng = port2eng [ port ] print ( ' {0} \u00e9 {1} ' . format ( port , eng )) Nessa op\u00e7\u00e3o, o bloco do for \u00e9 executado para cada chave do dicion\u00e1rio . Se voc\u00ea precisar do valor associado a essa chave \u00e9 necess\u00e1rio acessar o valor no dicion\u00e1rio (primeira linha dentro do for ). Ela \u00e9 equivalente a: port2eng = { 'couve' : 'kale' , 'repolho' : 'cabbage' , 'brocolis' : 'broccoli' } for port in port2eng . keys (): eng = port2eng [ port ] print ( ' {0} \u00e9 {1} ' . format ( port , eng )) O . keys () \u00e9 redundante nesse caso, apresentamos a vers\u00e3o acima por completude. Voc\u00ea pode sempre usar a primeira vers\u00e3o (sem o . keys () ) sem preju\u00edzo. Op\u00e7\u00e3o 2 \u00b6 A segunda op\u00e7\u00e3o para percorrer um dicion\u00e1rio possui um resultado similar ao for com listas, ou seja, percorremos somente os valores: port2eng = { 'couve' : 'kale' , 'repolho' : 'cabbage' , 'brocolis' : 'broccoli' } for eng in port2eng . values (): print ( eng ) O programa acima vai imprimir kale , cabbage , broccoli (um em cada linha). Note que nessa op\u00e7\u00e3o n\u00e3o temos acesso \u00e0s chaves. Op\u00e7\u00e3o 3 \u00b6 Se voc\u00ea est\u00e1 interessado tanto nas chaves quando nos valores, \u00e9 poss\u00edvel percorrer a lista da seguinte maneira: port2eng = { 'couve' : 'kale' , 'repolho' : 'cabbage' , 'brocolis' : 'broccoli' } for port , eng in port2eng . items (): print ( ' {0} \u00e9 {1} ' . format ( port , eng )) As vari\u00e1veis port e eng ser\u00e3o inicializadas simultaneamente com a pr\u00f3xima chave e o pr\u00f3ximo valor do dicion\u00e1rio. Removendo um item do dicion\u00e1rio \u00b6 Assim como em listas, podemos remover um item utilizando o operador del : port2eng = { 'couve' : 'kale' , 'repolho' : 'cabbage' , 'brocolis' : 'broccoli' } del port2eng [ 'repolho' ] print ( port2eng ) # Vai imprimir {'couve': 'kale', 'brocolis': 'broccoli'} EXERC\u00cdCIOS ADICIONAIS \u00b6 Resolva os exerc\u00edcios dispon\u00edveis no servidor para praticar o uso de dicion\u00e1rios. Algumas sugest\u00f5es: 146. Conta ocorr\u00eancias de palavras 147. Palavra mais frequente 148. Conta ocorr\u00eancias de letras","title":"Handout"},{"location":"aulas/07-dicionarios/#07-dicionarios","text":"O objetivo de aprendizado deste handout \u00e9 que, ao final da atividade, voc\u00ea seja capaz de utilizar dicion\u00e1rios em seus programas em conjunto com as estruturas que vimos nas aulas anteriores ( input , if , while , for , list , etc.). Vamos come\u00e7ar com um aquecimento.","title":"07 - Dicion\u00e1rios"},{"location":"aulas/07-dicionarios/#exemplo-com-listas","text":"Analise o c\u00f3digo abaixo: lista = [[ \"Fulano\" , \"99999-1111\" ], [ \"Sicrano\" , \"99999-2222\" ], [ \"Beltrano\" , \"99999-3333\" ]] nome_selecionado = input ( \"Digite um nome: \" ) for nome_e_telefone in lista : nome = nome_e_telefone [ 0 ] if nome == nome_selecionado : telefone = nome_e_telefone [ 1 ] print ( \"Telefone de {0} \u00e9: {1} \" . format ( nome , telefone ))","title":"Exemplo com listas"},{"location":"aulas/07-dicionarios/#exercicio-1","text":"Discuta o c\u00f3digo acima com um colega. Apresentem suas interpreta\u00e7\u00f5es e depois validem a compreens\u00e3o com a descri\u00e7\u00e3o a seguir: Abra apenas para validar a sua compreens\u00e3o Come\u00e7amos o c\u00f3digo criando uma lista na qual cada elemento \u00e9 uma outra lista contendo dois elementos. O primeiro desses elementos \u00e9 sempre um nome e o segundo \u00e9 sempre o seu respectivo telefone; O usu\u00e1rio digita um nome; Para cada elemento nome_e_telefone da lista repetimos o bloco a seguir (note que a vari\u00e1vel nome_e_telefone sempre vai guardar uma lista com exatamente dois elementos, o nome e o telefone): Armazenamos o primeiro elemento (o nome) de nome_e_telefone em uma vari\u00e1vel nome ; Se o nome for igual ao nome digitado pelo usu\u00e1rio executamos o bloco a seguir: Armazenamos o segundo elemento (o telefone) de nome_e_telefone em uma vari\u00e1vel telefone ; Imprimimos o telefone da pessoa selecionada Importante Mesmo depois de imprimir o telefone da pessoa selecionada, o c\u00f3digo continua percorrendo os pr\u00f3ximos elementos da lista at\u00e9 o fim. Acabamos de implementar uma lista de contatos! No c\u00f3digo acima, n\u00e3o seria mais f\u00e1cil se eu pudesse acessar elementos de uma lista utilizando palavras ao inv\u00e9s de n\u00fameros (\u00edndices)? Assim eu poderia acessar, por exemplo, o telefone de \"Fulano\" com o c\u00f3digo lista [ \"Fulano\" ] ao inv\u00e9s de ter que procurar por todos os elementos da lista. Para isso temos os dicion\u00e1rios!","title":"EXERC\u00cdCIO 1"},{"location":"aulas/07-dicionarios/#dicionarios","text":"Um dicion\u00e1rio pode armazenar uma quantidade arbitr\u00e1ria de elementos, assim como uma lista. A diferen\u00e7a \u00e9 que n\u00e3o estamos limitados a utilizar n\u00fameros como os \u00edndices, em dicion\u00e1rios podemos indexar os elementos por quase qualquer coisa (floats, strings, etc.)! No exemplo da lista de contatos, poder\u00edamos ter ao inv\u00e9s de uma lista de nomes e telefones indexados por n\u00fameros, uma lista de telefones indexada por nomes: O problema disso \u00e9 que na lista a posi\u00e7\u00e3o de cada elemento est\u00e1 claramente associada a um n\u00famero: o primeiro elemento da lista \u00e9 o 0, o segundo \u00e9 o 1, o terceiro \u00e9 o 2 e assim por diante. No dicion\u00e1rio essa associa\u00e7\u00e3o entre o \u00edndice (no exemplo, o nome) e a localiza\u00e7\u00e3o de um valor (o telefone) n\u00e3o \u00e9 igualmente clara. Independente da ordem dos elementos no dicion\u00e1rio queremos utilizar os nomes para acessar os telefones. Por isso, ao criar um dicion\u00e1rio precisamos ser expl\u00edcitos sobre qual \u00e9 o \"\u00edndice\" de cada valor adicionado. Fazemos isso utilizando o seguinte c\u00f3digo (ainda utilizando o exemplo acima): dicionario = { \"Fulano\" : \"99999-1111\" , \"Sicrano\" : \"99999-2222\" , \"Beltrano\" : \"99999-3333\" } A princ\u00edpio pode parecer um pouco assustador, mas n\u00e3o se preocupe, com um pouco de pr\u00e1tica voc\u00ea vai se acostumar. Vamos entender o que a linha acima est\u00e1 fazendo. Assim como definimos listas utilizando os colchetes [] , os dicion\u00e1rios s\u00e3o definidos com chaves {} . Ent\u00e3o definimos os pares de \"\u00edndice\" e valor do elemento separados por dois pontos (\" : \").","title":"Dicion\u00e1rios"},{"location":"aulas/07-dicionarios/#chaves-e-valores","text":"Talvez voc\u00ea tenha reparado que utilizamos aspas quando nos refer\u00edamos aos \"\u00edndices\" do dicion\u00e1rio. Na verdade, no dicion\u00e1rio chamamos os \u00edndices de chaves (em ingl\u00eas: \" keys \") e os elementos armazenados de valores (em ingl\u00eas: \" values \"). Vimos tamb\u00e9m que as chaves e valores est\u00e3o associados. Esse par chave-valor \u00e9 chamado de item (em ingl\u00eas... tamb\u00e9m \u00e9 \" item \"). Por exemplo, em: idades = { 'Sicrano' : 18 , 'Beltrano' : 20 } As chaves s\u00e3o 'Sicrano' e 'Beltrano' , os valores s\u00e3o 18 e 20 e os itens s\u00e3o ( 'Sicrano' , 18 ) e ( 'Beltrano' , 20 ) .","title":"Chaves e valores"},{"location":"aulas/07-dicionarios/#acessando-valores-em-um-dicionario","text":"Vimos que podemos criar um dicion\u00e1rio colocando os pares de chaves e valores entre { e } . Para acessa um valor em uma determinada chave utilizamos o mesmo formato utilizado em listas. No nosso exemplo, dicionario [ 'Sicrano' ] devolve o valor armazenado na chave 'Sicrano' , ou seja, '99999-2222' .","title":"Acessando valores em um dicion\u00e1rio"},{"location":"aulas/07-dicionarios/#exercicio-2","text":"Reescreva o c\u00f3digo da lista de contatos (no come\u00e7o do handout) para utilizar dicion\u00e1rios. Dica: o for n\u00e3o ser\u00e1 mais necess\u00e1rio. \u00c9 poss\u00edvel substitu\u00ed-lo por uma \u00fanica linha.","title":"EXERC\u00cdCIO 2"},{"location":"aulas/07-dicionarios/#exercicio-3","text":"Uma poss\u00edvel solu\u00e7\u00e3o para o exerc\u00edcio 2 pode ser encontrada no [TESTE DE MESA] Lista de contatos . Fa\u00e7a esse teste de mesa para consolidar sua compreens\u00e3o.","title":"EXERC\u00cdCIO 3"},{"location":"aulas/07-dicionarios/#inicializacao-de-dicionarios","text":"J\u00e1 vimos que podemos criar um dicion\u00e1rio indicando a chave e o valor separados por dois pontos: precos = { 'chocolate' : 5.0 , 'suco' : 4.0 } E que podemos guardar qualquer coisa em dicion\u00e1rios, inclusive listas ou at\u00e9 outros dicion\u00e1rios: colecao = { 'Felipe' : [ 'brontossauro' , 'T-Rex' ], 'Julia' : [ 'Euro' , 'Dolar' , 'Bitcoin' ]} Podemos tamb\u00e9m criar dicion\u00e1rios vazios de maneira similar \u00e0s listas: dicionario_vazio = {} # Tamb\u00e9m podemos criar da seguinte maneira outro_dicionario_vazio = dict ()","title":"Inicializa\u00e7\u00e3o de dicion\u00e1rios"},{"location":"aulas/07-dicionarios/#tem-append","text":"Em uma lista temos que usar o m\u00e9todo . append () para colocar um elemento extra (criando uma posi\u00e7\u00e3o nova): minha_lista = [] minha_lista . append ( 42 ) Em um dicion\u00e1rio isso n\u00e3o \u00e9 necess\u00e1rio : basta colocar o novo elemento na nova posi\u00e7\u00e3o (como fazemos quando queremos substituir um elemento em uma lista): meu_dicionario = {} meu_dicionario [ 'vida universo e tudo mais' ] = 42","title":"Tem append?"},{"location":"aulas/07-dicionarios/#exercicio-4","text":"Resolva o exerc\u00edcio 79. Lista para dicion\u00e1rio .","title":"EXERC\u00cdCIO 4"},{"location":"aulas/07-dicionarios/#verificando-se-uma-chave-existe","text":"","title":"Verificando se uma chave existe"},{"location":"aulas/07-dicionarios/#exercicio-5","text":"Teste o programa a seguir ( se der um erro \u00e9 porque est\u00e1 certo ): port2eng = { 'couve' : 'kale' , 'repolho' : 'cabbage' , 'brocolis' : 'broccoli' } port = 'alface' eng = port2eng [ port ] print ( ' {0} em ingl\u00eas \u00e9 {1} ' . format ( port , eng )) O resultado esperado do programa acima \u00e9 o erro KeyError . Por qu\u00ea? A chave 'alface' n\u00e3o existe no dicion\u00e1rio, ent\u00e3o o dicion\u00e1rio n\u00e3o tem um valor para devolver. Por esse motivo \u00e9 importante verificarmos se uma chave existe no dicion\u00e1rio antes de tentar acessar seu valor. Para isso utilizamos o operador in : port2eng = { 'couve' : 'kale' , 'repolho' : 'cabbage' , 'brocolis' : 'broccoli' } port = 'alface' if port in port2eng : eng = port2eng [ port ] print ( ' {0} em ingl\u00eas \u00e9 {1} ' . format ( port , eng )) else : print ( 'A palavra {0} n\u00e3o existe no dicion\u00e1rio' . format ( port )) Nesse caso, o programa vai imprimir: A palavra alface n\u00e3o existe no dicion\u00e1rio .","title":"EXERC\u00cdCIO 5"},{"location":"aulas/07-dicionarios/#exercicio-6","text":"Resolva o exerc\u00edcio 44. M\u00eas para n\u00famero . Mesmo se voc\u00ea j\u00e1 o tiver resolvido, resolva novamente utilizando um dicion\u00e1rio, sem while ou for .","title":"EXERC\u00cdCIO 6"},{"location":"aulas/07-dicionarios/#percorrendo-um-dicionario","text":"Para percorrer os elementos de um dicion\u00e1rio vamos utilizar exclusivamente o for . Existem 3 maneiras de percorrer um dicion\u00e1rio utilizando o for . Para compreender as 3 maneiras, precisamos conhecer alguns m\u00e9todos dispon\u00edveis em dicion\u00e1rios: O m\u00e9todo . keys () (usado como dicionario . keys () ) devolve todas as chaves do dicion\u00e1rio; O m\u00e9todo . values () (usado como dicionario . values () ) devolve todos os valores do dicion\u00e1rio; O m\u00e9todo . items () (usado como dicionario . items () ) devolve todos os itens (pares chave-valor) do dicion\u00e1rio.","title":"Percorrendo um dicion\u00e1rio"},{"location":"aulas/07-dicionarios/#opcao-1","text":"A primeira op\u00e7\u00e3o para percorrer um dicion\u00e1rio utilizando for \u00e9: port2eng = { 'couve' : 'kale' , 'repolho' : 'cabbage' , 'brocolis' : 'broccoli' } for port in port2eng : eng = port2eng [ port ] print ( ' {0} \u00e9 {1} ' . format ( port , eng )) Nessa op\u00e7\u00e3o, o bloco do for \u00e9 executado para cada chave do dicion\u00e1rio . Se voc\u00ea precisar do valor associado a essa chave \u00e9 necess\u00e1rio acessar o valor no dicion\u00e1rio (primeira linha dentro do for ). Ela \u00e9 equivalente a: port2eng = { 'couve' : 'kale' , 'repolho' : 'cabbage' , 'brocolis' : 'broccoli' } for port in port2eng . keys (): eng = port2eng [ port ] print ( ' {0} \u00e9 {1} ' . format ( port , eng )) O . keys () \u00e9 redundante nesse caso, apresentamos a vers\u00e3o acima por completude. Voc\u00ea pode sempre usar a primeira vers\u00e3o (sem o . keys () ) sem preju\u00edzo.","title":"Op\u00e7\u00e3o 1"},{"location":"aulas/07-dicionarios/#opcao-2","text":"A segunda op\u00e7\u00e3o para percorrer um dicion\u00e1rio possui um resultado similar ao for com listas, ou seja, percorremos somente os valores: port2eng = { 'couve' : 'kale' , 'repolho' : 'cabbage' , 'brocolis' : 'broccoli' } for eng in port2eng . values (): print ( eng ) O programa acima vai imprimir kale , cabbage , broccoli (um em cada linha). Note que nessa op\u00e7\u00e3o n\u00e3o temos acesso \u00e0s chaves.","title":"Op\u00e7\u00e3o 2"},{"location":"aulas/07-dicionarios/#opcao-3","text":"Se voc\u00ea est\u00e1 interessado tanto nas chaves quando nos valores, \u00e9 poss\u00edvel percorrer a lista da seguinte maneira: port2eng = { 'couve' : 'kale' , 'repolho' : 'cabbage' , 'brocolis' : 'broccoli' } for port , eng in port2eng . items (): print ( ' {0} \u00e9 {1} ' . format ( port , eng )) As vari\u00e1veis port e eng ser\u00e3o inicializadas simultaneamente com a pr\u00f3xima chave e o pr\u00f3ximo valor do dicion\u00e1rio.","title":"Op\u00e7\u00e3o 3"},{"location":"aulas/07-dicionarios/#removendo-um-item-do-dicionario","text":"Assim como em listas, podemos remover um item utilizando o operador del : port2eng = { 'couve' : 'kale' , 'repolho' : 'cabbage' , 'brocolis' : 'broccoli' } del port2eng [ 'repolho' ] print ( port2eng ) # Vai imprimir {'couve': 'kale', 'brocolis': 'broccoli'}","title":"Removendo um item do dicion\u00e1rio"},{"location":"aulas/07-dicionarios/#exercicios-adicionais","text":"Resolva os exerc\u00edcios dispon\u00edveis no servidor para praticar o uso de dicion\u00e1rios. Algumas sugest\u00f5es: 146. Conta ocorr\u00eancias de palavras 147. Palavra mais frequente 148. Conta ocorr\u00eancias de letras","title":"EXERC\u00cdCIOS ADICIONAIS"},{"location":"aulas/08-strings/","text":"08 - Strings e Fatiamento \u00b6 Trabalhamos com strings desde a primeira aula, quando aprendemos a mostrar um texto na tela usando o print . Hoje j\u00e1 sabemos fazer muito mais do que s\u00f3 mostrar um texto na tela! Ao final deste handout, o objetivo \u00e9 que voc\u00ea seja capaz de utilizar opera\u00e7\u00f5es comuns em strings, como encontrar e substituir substrings, limpar espa\u00e7os em branco e obter fatias ( slicing ) de uma string ou lista. Veremos que strings s\u00e3o muito parecidos com listas em diversos aspectos. O primeiro deles \u00e9 que assim como em uma lista, os caracteres de uma string tamb\u00e9m podem ser acessados por \u00edndices: EXERC\u00cdCIO 1 \u00b6 Fa\u00e7a o [TESTE DE MESA] Imprimindo caracteres de uma string . EXERC\u00cdCIO 2 \u00b6 Fa\u00e7a o Exerc\u00edcio 58. Conta ocorr\u00eancias de a . M\u00e9todos de uma string \u00b6 O que s\u00e3o m\u00e9todos? \u00b6 Quando trabalhamos com listas sabemos que \u00e9 poss\u00edvel usar o . append () para adicionar um elemento. O Python sabe em qual lista ele deve adicionar o novo elemento porque o . append () \u00e9 sempre precedido pelo nome da lista. Por exemplo: lista1 = [ 1 , 2 , 3 , 4 ] lista2 = [ 9 , 8 , 7 , 6 ] lista1 . append ( 5 ) O n\u00famero 5 ser\u00e1 adicionado \u00e0 lista1 , pois o append ( 5 ) est\u00e1 associado a ela atrav\u00e9s do ponto ( . ). Esse tipo especial de fun\u00e7\u00f5es \u00e9 o que chamamos de m\u00e9todo (lembre-se que normalmente os argumentos de uma fun\u00e7\u00e3o s\u00e3o passados dentro dos par\u00eanteses). Por enquanto isso \u00e9 tudo o que precisamos saber sobre um m\u00e9todo: \u00e9 uma fun\u00e7\u00e3o especial que est\u00e1 associada a um objeto (no caso uma lista) espec\u00edfico. Trabalharemos um pouco mais com m\u00e9todos durante o projeto final de Design de Software. Para aqueles que forem seguir em Engenharia de Computa\u00e7\u00e3o, o conceito de m\u00e9todo ser\u00e1 apresentado mais formalmente na disciplina Desenvolvimento Colaborativo \u00c1gil. Alguns m\u00e9todos de strings \u00b6 Vimos em aulas anteriores que \u00e9 poss\u00edvel criar uma nova string a partir de outras duas strings usando o + : 'abcd' + 'efgh' vai gerar a string 'abcdefgh' . Assim, n\u00e3o precisamos do . append () (de fato, ele nem funciona para strings). Mas existem diversos m\u00e9todos espec\u00edficos de strings que podem ser bastante \u00fateis. Uma lista completa pode ser encontrada na documenta\u00e7\u00e3o , mas vamos focar em alguns m\u00e9todos principais: find : m\u00e9todo que retorna a posi\u00e7\u00e3o da primeira ocorr\u00eancia de uma dada string em outra. Se n\u00e3o encontrou, retorna -1. Por exemplo: 'abcde' . find ( 'c' ) devolve o n\u00famero 2 . replace : m\u00e9todo que recebe duas strings e retorna uma nova string com todas as ocorr\u00eancias da primeira substitu\u00eddas pela segunda. Por exemplo: 'abcba' . replace ( 'b' , 'd' ) devolve a string 'adcda' . strip : m\u00e9todo que n\u00e3o recebe nenhum argumento e retorna uma nova string removendo os caracteres em branco (incluindo o caractere especial ' \\n ' ) de ambas as pontas. Por exemplo: ' uma frase \\n ' . strip () devolve a string 'uma frase' (note que o espa\u00e7o do meio n\u00e3o \u00e9 removido). split : m\u00e9todo que recebe uma string delimitadora (ex: ',' ) e retorna uma lista formada pela separa\u00e7\u00e3o da string original pelo delimitador. Por exemplo: 'uma palavra, outra palavra, \u00faltima palavra' . split ( ',' ) devolve a lista [ 'uma palavra' , ' outra palavra' , ' \u00faltima palavra' ] . Se nenhum argumento for utilizado o delimitador utilizado ser\u00e1 o espa\u00e7o em branco. Por exemplo: 'palavras separadas por espa\u00e7o' . split () devolve a lista de strings [ 'palavras' , 'separadas' , 'por' , 'espa\u00e7o' ] . join : m\u00e9todo que recebe uma lista de strings e retorna uma \u00fanica string separada pelo delimitador. Por exemplo: ' ' . join ([ 'a' , 'b' , 'c' ]) devolve a string 'a b c' . Outro exemplo: ',' . join ([ 'a' , 'b' , 'c' ]) devolve a string 'a,b,c' . EXERC\u00cdCIO 3 \u00b6 Fa\u00e7a o [TESTE DE MESA] M\u00e9todos de strings . Extraindo substrings com fatiamento \u00b6 A opera\u00e7\u00e3o de fatiamento permite realizarmos um recorte da string. A sintaxe \u00e9 semelhante ao acesso a um caractere usando o \u00edndice, mas ao inv\u00e9s de um n\u00famero n\u00f3s passamos um intervalo: A sem\u00e2ntica \u00e9 semelhante ao range : o fatiamento inclui o primeiro \u00edndice e n\u00e3o inclui o segundo. Assim, no exemplo acima, o fatiamento s [ 2 : 4 ] inclui o \u00edndice 2 , mas n\u00e3o inclui o 4 . Portanto apenas os caracteres nos \u00edndices 2 e 3 est\u00e3o presentes no resultado do fatiamento. Alternativamente, podemos omitir um (ou ambos) dos \u00edndices: Assim como no range, podemos passar um terceiro argumento opcional para um fatiamento. Esse terceiro argumento indica o tamanho do pulo, ou seja, de quanto em quanto o \u00edndice deve ser aumentado (por padr\u00e3o ele aumenta de 1 em 1). Por exemplo, 'abcdefghij' [ 0 : 10 : 2 ] vai retornar uma nova string do \u00edndice 0 ao 9 pulando de 2 em 2, ou seja, a string 'acegi' . Al\u00e9m do fatiamento, pode ser \u00fatil usarmos \u00edndices negativos. Os \u00edndices negativos tem um efeito semelhante aos \u00edndices positivos, mas v\u00e3o do final para o come\u00e7o. Por exemplo, o \u00edndice - 1 \u00e9 o \u00faltimo elemento, o \u00edndice - 2 \u00e9 o pen\u00faltimo elemento, o \u00edndice - 3 \u00e9 o antepen\u00faltimo elemento, e assim por diante. No exemplo acima apresentamos uma t\u00e9cnica bastante utilizada para inverter uma string, que \u00e9 o uso do fatiamento [:: - 1 ] . Ele pode ser \u00fatil em alguns exerc\u00edcios do servidor. EXERC\u00cdCIO 4 \u00b6 Fa\u00e7a o [TESTE DE MESA] Fatiamento de strings . EXERC\u00cdCIO 5 \u00b6 Fa\u00e7a o Exerc\u00edcio 60. Verifica pal\u00edndromo . Fatiamento em listas \u00b6 Dissemos no come\u00e7o do handout que existem muitas semelhan\u00e7as entre listas e strings em Python. Uma delas \u00e9 que tamb\u00e9m \u00e9 poss\u00edvel realizar fatiamentos de listas, da mesma maneira como fizemos com strings. EXERC\u00cdCIO 6 \u00b6 Fa\u00e7a o [TESTE DE MESA] Fatiamento de listas . EXERC\u00cdCIOS ADICIONAIS \u00b6 62. Posi\u00e7\u00e3o do @ 63. Nome do usu\u00e1rio 66. Listando todos os sufixos de uma string 67. Lista alunos \u00edmpares 68. Forma trios","title":"Handout"},{"location":"aulas/08-strings/#08-strings-e-fatiamento","text":"Trabalhamos com strings desde a primeira aula, quando aprendemos a mostrar um texto na tela usando o print . Hoje j\u00e1 sabemos fazer muito mais do que s\u00f3 mostrar um texto na tela! Ao final deste handout, o objetivo \u00e9 que voc\u00ea seja capaz de utilizar opera\u00e7\u00f5es comuns em strings, como encontrar e substituir substrings, limpar espa\u00e7os em branco e obter fatias ( slicing ) de uma string ou lista. Veremos que strings s\u00e3o muito parecidos com listas em diversos aspectos. O primeiro deles \u00e9 que assim como em uma lista, os caracteres de uma string tamb\u00e9m podem ser acessados por \u00edndices:","title":"08 - Strings e Fatiamento"},{"location":"aulas/08-strings/#exercicio-1","text":"Fa\u00e7a o [TESTE DE MESA] Imprimindo caracteres de uma string .","title":"EXERC\u00cdCIO 1"},{"location":"aulas/08-strings/#exercicio-2","text":"Fa\u00e7a o Exerc\u00edcio 58. Conta ocorr\u00eancias de a .","title":"EXERC\u00cdCIO 2"},{"location":"aulas/08-strings/#metodos-de-uma-string","text":"","title":"M\u00e9todos de uma string"},{"location":"aulas/08-strings/#o-que-sao-metodos","text":"Quando trabalhamos com listas sabemos que \u00e9 poss\u00edvel usar o . append () para adicionar um elemento. O Python sabe em qual lista ele deve adicionar o novo elemento porque o . append () \u00e9 sempre precedido pelo nome da lista. Por exemplo: lista1 = [ 1 , 2 , 3 , 4 ] lista2 = [ 9 , 8 , 7 , 6 ] lista1 . append ( 5 ) O n\u00famero 5 ser\u00e1 adicionado \u00e0 lista1 , pois o append ( 5 ) est\u00e1 associado a ela atrav\u00e9s do ponto ( . ). Esse tipo especial de fun\u00e7\u00f5es \u00e9 o que chamamos de m\u00e9todo (lembre-se que normalmente os argumentos de uma fun\u00e7\u00e3o s\u00e3o passados dentro dos par\u00eanteses). Por enquanto isso \u00e9 tudo o que precisamos saber sobre um m\u00e9todo: \u00e9 uma fun\u00e7\u00e3o especial que est\u00e1 associada a um objeto (no caso uma lista) espec\u00edfico. Trabalharemos um pouco mais com m\u00e9todos durante o projeto final de Design de Software. Para aqueles que forem seguir em Engenharia de Computa\u00e7\u00e3o, o conceito de m\u00e9todo ser\u00e1 apresentado mais formalmente na disciplina Desenvolvimento Colaborativo \u00c1gil.","title":"O que s\u00e3o m\u00e9todos?"},{"location":"aulas/08-strings/#alguns-metodos-de-strings","text":"Vimos em aulas anteriores que \u00e9 poss\u00edvel criar uma nova string a partir de outras duas strings usando o + : 'abcd' + 'efgh' vai gerar a string 'abcdefgh' . Assim, n\u00e3o precisamos do . append () (de fato, ele nem funciona para strings). Mas existem diversos m\u00e9todos espec\u00edficos de strings que podem ser bastante \u00fateis. Uma lista completa pode ser encontrada na documenta\u00e7\u00e3o , mas vamos focar em alguns m\u00e9todos principais: find : m\u00e9todo que retorna a posi\u00e7\u00e3o da primeira ocorr\u00eancia de uma dada string em outra. Se n\u00e3o encontrou, retorna -1. Por exemplo: 'abcde' . find ( 'c' ) devolve o n\u00famero 2 . replace : m\u00e9todo que recebe duas strings e retorna uma nova string com todas as ocorr\u00eancias da primeira substitu\u00eddas pela segunda. Por exemplo: 'abcba' . replace ( 'b' , 'd' ) devolve a string 'adcda' . strip : m\u00e9todo que n\u00e3o recebe nenhum argumento e retorna uma nova string removendo os caracteres em branco (incluindo o caractere especial ' \\n ' ) de ambas as pontas. Por exemplo: ' uma frase \\n ' . strip () devolve a string 'uma frase' (note que o espa\u00e7o do meio n\u00e3o \u00e9 removido). split : m\u00e9todo que recebe uma string delimitadora (ex: ',' ) e retorna uma lista formada pela separa\u00e7\u00e3o da string original pelo delimitador. Por exemplo: 'uma palavra, outra palavra, \u00faltima palavra' . split ( ',' ) devolve a lista [ 'uma palavra' , ' outra palavra' , ' \u00faltima palavra' ] . Se nenhum argumento for utilizado o delimitador utilizado ser\u00e1 o espa\u00e7o em branco. Por exemplo: 'palavras separadas por espa\u00e7o' . split () devolve a lista de strings [ 'palavras' , 'separadas' , 'por' , 'espa\u00e7o' ] . join : m\u00e9todo que recebe uma lista de strings e retorna uma \u00fanica string separada pelo delimitador. Por exemplo: ' ' . join ([ 'a' , 'b' , 'c' ]) devolve a string 'a b c' . Outro exemplo: ',' . join ([ 'a' , 'b' , 'c' ]) devolve a string 'a,b,c' .","title":"Alguns m\u00e9todos de strings"},{"location":"aulas/08-strings/#exercicio-3","text":"Fa\u00e7a o [TESTE DE MESA] M\u00e9todos de strings .","title":"EXERC\u00cdCIO 3"},{"location":"aulas/08-strings/#extraindo-substrings-com-fatiamento","text":"A opera\u00e7\u00e3o de fatiamento permite realizarmos um recorte da string. A sintaxe \u00e9 semelhante ao acesso a um caractere usando o \u00edndice, mas ao inv\u00e9s de um n\u00famero n\u00f3s passamos um intervalo: A sem\u00e2ntica \u00e9 semelhante ao range : o fatiamento inclui o primeiro \u00edndice e n\u00e3o inclui o segundo. Assim, no exemplo acima, o fatiamento s [ 2 : 4 ] inclui o \u00edndice 2 , mas n\u00e3o inclui o 4 . Portanto apenas os caracteres nos \u00edndices 2 e 3 est\u00e3o presentes no resultado do fatiamento. Alternativamente, podemos omitir um (ou ambos) dos \u00edndices: Assim como no range, podemos passar um terceiro argumento opcional para um fatiamento. Esse terceiro argumento indica o tamanho do pulo, ou seja, de quanto em quanto o \u00edndice deve ser aumentado (por padr\u00e3o ele aumenta de 1 em 1). Por exemplo, 'abcdefghij' [ 0 : 10 : 2 ] vai retornar uma nova string do \u00edndice 0 ao 9 pulando de 2 em 2, ou seja, a string 'acegi' . Al\u00e9m do fatiamento, pode ser \u00fatil usarmos \u00edndices negativos. Os \u00edndices negativos tem um efeito semelhante aos \u00edndices positivos, mas v\u00e3o do final para o come\u00e7o. Por exemplo, o \u00edndice - 1 \u00e9 o \u00faltimo elemento, o \u00edndice - 2 \u00e9 o pen\u00faltimo elemento, o \u00edndice - 3 \u00e9 o antepen\u00faltimo elemento, e assim por diante. No exemplo acima apresentamos uma t\u00e9cnica bastante utilizada para inverter uma string, que \u00e9 o uso do fatiamento [:: - 1 ] . Ele pode ser \u00fatil em alguns exerc\u00edcios do servidor.","title":"Extraindo substrings com fatiamento"},{"location":"aulas/08-strings/#exercicio-4","text":"Fa\u00e7a o [TESTE DE MESA] Fatiamento de strings .","title":"EXERC\u00cdCIO 4"},{"location":"aulas/08-strings/#exercicio-5","text":"Fa\u00e7a o Exerc\u00edcio 60. Verifica pal\u00edndromo .","title":"EXERC\u00cdCIO 5"},{"location":"aulas/08-strings/#fatiamento-em-listas","text":"Dissemos no come\u00e7o do handout que existem muitas semelhan\u00e7as entre listas e strings em Python. Uma delas \u00e9 que tamb\u00e9m \u00e9 poss\u00edvel realizar fatiamentos de listas, da mesma maneira como fizemos com strings.","title":"Fatiamento em listas"},{"location":"aulas/08-strings/#exercicio-6","text":"Fa\u00e7a o [TESTE DE MESA] Fatiamento de listas .","title":"EXERC\u00cdCIO 6"},{"location":"aulas/08-strings/#exercicios-adicionais","text":"62. Posi\u00e7\u00e3o do @ 63. Nome do usu\u00e1rio 66. Listando todos os sufixos de uma string 67. Lista alunos \u00edmpares 68. Forma trios","title":"EXERC\u00cdCIOS ADICIONAIS"},{"location":"aulas/09-arquivos/","text":"09 - Arquivos \u00b6 Nossos programas at\u00e9 o momento utilizam dados fornecidos pelo usu\u00e1rio ou obtidos a partir de algum c\u00e1lculo, mas esses dados s\u00e3o perdidos assim que o programa acaba. Arquivos s\u00e3o estruturas de dados que normalmente s\u00e3o armazenados em dispositivos secund\u00e1rios de mem\u00f3ria. Esses dispositivos secund\u00e1rios de mem\u00f3ria permitem o armazenamento permanente dos dados, ou seja, mesmo depois que o programa acaba ou at\u00e9 depois que o computador \u00e9 reiniciado, os dados continuam existindo. Os principais dispositivos de armazenamento atualmente s\u00e3o: Disco R\u00edgido (HD) Solid-State Drive (SSD) Pen Drives Os arquivos armazenados nestes dispositivos possuem sempre uma identifica\u00e7\u00e3o (nome) e sua localiza\u00e7\u00e3o (normalmente em uma estrutura hier\u00e1rquica de diret\u00f3rios). Outros atributos como data e permiss\u00f5es de acesso tamb\u00e9m s\u00e3o normalmente usados no \u00edndice. Acessando arquivos \u00b6 Arquivos s\u00e3o lidos como uma sequ\u00eancia de bytes. Um byte \u00e9 um conjunto de 8 bits ( BI nary digi T ), que s\u00e3o valores do tipo 0 ou 1. Bytes por si s\u00f3 n\u00e3o possuem significado nenhum, s\u00e3o simplesmente uma sequ\u00eancia de 0s e 1s. \u00c9 necess\u00e1rio que um programa seja capaz de entender essa sequ\u00eancia de bytes do arquivo para extrair alguma informa\u00e7\u00e3o. Existem basicamente dois tipos de arquivos: Arquivos de texto : os bytes representam caracteres. Por exemplo, os arquivos . py que criamos com o nosso c\u00f3digo Python s\u00e3o arquivos de texto. Cada caractere do nosso c\u00f3digo Python (incluindo espa\u00e7os e pula linha) \u00e9 representado por um byte e armazenado no nosso HD ou SSD. Arquivos bin\u00e1rios : cada byte pode ter um significado diferente. Por exemplo, em imagens \u00e9 comum usar bytes para representar cores. No exemplo abaixo, os bytes do arquivo (\u00e0 direita) s\u00e3o interpretados por um programa que \u00e9 capaz de mostrar o resultado como uma imagem (\u00e0 esquerda) Neste handout vamos aprender a trabalhar com arquivos em Python. Ao final do handout voc\u00ea deve ser capaz de abrir um arquivo para (1) ler os dados armazenados; ou (2) escrever dados. Arquivos em Python \u00b6 Antes de utilizar qualquer arquivo \u00e9 necess\u00e1rio abri-lo. Para isso, existe a fun\u00e7\u00e3o open () , que recebe pelo menos dois argumentos: a localiza\u00e7\u00e3o do arquivo e o modo de abertura. Depois de utilizar o arquivo \u00e9 muito importante lembrar de fech\u00e1-lo. Muitos problemas podem acontecer se voc\u00ea esquecer de fechar o programa . Para isso devemos usar a fun\u00e7\u00e3o close () : # Modo tradicional de ler um arquivo arquivo = open ( 'arquivo_texto.txt' , 'r' ) conteudo = arquivo . read () arquivo . close () # O que acontece se n\u00e3o fechar? # Imprime o conte\u00fado print ( conteudo ) O programa acima abre um arquivo chamado arquivo_texto . txt para leitura ( importante : ele deve existir na mesma pasta onde voc\u00ea est\u00e1 executando o seu programa), armazena o conte\u00fado na vari\u00e1vel conteudo , fecha o arquivo e depois imprime todo o conte\u00fado do arquivo. Info Os testes deste handout utilizam arquivos externos. Por esse motivo, n\u00e3o faz muito sentido fazermos testes de mesa no servidor. A melhor maneira de entender o que o programa est\u00e1 fazendo \u00e9 execut\u00e1-lo no pr\u00f3prio computador para observar as mudan\u00e7as nos outros arquivos. Assim, neste handout n\u00e3o teremos testes de mesa do servidor. Fa\u00e7a todos os testes no seu pr\u00f3prio computador. EXERC\u00cdCIO 1 \u00b6 Teste o programa acima no seu computador. Para isso, crie um arquivo chamado arquivo_texto . txt e escreva alguma coisa (pode ser no Spyder, VS Code, ou qualquer editor de texto de sua prefer\u00eancia - n\u00e3o use o Word, pois ele gera um arquivo muito mais complicado ). Salve o programa acima na mesma pasta . Execute seu programa. Ele deve imprimir no terminal o conte\u00fado do seu arquivo. Caminho ( path ) do arquivo Quando estamos trabalhando com arquivos \u00e9 comum obtermos o erro FileNotFoundError . Ele ocorre quando tentamos abrir ( open () ) um arquivo que n\u00e3o existe. \u00c9 importante que o arquivo que voc\u00ea est\u00e1 tentando abrir esteja na mesma pasta que cont\u00e9m o seu programa. \u00c9 poss\u00edvel abrir arquivos localizados em outras pastas do seu computador, mas nesse caso \u00e9 necess\u00e1rio especificar o caminho do arquivo, ou seja, qual \u00e9 a sequ\u00eancia de pastas que devem ser percorridas para se localizar esse arquivo. Abrindo arquivos com o with \u00b6 Como dissemos anteriormente, \u00e9 muito importante se lembrar de fechar o arquivo depois de utiliz\u00e1-lo. Na verdade, isso \u00e9 t\u00e3o importante que existe uma maneira de escrevermos um c\u00f3digo que fecha o arquivo automaticamente depois que terminamos de utiliz\u00e1-lo: # Abre um arquivo para a leitura. with open ( 'arquivo_texto.txt' , 'r' ) as arquivo : conteudo = arquivo . read () # Quando sai do bloco do 'with', fecha o arquivo automaticamente. # Imprime o conte\u00fado print ( conteudo ) A sintaxe do c\u00f3digo acima \u00e9 um pouco diferente, ent\u00e3o vamos por partes. O with define um bloco dentro do qual o arquivo ser\u00e1 utilizado. Assim que o bloco termina, o que \u00e9 indicado pelo fim da indenta\u00e7\u00e3o, o arquivo ser\u00e1 automaticamente fechado. A fun\u00e7\u00e3o open () n\u00e3o foi alterada, mas agora ao inv\u00e9s de arquivo = open ( 'arquivo_texto.txt' , 'r' ) n\u00f3s temos open ( 'arquivo_texto.txt' , 'r' ) as arquivo . O resultado ser\u00e1 o mesmo: o arquivo aberto ser\u00e1 armazenado na vari\u00e1vel arquivo . Essa invers\u00e3o da ordem \u00e9 feita apenas em conjunto com o with . EXERC\u00cdCIO 2 \u00b6 Teste a vers\u00e3o do programa acima. O resultado deve ser o mesmo da primeira vers\u00e3o. Modos de abertura de um arquivo \u00b6 Comentamos que existem dois tipos de arquivo: arquivos bin\u00e1rios e arquivos de texto. Nos exemplos acima n\u00f3s trabalhamos com a leitura de um arquivo de texto. Para isso o modo de abertura do arquivo foi o 'r' , ou seja, leitura ( read ). Para abrir um arquivo bin\u00e1rio para leitura devemos utilizar o modo 'rb' ( read binary ). Tanto o modo 'r' quanto o modo 'rb' permitem apenas a leitura de um arquivo existente. N\u00e3o \u00e9 poss\u00edvel adicionar (escrever) nenhuma informa\u00e7\u00e3o a ele. Para adicionar dados a um arquivo devemos abri-lo com algum dos modos de escrita . Os modos dispon\u00edveis s\u00e3o 'w' e 'a' . O modo 'w' cria um novo arquivo no modo escrita ( write ). Importante: se j\u00e1 existir um arquivo com o mesmo nome ele apaga o antigo. O modo 'a' ( append ) \u00e9 um modo de escrita alternativo que adiciona o novo conte\u00fado ao final do arquivo se ele j\u00e1 existir, sem apagar o conte\u00fado anterior. Exemplos: # Cria o arquivo para escrita (limpa o antigo se j\u00e1 existir) with open ( 'arquivo_texto.txt' , 'w' ) as arquivo : # Escrevendo um texto arquivo . write ( \"algum dado \\n \" ) # Abre/Cria o arquivo para escrita SEM apagar o que tinha antes. with open ( 'arquivo_texto.txt' , 'a' ) as arquivo : # Escrevendo um texto arquivo . write ( \"novo dado \\n \" ) A seguir apresentamos um resumo dos principais modos de abertura de arquivos (para mais detalhes consulte a documenta\u00e7\u00e3o ): 'r' : modo de leitura de arquivo texto; 'rb' : modo de leitura de arquivo bin\u00e1rio; 'w' : modo de escrita de arquivo texto; 'wb' : modo de escrita de arquivo bin\u00e1rio; 'a' : modo de escrita de arquivo texto, sem apagar o conte\u00fado anterior; 'ab' : modo de escrita de arquivo bin\u00e1rio, sem apagar o conte\u00fado anterior. EXERC\u00cdCIO 3 \u00b6 Teste o programa acima no seu computador. Ele n\u00e3o vai imprimir nada no terminal, mas ao abrir o arquivo arquivo_texto . txt o seu conte\u00fado deve ser: algum dado novo dado Se troc\u00e1ssemos a ordem dos blocos with do programa acima, qual seria o efeito esperado? Teste essa mudan\u00e7a e verifique se ele fez o que voc\u00ea esperava. EXERC\u00cdCIO 4 \u00b6 Salve o arquivo cancao_do_exilio . txt (dispon\u00edvel neste link) na mesma pasta onde voc\u00ea fez os outros testes deste handout. Depois disso, teste cada um dos programas abaixo: Programa 1 \u00b6 # Lendo tudo de uma vez with open ( 'cancao_do_exilio.txt' , 'r' ) as arquivo : conteudo_completo = arquivo . read () print ( conteudo_completo ) Programa 2 \u00b6 # Lendo apenas a primeira linha with open ( 'cancao_do_exilio.txt' , 'r' ) as arquivo : primeira_linha = arquivo . readline () print ( primeira_linha ) Programa 3 \u00b6 # Lendo de linha em linha (note o plural em readlines) with open ( 'cancao_do_exilio.txt' , 'r' ) as arquivo : # linhas \u00e9 uma lista de strings, cada linha \u00e9 uma string diferente linhas = arquivo . readlines () # Verificando que linhas \u00e9 uma lista de strings print ( linhas ) # Imprimindo de linha em linha for linha in linhas : print ( linha ) Note que no \u00faltimo exemplo as linhas aparecer\u00e3o sempre com uma linha em branco entre si. Isso acontece porque no arquivo original cada linha termina em um ' \\n ' , que indica que a linha terminou, mas o print tamb\u00e9m pula uma linha automaticamente, ent\u00e3o sempre ser\u00e3o puladas duas linhas. Resumo dos m\u00e9todos de arquivos: \u00b6 Abaixo voc\u00ea encontra um resumo dos principais m\u00e9todos de arquivos. Para mais detalhes, consulte a documenta\u00e7\u00e3o . Para arquivos abertos no modo de leitura \u00b6 read : retorna todo o conte\u00fado do arquivo em uma \u00fanica string; readline : retorna uma string contendo apenas a pr\u00f3xima linha; readlines : retorna uma lista de strings, contendo uma string para cada linha. Para arquivos abertos no modo de escrita \u00b6 write : escreve no arquivo a string passada como argumento; writelines : recebe uma lista de strings e escreve todas no arquivo. EXERC\u00cdCIO 5 \u00b6 Fa\u00e7a o Exerc\u00edcio 158. Conta palavras no arquivo . EXERC\u00cdCIO 6 \u00b6 Fa\u00e7a o Exerc\u00edcio 85. Bananas no arquivo . EXERC\u00cdCIO 7 \u00b6 Fa\u00e7a o Exerc\u00edcio 86. CSV para TSV . EXERC\u00cdCIO 8 \u00b6 Fa\u00e7a o Exerc\u00edcio 87. Custo do churrasco . O formato JSON \u00b6 O formato JSON \u00e9 uma forma de trocar informa\u00e7\u00e3o de modo estruturado, simples e r\u00e1pido entre sistemas. Ele \u00e9 muito parecido com um dicion\u00e1rio do Python, contudo o JSON \u00e9 um texto (string) e n\u00e3o uma estrutura de dados. Por ser um texto, ele pode ser armazenado em um arquivo. Assim esses dados continuam existindo, mesmo depois que o programa termina. Exemplo: {\"Alunos\":[ { \"nome\": \"Jo\u00e3o\", \"notas\": [ 8, 9, 5 ] }, { \"nome\": \"Maria\", \"notas\": [ 8, 10, 7 ] }, { \"nome\": \"Jos\u00e9\", \"notas\": [ 10, 10, 9 ] } ]} O JSON acima cont\u00e9m os nomes e notas de 3 alunos. Esse poderia ser o conte\u00fado de um arquivo de texto chamado, por exemplo, alunos . json . Para utilizar os dados presentes nele ser\u00e1 necess\u00e1rio processar a string JSON para obter um dicion\u00e1rio. Para isso utilizamos o m\u00f3dulo json do Python: import json with open ( 'alunos.json' , 'r' ) as arquivo_json : texto = arquivo_json . read () print ( texto ) # Para verificar que \u00e9 realmente um texto (string), # vamos usar um fatiamento: print ( texto [: 15 ]) # Criando um dicion\u00e1rio a partir das informa\u00e7\u00f5es no texto dicionario = json . loads ( texto ) # Para verificar que \u00e9 um dicion\u00e1rio, # vamos imprimir o valor armazenado na chave \"Alunos\" print ( dicionario [ 'Alunos' ]) # Adicionando um novo aluno no dicion\u00e1rio novo_aluno = { 'nome' : 'Alice' , 'notas' : [ 10 , 7 , 8 ]} dicionario [ 'Alunos' ] . append ( novo_aluno ) # Transformando de volta para JSON (texto) novo_json = json . dumps ( dicionario ) # Salvando o arquivo with open ( 'alunos.json' , 'w' ) as arquivo_json : arquivo_json . write ( novo_json ) # Abra o arquivo alunos.json e verifique seu conte\u00fado. EXERC\u00cdCIO 9 \u00b6 Baixe o arquivo alunos.json dispon\u00edvel neste link . Salve-o na mesma pasta onde voc\u00ea est\u00e1 fazendo os testes deste handout. Abra o arquivo no Spyder, VS Code ou seu editor de texto favorito. Crie um novo arquivo chamado testa_json.py e copie o c\u00f3digo do programa acima. Teste-o e verifique o conte\u00fado do arquivo alunos.json . EXERC\u00cdCIO 10 \u00b6 Fa\u00e7a o Exerc\u00edcio 159. Valor total do estoque .","title":"Handout"},{"location":"aulas/09-arquivos/#09-arquivos","text":"Nossos programas at\u00e9 o momento utilizam dados fornecidos pelo usu\u00e1rio ou obtidos a partir de algum c\u00e1lculo, mas esses dados s\u00e3o perdidos assim que o programa acaba. Arquivos s\u00e3o estruturas de dados que normalmente s\u00e3o armazenados em dispositivos secund\u00e1rios de mem\u00f3ria. Esses dispositivos secund\u00e1rios de mem\u00f3ria permitem o armazenamento permanente dos dados, ou seja, mesmo depois que o programa acaba ou at\u00e9 depois que o computador \u00e9 reiniciado, os dados continuam existindo. Os principais dispositivos de armazenamento atualmente s\u00e3o: Disco R\u00edgido (HD) Solid-State Drive (SSD) Pen Drives Os arquivos armazenados nestes dispositivos possuem sempre uma identifica\u00e7\u00e3o (nome) e sua localiza\u00e7\u00e3o (normalmente em uma estrutura hier\u00e1rquica de diret\u00f3rios). Outros atributos como data e permiss\u00f5es de acesso tamb\u00e9m s\u00e3o normalmente usados no \u00edndice.","title":"09 - Arquivos"},{"location":"aulas/09-arquivos/#acessando-arquivos","text":"Arquivos s\u00e3o lidos como uma sequ\u00eancia de bytes. Um byte \u00e9 um conjunto de 8 bits ( BI nary digi T ), que s\u00e3o valores do tipo 0 ou 1. Bytes por si s\u00f3 n\u00e3o possuem significado nenhum, s\u00e3o simplesmente uma sequ\u00eancia de 0s e 1s. \u00c9 necess\u00e1rio que um programa seja capaz de entender essa sequ\u00eancia de bytes do arquivo para extrair alguma informa\u00e7\u00e3o. Existem basicamente dois tipos de arquivos: Arquivos de texto : os bytes representam caracteres. Por exemplo, os arquivos . py que criamos com o nosso c\u00f3digo Python s\u00e3o arquivos de texto. Cada caractere do nosso c\u00f3digo Python (incluindo espa\u00e7os e pula linha) \u00e9 representado por um byte e armazenado no nosso HD ou SSD. Arquivos bin\u00e1rios : cada byte pode ter um significado diferente. Por exemplo, em imagens \u00e9 comum usar bytes para representar cores. No exemplo abaixo, os bytes do arquivo (\u00e0 direita) s\u00e3o interpretados por um programa que \u00e9 capaz de mostrar o resultado como uma imagem (\u00e0 esquerda) Neste handout vamos aprender a trabalhar com arquivos em Python. Ao final do handout voc\u00ea deve ser capaz de abrir um arquivo para (1) ler os dados armazenados; ou (2) escrever dados.","title":"Acessando arquivos"},{"location":"aulas/09-arquivos/#arquivos-em-python","text":"Antes de utilizar qualquer arquivo \u00e9 necess\u00e1rio abri-lo. Para isso, existe a fun\u00e7\u00e3o open () , que recebe pelo menos dois argumentos: a localiza\u00e7\u00e3o do arquivo e o modo de abertura. Depois de utilizar o arquivo \u00e9 muito importante lembrar de fech\u00e1-lo. Muitos problemas podem acontecer se voc\u00ea esquecer de fechar o programa . Para isso devemos usar a fun\u00e7\u00e3o close () : # Modo tradicional de ler um arquivo arquivo = open ( 'arquivo_texto.txt' , 'r' ) conteudo = arquivo . read () arquivo . close () # O que acontece se n\u00e3o fechar? # Imprime o conte\u00fado print ( conteudo ) O programa acima abre um arquivo chamado arquivo_texto . txt para leitura ( importante : ele deve existir na mesma pasta onde voc\u00ea est\u00e1 executando o seu programa), armazena o conte\u00fado na vari\u00e1vel conteudo , fecha o arquivo e depois imprime todo o conte\u00fado do arquivo. Info Os testes deste handout utilizam arquivos externos. Por esse motivo, n\u00e3o faz muito sentido fazermos testes de mesa no servidor. A melhor maneira de entender o que o programa est\u00e1 fazendo \u00e9 execut\u00e1-lo no pr\u00f3prio computador para observar as mudan\u00e7as nos outros arquivos. Assim, neste handout n\u00e3o teremos testes de mesa do servidor. Fa\u00e7a todos os testes no seu pr\u00f3prio computador.","title":"Arquivos em Python"},{"location":"aulas/09-arquivos/#exercicio-1","text":"Teste o programa acima no seu computador. Para isso, crie um arquivo chamado arquivo_texto . txt e escreva alguma coisa (pode ser no Spyder, VS Code, ou qualquer editor de texto de sua prefer\u00eancia - n\u00e3o use o Word, pois ele gera um arquivo muito mais complicado ). Salve o programa acima na mesma pasta . Execute seu programa. Ele deve imprimir no terminal o conte\u00fado do seu arquivo. Caminho ( path ) do arquivo Quando estamos trabalhando com arquivos \u00e9 comum obtermos o erro FileNotFoundError . Ele ocorre quando tentamos abrir ( open () ) um arquivo que n\u00e3o existe. \u00c9 importante que o arquivo que voc\u00ea est\u00e1 tentando abrir esteja na mesma pasta que cont\u00e9m o seu programa. \u00c9 poss\u00edvel abrir arquivos localizados em outras pastas do seu computador, mas nesse caso \u00e9 necess\u00e1rio especificar o caminho do arquivo, ou seja, qual \u00e9 a sequ\u00eancia de pastas que devem ser percorridas para se localizar esse arquivo.","title":"EXERC\u00cdCIO 1"},{"location":"aulas/09-arquivos/#abrindo-arquivos-com-o-with","text":"Como dissemos anteriormente, \u00e9 muito importante se lembrar de fechar o arquivo depois de utiliz\u00e1-lo. Na verdade, isso \u00e9 t\u00e3o importante que existe uma maneira de escrevermos um c\u00f3digo que fecha o arquivo automaticamente depois que terminamos de utiliz\u00e1-lo: # Abre um arquivo para a leitura. with open ( 'arquivo_texto.txt' , 'r' ) as arquivo : conteudo = arquivo . read () # Quando sai do bloco do 'with', fecha o arquivo automaticamente. # Imprime o conte\u00fado print ( conteudo ) A sintaxe do c\u00f3digo acima \u00e9 um pouco diferente, ent\u00e3o vamos por partes. O with define um bloco dentro do qual o arquivo ser\u00e1 utilizado. Assim que o bloco termina, o que \u00e9 indicado pelo fim da indenta\u00e7\u00e3o, o arquivo ser\u00e1 automaticamente fechado. A fun\u00e7\u00e3o open () n\u00e3o foi alterada, mas agora ao inv\u00e9s de arquivo = open ( 'arquivo_texto.txt' , 'r' ) n\u00f3s temos open ( 'arquivo_texto.txt' , 'r' ) as arquivo . O resultado ser\u00e1 o mesmo: o arquivo aberto ser\u00e1 armazenado na vari\u00e1vel arquivo . Essa invers\u00e3o da ordem \u00e9 feita apenas em conjunto com o with .","title":"Abrindo arquivos com o with"},{"location":"aulas/09-arquivos/#exercicio-2","text":"Teste a vers\u00e3o do programa acima. O resultado deve ser o mesmo da primeira vers\u00e3o.","title":"EXERC\u00cdCIO 2"},{"location":"aulas/09-arquivos/#modos-de-abertura-de-um-arquivo","text":"Comentamos que existem dois tipos de arquivo: arquivos bin\u00e1rios e arquivos de texto. Nos exemplos acima n\u00f3s trabalhamos com a leitura de um arquivo de texto. Para isso o modo de abertura do arquivo foi o 'r' , ou seja, leitura ( read ). Para abrir um arquivo bin\u00e1rio para leitura devemos utilizar o modo 'rb' ( read binary ). Tanto o modo 'r' quanto o modo 'rb' permitem apenas a leitura de um arquivo existente. N\u00e3o \u00e9 poss\u00edvel adicionar (escrever) nenhuma informa\u00e7\u00e3o a ele. Para adicionar dados a um arquivo devemos abri-lo com algum dos modos de escrita . Os modos dispon\u00edveis s\u00e3o 'w' e 'a' . O modo 'w' cria um novo arquivo no modo escrita ( write ). Importante: se j\u00e1 existir um arquivo com o mesmo nome ele apaga o antigo. O modo 'a' ( append ) \u00e9 um modo de escrita alternativo que adiciona o novo conte\u00fado ao final do arquivo se ele j\u00e1 existir, sem apagar o conte\u00fado anterior. Exemplos: # Cria o arquivo para escrita (limpa o antigo se j\u00e1 existir) with open ( 'arquivo_texto.txt' , 'w' ) as arquivo : # Escrevendo um texto arquivo . write ( \"algum dado \\n \" ) # Abre/Cria o arquivo para escrita SEM apagar o que tinha antes. with open ( 'arquivo_texto.txt' , 'a' ) as arquivo : # Escrevendo um texto arquivo . write ( \"novo dado \\n \" ) A seguir apresentamos um resumo dos principais modos de abertura de arquivos (para mais detalhes consulte a documenta\u00e7\u00e3o ): 'r' : modo de leitura de arquivo texto; 'rb' : modo de leitura de arquivo bin\u00e1rio; 'w' : modo de escrita de arquivo texto; 'wb' : modo de escrita de arquivo bin\u00e1rio; 'a' : modo de escrita de arquivo texto, sem apagar o conte\u00fado anterior; 'ab' : modo de escrita de arquivo bin\u00e1rio, sem apagar o conte\u00fado anterior.","title":"Modos de abertura de um arquivo"},{"location":"aulas/09-arquivos/#exercicio-3","text":"Teste o programa acima no seu computador. Ele n\u00e3o vai imprimir nada no terminal, mas ao abrir o arquivo arquivo_texto . txt o seu conte\u00fado deve ser: algum dado novo dado Se troc\u00e1ssemos a ordem dos blocos with do programa acima, qual seria o efeito esperado? Teste essa mudan\u00e7a e verifique se ele fez o que voc\u00ea esperava.","title":"EXERC\u00cdCIO 3"},{"location":"aulas/09-arquivos/#exercicio-4","text":"Salve o arquivo cancao_do_exilio . txt (dispon\u00edvel neste link) na mesma pasta onde voc\u00ea fez os outros testes deste handout. Depois disso, teste cada um dos programas abaixo:","title":"EXERC\u00cdCIO 4"},{"location":"aulas/09-arquivos/#programa-1","text":"# Lendo tudo de uma vez with open ( 'cancao_do_exilio.txt' , 'r' ) as arquivo : conteudo_completo = arquivo . read () print ( conteudo_completo )","title":"Programa 1"},{"location":"aulas/09-arquivos/#programa-2","text":"# Lendo apenas a primeira linha with open ( 'cancao_do_exilio.txt' , 'r' ) as arquivo : primeira_linha = arquivo . readline () print ( primeira_linha )","title":"Programa 2"},{"location":"aulas/09-arquivos/#programa-3","text":"# Lendo de linha em linha (note o plural em readlines) with open ( 'cancao_do_exilio.txt' , 'r' ) as arquivo : # linhas \u00e9 uma lista de strings, cada linha \u00e9 uma string diferente linhas = arquivo . readlines () # Verificando que linhas \u00e9 uma lista de strings print ( linhas ) # Imprimindo de linha em linha for linha in linhas : print ( linha ) Note que no \u00faltimo exemplo as linhas aparecer\u00e3o sempre com uma linha em branco entre si. Isso acontece porque no arquivo original cada linha termina em um ' \\n ' , que indica que a linha terminou, mas o print tamb\u00e9m pula uma linha automaticamente, ent\u00e3o sempre ser\u00e3o puladas duas linhas.","title":"Programa 3"},{"location":"aulas/09-arquivos/#resumo-dos-metodos-de-arquivos","text":"Abaixo voc\u00ea encontra um resumo dos principais m\u00e9todos de arquivos. Para mais detalhes, consulte a documenta\u00e7\u00e3o .","title":"Resumo dos m\u00e9todos de arquivos:"},{"location":"aulas/09-arquivos/#para-arquivos-abertos-no-modo-de-leitura","text":"read : retorna todo o conte\u00fado do arquivo em uma \u00fanica string; readline : retorna uma string contendo apenas a pr\u00f3xima linha; readlines : retorna uma lista de strings, contendo uma string para cada linha.","title":"Para arquivos abertos no modo de leitura"},{"location":"aulas/09-arquivos/#para-arquivos-abertos-no-modo-de-escrita","text":"write : escreve no arquivo a string passada como argumento; writelines : recebe uma lista de strings e escreve todas no arquivo.","title":"Para arquivos abertos no modo de escrita"},{"location":"aulas/09-arquivos/#exercicio-5","text":"Fa\u00e7a o Exerc\u00edcio 158. Conta palavras no arquivo .","title":"EXERC\u00cdCIO 5"},{"location":"aulas/09-arquivos/#exercicio-6","text":"Fa\u00e7a o Exerc\u00edcio 85. Bananas no arquivo .","title":"EXERC\u00cdCIO 6"},{"location":"aulas/09-arquivos/#exercicio-7","text":"Fa\u00e7a o Exerc\u00edcio 86. CSV para TSV .","title":"EXERC\u00cdCIO 7"},{"location":"aulas/09-arquivos/#exercicio-8","text":"Fa\u00e7a o Exerc\u00edcio 87. Custo do churrasco .","title":"EXERC\u00cdCIO 8"},{"location":"aulas/09-arquivos/#o-formato-json","text":"O formato JSON \u00e9 uma forma de trocar informa\u00e7\u00e3o de modo estruturado, simples e r\u00e1pido entre sistemas. Ele \u00e9 muito parecido com um dicion\u00e1rio do Python, contudo o JSON \u00e9 um texto (string) e n\u00e3o uma estrutura de dados. Por ser um texto, ele pode ser armazenado em um arquivo. Assim esses dados continuam existindo, mesmo depois que o programa termina. Exemplo: {\"Alunos\":[ { \"nome\": \"Jo\u00e3o\", \"notas\": [ 8, 9, 5 ] }, { \"nome\": \"Maria\", \"notas\": [ 8, 10, 7 ] }, { \"nome\": \"Jos\u00e9\", \"notas\": [ 10, 10, 9 ] } ]} O JSON acima cont\u00e9m os nomes e notas de 3 alunos. Esse poderia ser o conte\u00fado de um arquivo de texto chamado, por exemplo, alunos . json . Para utilizar os dados presentes nele ser\u00e1 necess\u00e1rio processar a string JSON para obter um dicion\u00e1rio. Para isso utilizamos o m\u00f3dulo json do Python: import json with open ( 'alunos.json' , 'r' ) as arquivo_json : texto = arquivo_json . read () print ( texto ) # Para verificar que \u00e9 realmente um texto (string), # vamos usar um fatiamento: print ( texto [: 15 ]) # Criando um dicion\u00e1rio a partir das informa\u00e7\u00f5es no texto dicionario = json . loads ( texto ) # Para verificar que \u00e9 um dicion\u00e1rio, # vamos imprimir o valor armazenado na chave \"Alunos\" print ( dicionario [ 'Alunos' ]) # Adicionando um novo aluno no dicion\u00e1rio novo_aluno = { 'nome' : 'Alice' , 'notas' : [ 10 , 7 , 8 ]} dicionario [ 'Alunos' ] . append ( novo_aluno ) # Transformando de volta para JSON (texto) novo_json = json . dumps ( dicionario ) # Salvando o arquivo with open ( 'alunos.json' , 'w' ) as arquivo_json : arquivo_json . write ( novo_json ) # Abra o arquivo alunos.json e verifique seu conte\u00fado.","title":"O formato JSON"},{"location":"aulas/09-arquivos/#exercicio-9","text":"Baixe o arquivo alunos.json dispon\u00edvel neste link . Salve-o na mesma pasta onde voc\u00ea est\u00e1 fazendo os testes deste handout. Abra o arquivo no Spyder, VS Code ou seu editor de texto favorito. Crie um novo arquivo chamado testa_json.py e copie o c\u00f3digo do programa acima. Teste-o e verifique o conte\u00fado do arquivo alunos.json .","title":"EXERC\u00cdCIO 9"},{"location":"aulas/09-arquivos/#exercicio-10","text":"Fa\u00e7a o Exerc\u00edcio 159. Valor total do estoque .","title":"EXERC\u00cdCIO 10"},{"location":"aulas/10-pygame/","text":"10 - PyGame \u00b6 Neste handout vamos come\u00e7ar a nos preparar para desenvolver o projeto final de Design de Software. Para isso vamos apresentar uma biblioteca de desenvolvimento de jogos em Python chamada pygame. Ao final deste handout voc\u00ea ter\u00e1 implementado um jogo simples baseado no Asteroids usando pygame. Estrutura b\u00e1sica de um jogo \u00b6 Vamos come\u00e7ar entendendo a estrutura de um jogo qualquer. Note que este conhecimento independe da biblioteca ou linguagem de programa\u00e7\u00e3o utilizada. Essa estrutura pode ser resumida da seguinte maneira: Nas se\u00e7\u00f5es a seguir explicamos o que o programa faz em cada um desses blocos. Inicializa\u00e7\u00e3o \u00b6 Importa e inicia pacotes: por exemplo, realiza os imports no Python; Inicia estruturas de dados: por exemplo, inicia listas, dicion\u00e1rios, vari\u00e1veis, etc. com seus valores padr\u00e3o; Inicia assets: exemplos de assets s\u00e3o imagens, sons, sprites, modelos 3D, etc. que s\u00e3o utilizados pelo jogo; Gera tela principal: criar a janela onde o jogo ser\u00e1 apresentado; Dispara loop principal: depois que toda a inicializa\u00e7\u00e3o est\u00e1 conclu\u00edda o jogo propriamente dito se inicia. Loop principal \u00b6 O jogo e toda a intera\u00e7\u00e3o acontece durante esta fase. O loop principal, tamb\u00e9m chamado de game loop , se repete enquanto o jogo estiver rodando. Em geral, ao final de uma itera\u00e7\u00e3o do loop principal ser\u00e1 gerado um novo frame para ser apresentado para o usu\u00e1rio. Trata eventos: por exemplo, movimentos/cliques de mouse, input de teclado, timer, clique do usu\u00e1rio no X para fechar a janela, etc. Verifica consequ\u00eancias: verifica se houve colis\u00f5es, aplica as a\u00e7\u00f5es do usu\u00e1rio (por exemplo, muda a dire\u00e7\u00e3o do personagem se o jogador apertou uma tecla), etc. de acordo com as regras e mec\u00e2nica do jogo; Atualiza estado do jogo: move os objetos na tela, atualiza os estados dos assets (por exemplo, muda a anima\u00e7\u00e3o) e as estruturas de dados utilizadas (por exemplo, atualiza a lista de personagens vivos); Gera sa\u00eddas: exibe as mudan\u00e7as para o jogador (gera uma nova imagem/frame, toca um som, etc.). Finaliza\u00e7\u00e3o \u00b6 Na finaliza\u00e7\u00e3o pode ser realizado o fechamento de arquivos, salvar o placar do jogo, fechar a janela do jogo, etc. O pygame \u00e9 um framework (ou game engine ) para desenvolvimento de jogos em Python, baseado na biblioteca SDL2 (Simple DirectMedia Layer). Instala\u00e7\u00e3o \u00b6 Windows e Linux \u00b6 Abra o seu terminal (Linux) ou Anaconda Prompt (Windows) e digite: pip install pygame Mac OSX \u00b6 A instala\u00e7\u00e3o no Mac \u00e9 um pouco mais complicada, infelizmente. Se voc\u00ea n\u00e3o tiver o Homebrew instalado, instale-o seguindo as instru\u00e7\u00f5es dispon\u00edveis neste link (se voc\u00ea n\u00e3o sabe se tem o Homebrew instalado, provavelmente n\u00e3o tem): https://brew.sh/ Abra o terminal e digite: brew install sdl2 sdl2_gfx sdl2_image sdl2_mixer sdl2_net sdl2_ttf brew install Caskroom/cask/xquartz git clone -b 1.9.6 --single-branch https://github.com/pygame/pygame.git cd pygame python setup.py -config -auto -sdl2 python setup.py install cd .. rm -rf pygame Para mais detalhes e outras op\u00e7\u00f5es de instala\u00e7\u00e3o no Mac, consulte a documenta\u00e7\u00e3o: https://www.pygame.org/wiki/MacCompile Preparo para o tutorial \u00b6 Antes de seguir com o tutorial de pygame, fa\u00e7a o download do arquivo referencia.zip (dispon\u00edvel neste link) . Descompacte os arquivos em uma pasta, sem alterar a estrutura de pastas. Importante Consulte a documenta\u00e7\u00e3o se n\u00e3o entender algum dos comandos. Criando uma janela \u00b6 Veremos que ser\u00e1 necess\u00e1rio utilizarmos muitos comandos para fazer coisas aparentemente simples, como mostrar uma janela em branco. N\u00e3o se assuste. Muito desse c\u00f3digo se repete de maneira muito semelhante em qualquer jogo que voc\u00ea for desenvolver. Vamos come\u00e7ar ent\u00e3o com o exemplo que acabamos de comentar: como mostrar uma janela do pygame. Abra o arquivo referencia / jogo_v1 . py . Esse arquivo cont\u00e9m coment\u00e1rios que separam o c\u00f3digo nos blocos descritos no in\u00edcio deste handout. Vamos entender o que esses comandos fazem: referencia/jogo_v1.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame pygame . init () # ----- Gera tela principal window = pygame . display . set_mode (( 500 , 400 )) pygame . display . set_caption ( 'Hello World!' ) # ----- Inicia estruturas de dados game = True # ===== Loop principal ===== while game : # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : game = False # ----- Gera sa\u00eddas window . fill (( 255 , 255 , 255 )) # Preenche com a cor branca # ----- Atualiza estado do jogo pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados pygame . init () (linha 5): o framework pygame \u00e9 iniciado. Apenas ap\u00f3s este comando \u00e9 que os recursos do pacote podem ser utilizados; pygame . display . set_mode (( 500 , 400 )) (linha 8): cria uma janela com 500 pixels de largura e 400 pixels de altura; pygame . display . set_caption ( 'Hello World!' ) (linha 9): define o t\u00edtulo da janela (que aparece na barra superior) como o texto 'Hello World!' ; game = True (linha 12): a vari\u00e1vel game ser\u00e1 utilizada para indicar que o jogo deve continuar; while game : (linha 15): continua o jogo enquanto game for True ; for event in pygame . event . get (): (linha 17): pygame . event . get () devolve uma lista com todos os eventos (cliques/movimentos de mouse, teclas apertadas, bot\u00f5es da janela apertados, etc.) que ocorreram desde a \u00faltima vez que essa fun\u00e7\u00e3o foi chamada. O for percorre cada um desses eventos, aplicando as consequ\u00eancias necess\u00e1rias a cada caso; if event . type == pygame . QUIT : (linha 19): verifica se o tipo do evento \u00e9 pygame . QUIT , ou seja, se o usu\u00e1rio clicou no bot\u00e3o de fechar a janela (consulte a documenta\u00e7\u00e3o para ver mais eventos poss\u00edveis); game = False (linha 20): muda o valor para False para que a pr\u00f3xima itera\u00e7\u00e3o do loop principal n\u00e3o seja mais executada. Depois disso o programa termina; window . fill (( 255 , 255 , 255 )) (linha 23): preenche a janela com a cor branca. As cores s\u00e3o valores RGB (Red, Green, Blue) que variam entre 0 e 255. Note que existe um par\u00eanteses ao redor dos tr\u00eas valores. Esse par\u00eanteses \u00e9 muito importante, pois define uma tupla (uma sequ\u00eancia de valores, semelhante a uma lista); pygame . display . update () (linha 26): tudo o que \u00e9 feito na tela ( window ) n\u00e3o \u00e9 mostrado para o usu\u00e1rio imediatamente, assim \u00e9 poss\u00edvel desenhar v\u00e1rias coisas e somente depois de terminar de desenhar mostramos a nova tela (ou frame) para o usu\u00e1rio. Essa fun\u00e7\u00e3o \u00e9 respons\u00e1vel por mostrar a nova tela que foi desenhada; pygame . quit () (linha 29): finaliza o pygame. \u00c9 importante chamar essa fun\u00e7\u00e3o para que ele feche todos os recursos que abriu (por exemplo a janela). EXERC\u00cdCIO 1 \u00b6 Aplique as seguintes modifica\u00e7\u00f5es ao c\u00f3digo do jogo_v1 . py : Utilize uma janela de 600 X 300 pixels; Mude o t\u00edtulo para Jogo da / do NOME (onde NOME \u00e9 o seu nome); Mude a cor da janela para azul ao inv\u00e9s de branco; Fa\u00e7a o jogo fechar assim que o usu\u00e1rio apertar qualquer tecla do teclado. Dica: procure pelo evento pygame . KEYUP . Desenhando na tela \u00b6 Vamos come\u00e7ar desenhando pol\u00edgono na tela. Para isso precisamos entender o sistema de coordenadas da tela do pygame (imagem extra\u00edda de: https://medium.com/iothincvit/pygame-for-beginners-234da7d3c56f ): No pygame, o canto superior esquerdo da janela \u00e9 a origem (ponto ( 0 , 0 ) ). O eixo X aumenta para a direita e o eixo Y aumenta para baixo . Assim, se queremos mostrar uma informa\u00e7\u00e3o \"mais para baixo\", devemos aumentar o valor de Y. Abra o arquivo jogo_v2 . py . A \u00fanica diferen\u00e7a para a vers\u00e3o 1 s\u00e3o as linhas 24 a 26. Nas linhas 24 e 25 n\u00f3s definimos uma cor (vermelha) e os v\u00e9rtices de um pol\u00edgono. Na linha 26 chamamos a fun\u00e7\u00e3o pygame . draw . polygon , que recebe uma superf\u00edcie na qual o pol\u00edgono ser\u00e1 desenhado (no nosso caso, a janela), a cor e os v\u00e9rtices do pol\u00edgono. referencia/jogo_v2.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame pygame . init () # ----- Gera tela principal window = pygame . display . set_mode (( 500 , 400 )) pygame . display . set_caption ( 'Hello World!' ) # ----- Inicia estruturas de dados game = True # ===== Loop principal ===== while game : # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : game = False # ----- Gera sa\u00eddas window . fill (( 255 , 255 , 255 )) # Preenche com a cor branca cor = ( 255 , 0 , 0 ) vertices = [( 250 , 0 ), ( 500 , 200 ), ( 250 , 400 ), ( 0 , 200 )] pygame . draw . polygon ( window , cor , vertices ) # ----- Atualiza estado do jogo pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados EXERC\u00cdCIO 2 \u00b6 Modifique o c\u00f3digo do jogo_v2 . py para que ele desenhe a bandeira do Brasil (simplificada, s\u00f3 a parte verde, amarela e azul). Dica: voc\u00ea provavelmente vai querer utilizar a fun\u00e7\u00e3o pygame . draw . circle (consulte a documenta\u00e7\u00e3o para entender como utiliz\u00e1-la). Tente mudar a ordem dos desenhos (desenhe primeiro o c\u00edrculo, depois o pol\u00edgono). O que acontece? A ordem dos desenhos importa. O novo desenho \u00e9 sempre feito sobrepondo os desenhos anteriores. Desenhando um texto \u00b6 Talvez voc\u00ea tenha estranhado o t\u00edtulo desta se\u00e7\u00e3o, mas qualquer texto deve realmente ser desenhado para aparecer na tela. Os caracteres de um texto tamb\u00e9m s\u00e3o desenhados como pixels. Vamos entender o arquivo jogo_v3 . py . Antes de abrir o arquivo, execute-o para ver o resultado. referencia/jogo_v3.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame pygame . init () # ----- Gera tela principal window = pygame . display . set_mode (( 500 , 400 )) pygame . display . set_caption ( 'Hello World!' ) # ----- Inicia estruturas de dados game = True # ----- Inicia assets font = pygame . font . SysFont ( None , 48 ) text = font . render ( 'HELLO WORLD' , True , ( 0 , 0 , 255 )) # ===== Loop principal ===== while game : # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : game = False # ----- Gera sa\u00eddas window . fill (( 255 , 255 , 255 )) # Preenche com a cor branca window . blit ( text , ( 10 , 10 )) # ----- Atualiza estado do jogo pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados Agora que voc\u00ea j\u00e1 viu o HELLO WORLD na tela, vamos entender o c\u00f3digo. As mudan\u00e7as est\u00e3o nas linhas 15, 16 e 28: font = pygame . font . SysFont ( None , 48 ) (linha 15): carrega uma nova fonte de texto. Como n\u00e3o passamos nada como o primeiro argumento ( None ), o PyGame vai utilizar a fonte padr\u00e3o. O segundo argumento \u00e9 o tamanho da fonte; text = font . render ( 'HELLO WORLD' , True , ( 0 , 0 , 255 )) (linha 16): cria uma imagem a partir da fonte criada na linha anterior com o texto 'HELLO WORLD' . O segundo argumento neste momento pode ser sempre True (ele faz com que as curvas sejam desenhadas de maneira mais suave). O terceiro argumento \u00e9 a cor; window . blit ( text , ( 10 , 10 )) (linha 28): desenha em window a imagem text na posi\u00e7\u00e3o ( 10 , 10 ) (lembrando que a origem - ponto (0, 0) - \u00e9 no canto superior esquerdo). A imagem \u00e9 delimitada por um ret\u00e2ngulo. A posi\u00e7\u00e3o passada como segundo argumento define a localiza\u00e7\u00e3o do ponto superior esquerdo desse ret\u00e2ngulo. Por padr\u00e3o, sempre que nos referimos \u00e0 posi\u00e7\u00e3o da imagem (coordenada (x, y) (x, y) ) queremos dizer o seu canto superior esquerdo. EXERC\u00cdCIO 3 \u00b6 Modifique o jogo_v3 . py para que ele desenhe o texto HELLO em uma posi\u00e7\u00e3o (por exemplo, no ponto (10, 10), onde ele j\u00e1 est\u00e1) e o texto WORLD em outro lugar da janela (por exemplo, no ponto (100, 100)). Desenhando uma imagem \u00b6 Como vimos na se\u00e7\u00e3o anterior, text j\u00e1 era uma imagem que foi desenhada na tela. Assim, n\u00e3o precisamos mudar muito o c\u00f3digo para desenhar uma imagem qualquer. Execute o arquivo jogo_v4 . py e depois abra o c\u00f3digo. A principal mudan\u00e7a est\u00e1 na linha 17, na qual carregamos uma imagem de um arquivo ao inv\u00e9s de desenhar um texto em uma imagem. O . convert () no final da linha \u00e9 uma otimiza\u00e7\u00e3o para acelerar o desenho da imagem. \u00c9 uma boa pr\u00e1tica sempre chamar esse m\u00e9todo ao carregar uma imagem. Alternativamente pode-se utilizar o . convert_alpha () quando a imagem possui transpar\u00eancia. referencia/jogo_v4.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame pygame . init () # ----- Gera tela principal WIDTH = 500 HEIGHT = 400 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Hello World!' ) # ----- Inicia estruturas de dados game = True # ----- Inicia assets image = pygame . image . load ( 'assets/img/logo-madfox.png' ) . convert () # ===== Loop principal ===== while game : # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : game = False # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( image , ( 10 , 10 )) # ----- Atualiza estado do jogo pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados Aproveitamos para come\u00e7ar a organizar melhor o c\u00f3digo. Foram criadas duas constantes, WIDTH e HEIGHT , para guardar o valor da largura e altura da janela. Assim, sempre que precisarmos dessa informa\u00e7\u00e3o podemos usar as constantes ao inv\u00e9s de colocar os n\u00fameros diretamente. Isso facilita muito quando queremos alterar o tamanho da janela. Nesse caso n\u00e3o ser\u00e1 necess\u00e1rio procurar em todos os lugares do c\u00f3digo onde o n\u00famero aparece. Basta mudar o valor da constante. EXERC\u00cdCIO 4 \u00b6 A imagem est\u00e1 grande demais. Modifique o jogo_v4 . py para mostrar uma imagem menor. Dica: use o comando image = pygame . transform . scale ( image , ( 125 , 166 )) para obter uma nova imagem de 125 X 166 pixels. Recriando o Asteroids \u00b6 Asteroids \u00e9 um jogo de nave que foi muito famoso na d\u00e9cada de 80. Consiste em destruir os meteoros que vem em sua dire\u00e7\u00e3o atrav\u00e9s de tiros. Nesse tutorial, vamos replicar uma vers\u00e3o simplificada do jogo usando o pygame. Esse tutorial foi baseado no site KidsCanCode , o qual possui mais tutoriais com mais t\u00e9cnicas de desenvolvimento de jogos. O arquivo jogo_v5 . py apresenta uma primeira vers\u00e3o com um \u00fanico meteoro que fica caindo do topo da tela. Quando sai da tela, ele retorna \u00e0 posi\u00e7\u00e3o inicial. Execute o jogo_v5 . py e depois abra o arquivo para entender o que ele faz. referencia/jogo_v5.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random pygame . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets METEOR_WIDTH = 50 METEOR_HEIGHT = 38 font = pygame . font . SysFont ( None , 48 ) background = pygame . image . load ( 'assets/img/starfield.png' ) . convert () meteor_img = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () meteor_img_small = pygame . transform . scale ( meteor_img , ( METEOR_WIDTH , METEOR_HEIGHT )) # ----- Inicia estruturas de dados game = True meteor_x = 200 # y negativo significa que est\u00e1 acima do topo da janela. O meteoro come\u00e7a fora da janela meteor_y = - METEOR_HEIGHT meteor_speedx = 3 meteor_speedy = 4 # ===== Loop principal ===== while game : # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : game = False # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o do meteoro meteor_x += meteor_speedx meteor_y += meteor_speedy # Se o meteoro passar do final da tela, volta para cima if meteor_y > HEIGHT or meteor_x + METEOR_WIDTH < 0 or meteor_x > WIDTH : meteor_x = 200 meteor_y = - METEOR_HEIGHT # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( background , ( 0 , 0 )) window . blit ( meteor_img_small , ( meteor_x , meteor_y )) pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados Este arquivo possui algumas modifica\u00e7\u00f5es: Linhas 18 a 20: carrega as imagens de fundo e do meteoro; Linhas 24 a 28: inicializa as vari\u00e1veis que armazenam a posi\u00e7\u00e3o e a velocidade do meteoro; Linhas 40 e 41: atualiza a posi\u00e7\u00e3o do meteoro; Linhas 43 a 45: verifica se o meteoro saiu da tela. Nesse caso, faz ele voltar para a posi\u00e7\u00e3o inicial. Linhas 49 e 50: desenha a imagem de fundo e depois a imagem do meteoro (note que a imagem de fundo s\u00f3 cobre a janela inteira porque mudamos o tamanho da janela para 480 X 600 pixels - caso contr\u00e1rio uma parte dela ficaria com a cor de fundo). EXERC\u00cdCIO 5 \u00b6 O meteoro sempre come\u00e7a na mesma posi\u00e7\u00e3o e sempre se move na mesma dire\u00e7\u00e3o. Vamos deixar o jogo mais interessante sorteando uma posi\u00e7\u00e3o aleat\u00f3ria. Sorteie valores aleat\u00f3rios para meteor_x , meteor_y , meteor_speedx , meteor_speedy na inicializa\u00e7\u00e3o do jogo (a partir da linha 24) e quando o meteoro sai da tela ( if da linha 43). Sugest\u00f5es de valores aleat\u00f3rios: meteor_x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) - o valor de x pode estar entre 0 e a largura da janela menos a largura da imagem do meteoro. Lembre-se que x \u00e9 a esquerda do ret\u00e2ngulo que define a imagem; meteor_y = random . randint ( - 100 , - METEOR_HEIGHT ) - valores negativos significam que o meteoro est\u00e1 acima da janela. Vamos sortear valores de maneira que ele sempre comece o movimento de fora da janela, ou seja, o mais baixo poss\u00edvel \u00e9 - METEOR_HEIGHT . Lembrando que y \u00e9 a coordenada de cima do ret\u00e2ngulo da imagem; meteor_speedx = random . randint ( - 3 , 3 ) - se os valores da componente x da velocidade forem muito altos o meteoro vai se mover para um dos lados sem descer muito; meteor_speedy = random . randint ( 2 , 9 ) - velocidades positivas em y significam que o meteoro vai se mover para baixo. Controlando a velocidade do jogo \u00b6 Voc\u00ea percebeu que o meteoro se move muito rapidamente? Isso acontece porque estamos em um loop infinito, cuja velocidade de execu\u00e7\u00e3o depende da CPU (processador), mem\u00f3ria e outras caracter\u00edsticas do equipamento onde estiver sendo executado. Dessa forma a velocidade de deslocamento da nave vai variar conforme a m\u00e1quina em que o jogo for executado e os programas que estejam nela rodando. Para controlar o n\u00famero de itera\u00e7\u00f5es do loop por segundo usaremos o seguinte artif\u00edcio: ser\u00e1 criado um rel\u00f3gio, a partir da classe Clock do pygame. Essa classe possui um m\u00e9todo chamado tick que conta quantos milissegundos j\u00e1 se passaram desde a \u00faltima vez que ele foi chamado. Pegaremos o tempo transcorrido mas n\u00e3o utilizaremos para nada. Mas ao pegar esse tempo especificaremos para o m\u00e9todo tick que queremos que ele seja executado no m\u00e1ximo 30 vezes por segundo. Dessa forma teremos um efeito colateral \u00fatil: o loop ser\u00e1 limitado por essa chamada e s\u00f3 executar\u00e1 30 vezes por segundo tamb\u00e9m. Assim, em qualquer m\u00e1quina que o c\u00f3digo for executado a velocidade de atualiza\u00e7\u00e3o do jogo ser\u00e1 a mesma (exceto, claro, se a m\u00e1quina for t\u00e3o lenta que n\u00e3o conseguir executar nessa velocidade). Aplicamos essas mudan\u00e7as no arquivo jogo_v6 . py (linhas 34, 35 e 39). Execute o programa para ver o resultado da mudan\u00e7a. referencia/jogo_v6.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random pygame . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets METEOR_WIDTH = 50 METEOR_HEIGHT = 38 font = pygame . font . SysFont ( None , 48 ) background = pygame . image . load ( 'assets/img/starfield.png' ) . convert () meteor_img = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () meteor_img_small = pygame . transform . scale ( meteor_img , ( METEOR_WIDTH , METEOR_HEIGHT )) # ----- Inicia estruturas de dados game = True # Sorteia posi\u00e7\u00e3o aleat\u00f3ria # Como x \u00e9 o lado esquerdo da imagem, ele s\u00f3 pode ir at\u00e9 a largura da # janela menos a largura da imagem meteor_x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) # y negativo significa que est\u00e1 acima do topo da janela. O meteoro come\u00e7a fora da janela meteor_y = random . randint ( - 100 , - METEOR_HEIGHT ) # Sorteia velocidade do meteoro meteor_speedx = random . randint ( - 3 , 3 ) meteor_speedy = random . randint ( 2 , 9 ) # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () FPS = 15 # ===== Loop principal ===== while game : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : game = False # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o do meteoro meteor_x += meteor_speedx meteor_y += meteor_speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if meteor_y > HEIGHT or meteor_x + METEOR_WIDTH < 0 or meteor_x > WIDTH : meteor_x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) meteor_y = random . randint ( - 100 , - METEOR_HEIGHT ) meteor_speedx = random . randint ( - 3 , 3 ) meteor_speedy = random . randint ( 2 , 9 ) # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( background , ( 0 , 0 )) window . blit ( meteor_img_small , ( meteor_x , meteor_y )) pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados EXERC\u00cdCIO 6 \u00b6 Agora parece que limitamos demais o n\u00famero de execu\u00e7\u00f5es do loop principal. A anima\u00e7\u00e3o parece um pouco travada. Altere a velocidade do jogo para que ele execute 30 frames por segundo ao inv\u00e9s de 15. Adicionando mais meteoros \u00b6 Vamos adicionar mais meteoros ao jogo. Para isso, onde ser\u00e1 necess\u00e1rio alterar o nosso c\u00f3digo? Temos a inicializa\u00e7\u00e3o da posi\u00e7\u00e3o e velocidade do meteoro no come\u00e7o do c\u00f3digo e depois temos a reinicializa\u00e7\u00e3o desses valores quando o meteoro sai da tela. Al\u00e9m disso, precisamos desenhar os meteoros em um outro lugar. Est\u00e1 come\u00e7ando a ficar complexo, n\u00e3o \u00e9 mesmo? Classes em Python \u00b6 Antes de criar mais meteoros, vamos ent\u00e3o melhorar o nosso c\u00f3digo. Para isso vamos utilizar um recurso dispon\u00edvel no Python chamado classes. Em Design de Software n\u00e3o vamos entrar em detalhes sobre o que s\u00e3o classes, nem como montar boas classes. Queremos apenas saber o m\u00ednimo para poder utiliz\u00e1-las. Neste primeiro momento voc\u00ea pode entender uma classe como um tipo de dados do Python. Na verdade, j\u00e1 trabalhamos com algumas classes, por mais que n\u00e3o tenhamos chamado-as assim: listas, strings e dicion\u00e1rios s\u00e3o algumas das classes dispon\u00edveis na linguagem. O interessante \u00e9 que podemos criar novas classes (ou tipos) no Python. A ideia \u00e9 semelhante ao que fazemos com um def . Primeiro definimos a classe e depois usamos quando for necess\u00e1rio. Suponha, por exemplo, que queremos criar um novo tipo que represente um ponto com coordenadas x e y . Ele poderia ser feito da seguinte maneira (o exemplo completo est\u00e1 no arquivo teste_ponto . py ): class Point : def __init__ ( self ): self . x = 0 self . y = 0 Isso define uma classe Point que possui coordenadas x e y ambas iguais a zero. Note que apenas definimos esse novo tipo, mas ainda n\u00e3o usamos. A partir desse momento o Python sabe o que \u00e9 uma lista, o que \u00e9 uma string e agora tamb\u00e9m o que \u00e9 um Point . Vamos utilizar esse nosso novo tipo: ponto = Point () print ( 'O ponto est\u00e1 nas coordenadas x= {0} e y= {1} ' . format ( ponto . x , ponto . y )) O c\u00f3digo acima vai imprimir: O ponto est\u00e1 nas coordenadas x = 0 e y = 0 . O x e y s\u00e3o vari\u00e1veis (chamamos de atributos) que est\u00e3o ligadas \u00e0quele ponto espec\u00edfico. Podemos inclusive mudar o seu valor: ponto = Point () ponto . x = 2 ponto . y = 5 print ( 'O ponto est\u00e1 nas coordenadas x= {0} e y= {1} ' . format ( ponto . x , ponto . y )) Esse novo c\u00f3digo vai imprimir: O ponto est\u00e1 nas coordenadas x = 2 e y = 5 . Podemos modificar a nossa classe para que ela receba como argumentos os valores das coordenadas assim que um novo ponto \u00e9 criado: class Point : def __init__ ( self , x_coord , y_coord ): self . x = x_coord self . y = y_coord ponto = Point ( 4 , 1 ) print ( 'O ponto est\u00e1 nas coordenadas x= {0} e y= {1} ' . format ( ponto . x , ponto . y )) Esse novo c\u00f3digo vai imprimir: O ponto est\u00e1 nas coordenadas x = 4 e y = 1 . A fun\u00e7\u00e3o __init__ \u00e9 um tipo de fun\u00e7\u00e3o especial que \u00e9 chamada quando o novo ponto \u00e9 criado. Duas observa\u00e7\u00f5es importantes: S\u00e3o dois underscores no come\u00e7o e dois underscores no fim (chamamos esse par de dois underscores de dunder , ou double underscore ); Essas fun\u00e7\u00f5es que fazem parte de uma classe sempre recebem um primeiro argumento chamado self . Ele \u00e9 uma vari\u00e1vel que guarda o pr\u00f3prio objeto. No nosso exemplo, self \u00e9 o pr\u00f3prio ponto. Por isso, quando fazemos self . x = 0 estamos guardando na vari\u00e1vel (atributo) x desse ponto espec\u00edfico o valor 0 . Vamos ver mais um exemplo de uma fun\u00e7\u00e3o definida dentro da classe (tamb\u00e9m chamada de m\u00e9todo): class Point : def __init__ ( self , x_coord , y_coord ): self . x = x_coord self . y = y_coord def distance_to ( self , other_point ): dx = other_point . x - self . x dy = other_point . y - self . y return (( dx ** 2 ) + ( dy ** 2 )) ** 0.5 p1 = Point ( 4 , 1 ) p2 = Point ( 7 , 5 ) d = p1 . distance_to ( p2 ) print ( 'A dist\u00e2ncia de ( {0} , {1} ) a ( {2} , {3} ) \u00e9 {4} ' . format ( p1 . x , p1 . y , p2 . x , p2 . y , d )) O programa acima vai imprimir: A dist\u00e2ncia de ( 4 , 1 ) a ( 7 , 5 ) \u00e9 5 . Considere o comando na pen\u00faltima linha: d = p1 . distance_to ( p2 ) . Ele segue uma estrutura muito parecida com o que j\u00e1 faz\u00edamos com strings, por exemplo: s = 'Insper' t = s . replace ( 'Ins' , 'Su' ) print ( t ) Se voc\u00ea quiser praticar um pouco o uso de classes, fa\u00e7a os exerc\u00edcios 88 e 89 do servidor. Classes no pygame \u00b6 O pygame define algumas novas classes que facilitam o desenvolvimento de jogos. Uma dessas classes \u00e9 o pygame . sprite . Sprite . Vamos aprender como usar esse tipo com o exemplo do meteoro. O exemplo a seguir define uma classe do tipo Meteor , que estende as funcionalidades de um pygame . sprite . Sprite (ou seja, faz tudo que um Sprite faz e mais um pouco): class Meteor ( pygame . sprite . Sprite ): def __init__ ( self ): self . image = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () self . image = pygame . transform . scale ( self . image , ( METEOR_WIDTH , METEOR_HEIGHT )) self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) Na inicializa\u00e7\u00e3o do tipo Meteor temos o carregamento da imagem e o sorteio das posi\u00e7\u00f5es e velocidades do meteoro. Todo Sprite deve definir um atributo image e um rect . Eles s\u00e3o utilizados para desenhar a imagem. O rect define a posi\u00e7\u00e3o do ret\u00e2ngulo da imagem e oferece algumas vantagens, como podemos ver na condi\u00e7\u00e3o do if . Um ret\u00e2ngulo \u00e9 um outro tipo definido pelo pygame, que possui, al\u00e9m da posi\u00e7\u00e3o x e y , outros atributos \u00fateis, como top , left , right , bottom , centerx e centery . Usamos alguns desses exemplos no if , simplificando as compara\u00e7\u00f5es. O m\u00e9todo update ser\u00e1 chamado quando quisermos atualizar a posi\u00e7\u00e3o do meteoro, ou seja, em cada itera\u00e7\u00e3o do loop principal. O arquivo jogo_v7 . py cria a classe Meteor e substitui o c\u00f3digo referente ao meteoro da vers\u00e3o anterior. Execute-o para ver o resultado e depois abra o c\u00f3digo. Note que a classe Meteor est\u00e1 ligeiramente diferente da que apresentamos acima. A diferen\u00e7a \u00e9 que ao inv\u00e9s de carregar a imagem dentro do __init__ , n\u00f3s j\u00e1 recebemos uma imagem carregada no __init__ (linha 25). Essa diferen\u00e7a \u00e9 importante, pois ao inv\u00e9s de carregar uma nova imagem para cada novo meteoro, n\u00f3s carregamos a imagem apenas uma vez e usamos a mesma imagem carregada em todos os meteoros. Tamb\u00e9m adicionamos uma linha no come\u00e7o do __init__ , com pygame . sprite . Sprite . __init__ ( self ) . Como o Meteor \u00e9 uma estens\u00e3o da classe pygame . sprite . Sprite , n\u00f3s precisamos inicializar o resto do Sprite . N\u00e3o se preocupe se n\u00e3o entender todos os detalhes. Por enquanto basta saber que essa linha \u00e9 obrigat\u00f3ria. referencia/jogo_v7.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random pygame . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets METEOR_WIDTH = 50 METEOR_HEIGHT = 38 font = pygame . font . SysFont ( None , 48 ) background = pygame . image . load ( 'assets/img/starfield.png' ) . convert () meteor_img = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () meteor_img = pygame . transform . scale ( meteor_img , ( METEOR_WIDTH , METEOR_HEIGHT )) # ----- Inicia estruturas de dados # Definindo os novos tipos class Meteor ( pygame . sprite . Sprite ): def __init__ ( self , img ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = img self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) game = True # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () FPS = 30 # Criando dois meteoros meteor1 = Meteor ( meteor_img ) meteor2 = Meteor ( meteor_img ) # ===== Loop principal ===== while game : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : game = False # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o dos meteoros meteor1 . update () meteor2 . update () # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( background , ( 0 , 0 )) # Desenhando meteoros window . blit ( meteor1 . image , meteor1 . rect ) window . blit ( meteor2 . image , meteor2 . rect ) pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados As principais mudan\u00e7as nesta vers\u00e3o s\u00e3o: Linhas 24 a 46: defini\u00e7\u00e3o da classe Meteor ; Linhas 54 e 55: cria\u00e7\u00e3o de dois meteoros. Note que o c\u00f3digo que sorteava a posi\u00e7\u00e3o do meteoro (linhas 27 a 32 do jogo_v6 . py ) agora est\u00e1 na inicializa\u00e7\u00e3o (construtor) da classe Meteor , assim, ao criar dois meteoros, cada um ser\u00e1 sorteado com posi\u00e7\u00f5es e velocidades distintas; Linhas 69 e 70: atualiza\u00e7\u00e3o da posi\u00e7\u00e3o dos meteoros. A l\u00f3gica de atualiza\u00e7\u00e3o da posi\u00e7\u00e3o agora est\u00e1 concentrada na classe Meteor , assim n\u00e3o precisamos mais das linhas 49 a 57 do jogo_v6 . py ; Linhas 76 e 77: desenhando os meteoros. O c\u00f3digo \u00e9 bastante semelhante ao que t\u00ednhamos antes, mas agora utilizamos a imagem e o rect (que define a posi\u00e7\u00e3o da imagem) guardados como atributos de cada meteoro. EXERC\u00cdCIO 7 \u00b6 Modifique o jogo_v7 . py para que ele tenha 4 meteoros ao inv\u00e9s de 2. Adicionando mais meteoros ainda \u00b6 Conforme criamos mais meteoros, come\u00e7a a ficar invi\u00e1vel utilizarmos uma vari\u00e1vel para cada meteoro. Uma solu\u00e7\u00f5es (que j\u00e1 ajudaria muito), seria criarmos uma lista com todos os meteoros. O pygame define um novo tipo chamado pygame . sprite . Group , que \u00e9 como uma lista, mas que tem algumas funcionalidades adicionais. O jogo_v8 utiliza o pygame . sprite . Group para criar v\u00e1rios grupos de uma vez. As principais mudan\u00e7as neste arquivo s\u00e3o: referencia/jogo_v8.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random pygame . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets METEOR_WIDTH = 50 METEOR_HEIGHT = 38 font = pygame . font . SysFont ( None , 48 ) background = pygame . image . load ( 'assets/img/starfield.png' ) . convert () meteor_img = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () meteor_img = pygame . transform . scale ( meteor_img , ( METEOR_WIDTH , METEOR_HEIGHT )) # ----- Inicia estruturas de dados # Definindo os novos tipos class Meteor ( pygame . sprite . Sprite ): def __init__ ( self , img ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = img self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) game = True # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () FPS = 30 # Criando um grupo de meteoros all_meteors = pygame . sprite . Group () # Criando os meteoros for i in range ( 8 ): meteor = Meteor ( meteor_img ) all_meteors . add ( meteor ) # ===== Loop principal ===== while game : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : game = False # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o dos meteoros all_meteors . update () # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( background , ( 0 , 0 )) # Desenhando meteoros all_meteors . draw ( window ) pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados Linhas 54 a 58: cria\u00e7\u00e3o de um grupo de sprites e um for que cria e adiciona v\u00e1rios meteoros no grupo; Linha 72: atualiza todos os sprites de uma vez. Por tr\u00e1s dos panos o pygame percorre todos os sprites dentro daquele grupo e chama o m\u00e9todo update de cada um deles; Linha 78: desenha todos os sprites de uma vez. Por tr\u00e1s dos panos o pygame percorre todos os sprites, desenhando um por um. EXERC\u00cdCIO 8 \u00b6 Modifique o jogo_v8 . py para que ele tenha 15 meteoros ao inv\u00e9s de 8. Al\u00e9m disso, vamos come\u00e7ar a nos preparar para implementar o jogador. Crie uma nova classe chamada Ship que tamb\u00e9m estende o tipo pygame . sprite . Sprite com a imagem assets / img / playerShip1_orange . png . A nave n\u00e3o deve se mover (n\u00e3o precisa implementar o update ). Utilize os valores self . rect . centerx = WIDTH / 2 e self . rect . bottom = HEIGHT - 10 . Adicionando a nave \u00b6 O jogo_v9 . py adiciona a classe Ship e cria uma nave. Ainda n\u00e3o \u00e9 poss\u00edvel mover a nave, mas a classe j\u00e1 est\u00e1 preparada para isso. As principais mudan\u00e7as s\u00e3o: referencia/jogo_v9.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random pygame . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets METEOR_WIDTH = 50 METEOR_HEIGHT = 38 SHIP_WIDTH = 50 SHIP_HEIGHT = 38 font = pygame . font . SysFont ( None , 48 ) background = pygame . image . load ( 'assets/img/starfield.png' ) . convert () meteor_img = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () meteor_img = pygame . transform . scale ( meteor_img , ( METEOR_WIDTH , METEOR_HEIGHT )) ship_img = pygame . image . load ( 'assets/img/playerShip1_orange.png' ) . convert_alpha () ship_img = pygame . transform . scale ( ship_img , ( SHIP_WIDTH , SHIP_HEIGHT )) # ----- Inicia estruturas de dados # Definindo os novos tipos class Ship ( pygame . sprite . Sprite ): def __init__ ( self , img ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = img self . rect = self . image . get_rect () self . rect . centerx = WIDTH / 2 self . rect . bottom = HEIGHT - 10 self . speedx = 0 def update ( self ): # Atualiza\u00e7\u00e3o da posi\u00e7\u00e3o da nave self . rect . x += self . speedx # Mantem dentro da tela if self . rect . right > WIDTH : self . rect . right = WIDTH if self . rect . left < 0 : self . rect . left = 0 class Meteor ( pygame . sprite . Sprite ): def __init__ ( self , img ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = img self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) game = True # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () FPS = 30 # Criando um grupo de meteoros all_sprites = pygame . sprite . Group () # Criando o jogador player = Ship ( ship_img ) all_sprites . add ( player ) # Criando os meteoros for i in range ( 8 ): meteor = Meteor ( meteor_img ) all_sprites . add ( meteor ) # ===== Loop principal ===== while game : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : game = False # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o dos meteoros all_sprites . update () # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( background , ( 0 , 0 )) # Desenhando meteoros all_sprites . draw ( window ) pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados Linhas 23 e 24: carrega a imagem da nave e redimensiona para um tamanho menor; Linhas 28 a 47: define a classe Ship . O m\u00e9todo update atualiza a posi\u00e7\u00e3o x aplicando a velocidade e o if garante que a nave n\u00e3o saia da janela. Sempre que a nave sai da janela ela \u00e9 movida para dentro da janela novamente. Note que a nave ainda n\u00e3o vai se mover, pois a velocidade no eixo x \u00e9 zero. Al\u00e9m disso, n\u00e3o implementamos o movimento no eixo y, pois queremos que a nave apenas se mova para os lados; Linhas 79 a 82: mudan\u00e7a do nome do grupo para all_sprites , pois agora guardaremos todos os sprites nesse mesmo grupo. Uma nave \u00e9 criada e armazenada na vari\u00e1vel player . Esse player \u00e9 adicionado ao all_sprites , assim ao chamar all_sprites . update () e all_sprites . draw ( window ) , todos os meteoros e a nave ser\u00e3o atualizados e desenhados em um \u00fanico comando. EXERC\u00cdCIO 9 \u00b6 Modifique o jogo_v9 . py para que a nave se mova com velocidade 5 para a esquerda. Se quiser, fa\u00e7a o seguinte teste adicional. Comente os blocos do if e else do update da nave e veja o que acontece. Movimento da nave \u00b6 Finalmente vamos adicionar alguma intera\u00e7\u00e3o! Queremos que o jogador possa controlar o movimento da nave usando o teclado. Assim, quando ele apertar as setas do teclado para a esquerda ou para a direita, a nave deve se mover. Lembre-se que no in\u00edcio deste handout falamos que teclas apertadas s\u00e3o eventos. O tratamento de eventos \u00e9 uma das etapas do loop principal. At\u00e9 agora s\u00f3 utilizamos o tratamento de eventos para verificar se o usu\u00e1rio fechou a janela do jogo. O jogo_v10 . py adiciona o tratamento dos eventos das setas do teclado. As principais mudan\u00e7as est\u00e3o nas linhas 98 a 110. referencia/jogo_v10.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random pygame . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets METEOR_WIDTH = 50 METEOR_HEIGHT = 38 SHIP_WIDTH = 50 SHIP_HEIGHT = 38 font = pygame . font . SysFont ( None , 48 ) background = pygame . image . load ( 'assets/img/starfield.png' ) . convert () meteor_img = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () meteor_img = pygame . transform . scale ( meteor_img , ( METEOR_WIDTH , METEOR_HEIGHT )) ship_img = pygame . image . load ( 'assets/img/playerShip1_orange.png' ) . convert_alpha () ship_img = pygame . transform . scale ( ship_img , ( SHIP_WIDTH , SHIP_HEIGHT )) # ----- Inicia estruturas de dados # Definindo os novos tipos class Ship ( pygame . sprite . Sprite ): def __init__ ( self , img ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = img self . rect = self . image . get_rect () self . rect . centerx = WIDTH / 2 self . rect . bottom = HEIGHT - 10 self . speedx = 0 def update ( self ): # Atualiza\u00e7\u00e3o da posi\u00e7\u00e3o da nave self . rect . x += self . speedx # Mantem dentro da tela if self . rect . right > WIDTH : self . rect . right = WIDTH if self . rect . left < 0 : self . rect . left = 0 class Meteor ( pygame . sprite . Sprite ): def __init__ ( self , img ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = img self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) game = True # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () FPS = 30 # Criando um grupo de meteoros all_sprites = pygame . sprite . Group () # Criando o jogador player = Ship ( ship_img ) all_sprites . add ( player ) # Criando os meteoros for i in range ( 8 ): meteor = Meteor ( meteor_img ) all_sprites . add ( meteor ) # ===== Loop principal ===== while game : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : game = False # Verifica se apertou alguma tecla. if event . type == pygame . KEYDOWN : # Dependendo da tecla, altera a velocidade. if event . key == pygame . K_LEFT : player . speedx -= 8 if event . key == pygame . K_RIGHT : player . speedx += 8 # Verifica se soltou alguma tecla. if event . type == pygame . KEYUP : # Dependendo da tecla, altera a velocidade. if event . key == pygame . K_LEFT : player . speedx += 8 if event . key == pygame . K_RIGHT : player . speedx -= 8 # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o dos meteoros all_sprites . update () # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( background , ( 0 , 0 )) # Desenhando meteoros all_sprites . draw ( window ) pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados Quando o jogador aperta uma tecla (evento do tipo pygame . KEYDOWN ), se a tecla apertada for a seta para a direita ou para a esquerda, n\u00f3s aumentamos ou diminuimos a velocidade da nave. QUando o jogador solta a tecla (evento do tipo pygame . KEYUP ), se a tecla apertada for a seta para a direita ou para a esquerda, n\u00f3s desfazemos a a\u00e7\u00e3o daquela tecla (diminuir ou aumentar a velocidade da nave). Note que esses eventos s\u00f3 ocorrem no instante em que a tecla \u00e9 apertada. Se o jogador apertar a tecla e n\u00e3o soltar, o evento pygame . KEYDOWN s\u00f3 ser\u00e1 recebido uma vez e assim a velocidade s\u00f3 vai aumentar uma vez. EXERC\u00cdCIO 10 \u00b6 Modifique o jogo_v10 . py para que a nave se mova com metade da velocidade. Tratamento de colis\u00f5es da nave com os meteoros \u00b6 J\u00e1 podemos movimentar a nave, mas quando um meteoro encosta na nave, nada acontece. Queremos que o jogo acabe quando um meteoro encostar na nave. O jogo_v11 . py implementa essa funcionalidade. O pygame disponibiliza uma fun\u00e7\u00e3o que verifica se houve uma colis\u00e3o entre um sprite e um grupo de sprites, o pygame . sprite . spritecollide . Essa fun\u00e7\u00e3o recebe um sprite, um grupo de sprites e um valor booleano que indica se, ao ocorrer uma colis\u00e3o, o elemento do grupo que colidiu com o sprite deve morrer ou n\u00e3o (morrer nesse caso significa que o sprite deixar\u00e1 de existir). As principais mudan\u00e7as neste arquivo s\u00e3o: referencia/jogo_v11.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random pygame . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets METEOR_WIDTH = 50 METEOR_HEIGHT = 38 SHIP_WIDTH = 50 SHIP_HEIGHT = 38 font = pygame . font . SysFont ( None , 48 ) background = pygame . image . load ( 'assets/img/starfield.png' ) . convert () meteor_img = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () meteor_img = pygame . transform . scale ( meteor_img , ( METEOR_WIDTH , METEOR_HEIGHT )) ship_img = pygame . image . load ( 'assets/img/playerShip1_orange.png' ) . convert_alpha () ship_img = pygame . transform . scale ( ship_img , ( SHIP_WIDTH , SHIP_HEIGHT )) # ----- Inicia estruturas de dados # Definindo os novos tipos class Ship ( pygame . sprite . Sprite ): def __init__ ( self , img ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = img self . rect = self . image . get_rect () self . rect . centerx = WIDTH / 2 self . rect . bottom = HEIGHT - 10 self . speedx = 0 def update ( self ): # Atualiza\u00e7\u00e3o da posi\u00e7\u00e3o da nave self . rect . x += self . speedx # Mantem dentro da tela if self . rect . right > WIDTH : self . rect . right = WIDTH if self . rect . left < 0 : self . rect . left = 0 class Meteor ( pygame . sprite . Sprite ): def __init__ ( self , img ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = img self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) game = True # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () FPS = 30 # Criando um grupo de meteoros all_sprites = pygame . sprite . Group () all_meteors = pygame . sprite . Group () # Criando o jogador player = Ship ( ship_img ) all_sprites . add ( player ) # Criando os meteoros for i in range ( 8 ): meteor = Meteor ( meteor_img ) all_sprites . add ( meteor ) all_meteors . add ( meteor ) # ===== Loop principal ===== while game : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : game = False # Verifica se apertou alguma tecla. if event . type == pygame . KEYDOWN : # Dependendo da tecla, altera a velocidade. if event . key == pygame . K_LEFT : player . speedx -= 8 if event . key == pygame . K_RIGHT : player . speedx += 8 # Verifica se soltou alguma tecla. if event . type == pygame . KEYUP : # Dependendo da tecla, altera a velocidade. if event . key == pygame . K_LEFT : player . speedx += 8 if event . key == pygame . K_RIGHT : player . speedx -= 8 # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o dos meteoros all_sprites . update () # Verifica se houve colis\u00e3o entre nave e meteoro hits = pygame . sprite . spritecollide ( player , all_meteors , True ) # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( background , ( 0 , 0 )) # Desenhando meteoros all_sprites . draw ( window ) pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados Linhas 80 e 88: cria\u00e7\u00e3o de mais um grupo de sprites. Cada meteoro \u00e9 colocado em dois grupos, no grupo de todos os sprites ( all_sprites ), que \u00e9 utilizado para atualizar e desenhar todos os sprites na tela, e o grupo dos meteoros ( all_meteors ), que ser\u00e1 utilizado para verificar a colis\u00e3o da nave com todos os meteoros de uma vez; Linha 119: verifica a colis\u00e3o do player (nave) com o all_meteors . A fun\u00e7\u00e3o retorna uma lista com todos os meteoros que colidiram com a nave. Se ela n\u00e3o estiver vazia significa que houve uma colis\u00e3o. EXERC\u00cdCIO 11 \u00b6 A vers\u00e3o atual faz com que os meteoros morram ao encostar na nave, mas nada al\u00e9m disso acontece. Modifique o jogo_v11 . py para que o jogo acabe se a nave colidir com um meteoro (dica: basta verificar uma condi\u00e7\u00e3o e modificar game para False ). Fazendo a nave atirar \u00b6 Vamos implementar a funcionalidade de tiro. Queremos que um tiro seja criado quando o jogador apertar a tecla ESPA\u00c7O . Execute o jogo_v12 . py para ver o resultado. Depois abra o c\u00f3digo. referencia/jogo_v12.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random pygame . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets METEOR_WIDTH = 50 METEOR_HEIGHT = 38 SHIP_WIDTH = 50 SHIP_HEIGHT = 38 font = pygame . font . SysFont ( None , 48 ) background = pygame . image . load ( 'assets/img/starfield.png' ) . convert () meteor_img = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () meteor_img = pygame . transform . scale ( meteor_img , ( METEOR_WIDTH , METEOR_HEIGHT )) ship_img = pygame . image . load ( 'assets/img/playerShip1_orange.png' ) . convert_alpha () ship_img = pygame . transform . scale ( ship_img , ( SHIP_WIDTH , SHIP_HEIGHT )) bullet_img = pygame . image . load ( 'assets/img/laserRed16.png' ) . convert_alpha () # ----- Inicia estruturas de dados # Definindo os novos tipos class Ship ( pygame . sprite . Sprite ): def __init__ ( self , img , all_sprites , all_bullets , bullet_img ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = img self . rect = self . image . get_rect () self . rect . centerx = WIDTH / 2 self . rect . bottom = HEIGHT - 10 self . speedx = 0 self . all_sprites = all_sprites self . all_bullets = all_bullets self . bullet_img = bullet_img def update ( self ): # Atualiza\u00e7\u00e3o da posi\u00e7\u00e3o da nave self . rect . x += self . speedx # Mantem dentro da tela if self . rect . right > WIDTH : self . rect . right = WIDTH if self . rect . left < 0 : self . rect . left = 0 def shoot ( self ): # A nova bala vai ser criada logo acima e no centro horizontal da nave new_bullet = Bullet ( self . bullet_img , self . rect . top , self . rect . centerx ) self . all_sprites . add ( new_bullet ) self . all_bullets . add ( new_bullet ) class Meteor ( pygame . sprite . Sprite ): def __init__ ( self , img ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = img self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) # Classe Bullet que representa os tiros class Bullet ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , img , bottom , centerx ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = img self . rect = self . image . get_rect () # Coloca no lugar inicial definido em x, y do constutor self . rect . centerx = centerx self . rect . bottom = bottom self . speedy = - 10 # Velocidade fixa para cima def update ( self ): # A bala s\u00f3 se move no eixo y self . rect . y += self . speedy # Se o tiro passar do inicio da tela, morre. if self . rect . bottom < 0 : self . kill () game = True # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () FPS = 30 # Criando um grupo de meteoros all_sprites = pygame . sprite . Group () all_meteors = pygame . sprite . Group () all_bullets = pygame . sprite . Group () # Criando o jogador player = Ship ( ship_img , all_sprites , all_bullets , bullet_img ) all_sprites . add ( player ) # Criando os meteoros for i in range ( 8 ): meteor = Meteor ( meteor_img ) all_sprites . add ( meteor ) all_meteors . add ( meteor ) # ===== Loop principal ===== while game : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : game = False # Verifica se apertou alguma tecla. if event . type == pygame . KEYDOWN : # Dependendo da tecla, altera a velocidade. if event . key == pygame . K_LEFT : player . speedx -= 8 if event . key == pygame . K_RIGHT : player . speedx += 8 if event . key == pygame . K_SPACE : player . shoot () # Verifica se soltou alguma tecla. if event . type == pygame . KEYUP : # Dependendo da tecla, altera a velocidade. if event . key == pygame . K_LEFT : player . speedx += 8 if event . key == pygame . K_RIGHT : player . speedx -= 8 # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o dos meteoros all_sprites . update () # Verifica se houve colis\u00e3o entre nave e meteoro hits = pygame . sprite . spritecollide ( player , all_meteors , True ) if len ( hits ) > 0 : game = False # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( background , ( 0 , 0 )) # Desenhando meteoros all_sprites . draw ( window ) pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados Neste c\u00f3digo, criamos um sprite Bullet e um novo m\u00e9todo shoot na classe Ship . Esse m\u00e9todo ser\u00e1 chamado sempre que quisermos que a nave atire. O problema \u00e9 que o sprite precisa ser adicionado ao grupo de sprites para ser desenhado, mas como ele ser\u00e1 criado dentro do m\u00e9todo shoot , n\u00f3s n\u00e3o temos acesso \u00e0s vari\u00e1veis que est\u00e3o no nosso programa. A solu\u00e7\u00e3o para esse problema \u00e9 guardar o grupo dentro do jogador. Assim, quando ele atirar ele j\u00e1 ter\u00e1 acesso ao grupo para adicionar a nova bala. Fazemos isso modificando o __init__ (construtor) do Ship . Al\u00e9m da imagem da nave ele passar\u00e1 a receber o grupo de todos os sprites, um grupo para guardar as balas e a imagem da bala. Esses valores s\u00e3o guardados dentro da nave nas linhas 39 a 41. Esses valores s\u00e3o utilizados pelo m\u00e9todo shoot (linhas 53 a 57). As principais mudan\u00e7as nesta vers\u00e3o s\u00e3o: Linhas 30 e 39 a 41: quando \u00e9 criada, a nave recebe o grupo de sprites, o grupo de balas e a imagem da bala. Ela armazena esses valores nos atributos (vari\u00e1veis dispon\u00edveis no self ) para usar quando o shoot for chamado; Linhas 53 a 57: m\u00e9todo shoot . Esse m\u00e9todo ser\u00e1 chamado quando a tecla espa\u00e7o for apertada. Uma nova bala \u00e9 criada e adicionada nos grupos de sprites e de balas; Linhas 84 a 104: classe Bullet . Uma bala s\u00f3 se move para cima com velocidade 10. Quando ela n\u00e3o est\u00e1 mais vis\u00edvel ela morre ( self . kill () ); Linhas 114 e 116: um novo grupo de balas \u00e9 criado. O grupo de sprites, o grupo de balas e a imagem da bala s\u00e3o utilizadas para que um Ship seja criado. Esse Ship vai armazenar esses valores dentro de si mesmo; Linhas 140 e 141: quando a tecla ESPA\u00c7O \u00e9 apertada a nave atira. Note que n\u00e3o precisamos mudar as linhas que chamam o update dos sprites e que desenham ( draw ) todos os sprites, pois as balas tamb\u00e9m ser\u00e3o adicionadas no grupo de todos os sprites ( all_sprites ). EXERC\u00cdCIO 12 \u00b6 As balas ainda n\u00e3o tem nenhum efeito sobre os meteoros. Implemente a colis\u00e3o das balas com os meteoros. A fun\u00e7\u00e3o pygame . sprite . spritecollide verificava se um sprite havia colidido com algum sprite de um grupo . Agora queremos verificar se algum sprite do grupo de balas colidiu com algum sprite do grupo de meteoros. Para isso temos a fun\u00e7\u00e3o pygame . sprite . groupcollide , que recebe dois grupos de sprites e dois valores booleanos ( True ou False ) que indicam se um elemento do primeiro grupo deve morrer ao colidir com algum elemento do segundo grupo e vice-versa. Importante: essa fun\u00e7\u00e3o retorna um dicion\u00e1rio no qual as chaves s\u00e3o elementos do primeiro grupo (primeiro argumento da fun\u00e7\u00e3o) e os valores s\u00e3o listas de elementos do segundo grupo (segundo argumento) que colidiram com ele. Se esse dicion\u00e1rio estiver vazio significa que n\u00e3o houve nenhuma colis\u00e3o entre os dois grupos. Fa\u00e7a com que, ao colidirem, tanto a bala, quanto o meteoro morram. Voc\u00ea vai notar que depois de um tempo n\u00e3o haver\u00e1 mais nenhum meteoro. N\u00e3o se preocupe com isso por enquanto. Adicionando som \u00b6 O pygame tamb\u00e9m \u00e9 capaz de tocar sons. Para isso, al\u00e9m de carregar os arquivos de \u00e1udio, \u00e9 necess\u00e1rio inicializar o uso de sons no pygame com a fun\u00e7\u00e3o pygame . mixer . init () . O jogo_v13 . py implementa os sons de explos\u00e3o e tiro da nave. As principais modifica\u00e7\u00f5es s\u00e3o: referencia/jogo_v13.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random import time pygame . init () pygame . mixer . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets METEOR_WIDTH = 50 METEOR_HEIGHT = 38 SHIP_WIDTH = 50 SHIP_HEIGHT = 38 font = pygame . font . SysFont ( None , 48 ) background = pygame . image . load ( 'assets/img/starfield.png' ) . convert () meteor_img = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () meteor_img = pygame . transform . scale ( meteor_img , ( METEOR_WIDTH , METEOR_HEIGHT )) ship_img = pygame . image . load ( 'assets/img/playerShip1_orange.png' ) . convert_alpha () ship_img = pygame . transform . scale ( ship_img , ( SHIP_WIDTH , SHIP_HEIGHT )) bullet_img = pygame . image . load ( 'assets/img/laserRed16.png' ) . convert_alpha () # Carrega os sons do jogo pygame . mixer . music . load ( 'assets/snd/tgfcoder-FrozenJam-SeamlessLoop.ogg' ) pygame . mixer . music . set_volume ( 0.4 ) boom_sound = pygame . mixer . Sound ( 'assets/snd/expl3.wav' ) destroy_sound = pygame . mixer . Sound ( 'assets/snd/expl6.wav' ) pew_sound = pygame . mixer . Sound ( 'assets/snd/pew.wav' ) # ----- Inicia estruturas de dados # Definindo os novos tipos class Ship ( pygame . sprite . Sprite ): def __init__ ( self , img , all_sprites , all_bullets , bullet_img , pew_sound ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = img self . rect = self . image . get_rect () self . rect . centerx = WIDTH / 2 self . rect . bottom = HEIGHT - 10 self . speedx = 0 self . all_sprites = all_sprites self . all_bullets = all_bullets self . bullet_img = bullet_img self . pew_sound = pew_sound def update ( self ): # Atualiza\u00e7\u00e3o da posi\u00e7\u00e3o da nave self . rect . x += self . speedx # Mantem dentro da tela if self . rect . right > WIDTH : self . rect . right = WIDTH if self . rect . left < 0 : self . rect . left = 0 def shoot ( self ): # A nova bala vai ser criada logo acima e no centro horizontal da nave new_bullet = Bullet ( self . bullet_img , self . rect . top , self . rect . centerx ) self . all_sprites . add ( new_bullet ) self . all_bullets . add ( new_bullet ) self . pew_sound . play () class Meteor ( pygame . sprite . Sprite ): def __init__ ( self , img ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = img self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) # Classe Bullet que representa os tiros class Bullet ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , img , bottom , centerx ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = img self . rect = self . image . get_rect () # Coloca no lugar inicial definido em x, y do constutor self . rect . centerx = centerx self . rect . bottom = bottom self . speedy = - 10 # Velocidade fixa para cima def update ( self ): # A bala s\u00f3 se move no eixo y self . rect . y += self . speedy # Se o tiro passar do inicio da tela, morre. if self . rect . bottom < 0 : self . kill () game = True # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () FPS = 30 # Criando um grupo de meteoros all_sprites = pygame . sprite . Group () all_meteors = pygame . sprite . Group () all_bullets = pygame . sprite . Group () # Criando o jogador player = Ship ( ship_img , all_sprites , all_bullets , bullet_img , pew_sound ) all_sprites . add ( player ) # Criando os meteoros for i in range ( 8 ): meteor = Meteor ( meteor_img ) all_sprites . add ( meteor ) all_meteors . add ( meteor ) # ===== Loop principal ===== pygame . mixer . music . play ( loops =- 1 ) while game : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : game = False # Verifica se apertou alguma tecla. if event . type == pygame . KEYDOWN : # Dependendo da tecla, altera a velocidade. if event . key == pygame . K_LEFT : player . speedx -= 8 if event . key == pygame . K_RIGHT : player . speedx += 8 if event . key == pygame . K_SPACE : player . shoot () # Verifica se soltou alguma tecla. if event . type == pygame . KEYUP : # Dependendo da tecla, altera a velocidade. if event . key == pygame . K_LEFT : player . speedx += 8 if event . key == pygame . K_RIGHT : player . speedx -= 8 # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o dos meteoros all_sprites . update () # Verifica se houve colis\u00e3o entre tiro e meteoro hits = pygame . sprite . groupcollide ( all_meteors , all_bullets , True , True ) for meteor in hits : # As chaves s\u00e3o os elementos do primeiro grupo (meteoros) que colidiram com alguma bala # O meteoro e destruido e precisa ser recriado m = Meteor ( meteor_img ) all_sprites . add ( m ) all_meteors . add ( m ) # Verifica se houve colis\u00e3o entre nave e meteoro hits = pygame . sprite . spritecollide ( player , all_meteors , True ) if len ( hits ) > 0 : # Toca o som da colis\u00e3o boom_sound . play () time . sleep ( 1 ) # Precisa esperar sen\u00e3o fecha game = False # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( background , ( 0 , 0 )) # Desenhando meteoros all_sprites . draw ( window ) pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados Linha 8: inicializa\u00e7\u00e3o do m\u00f3dulo de \u00e1udio do pygame; Linhas 30 a 34: carrega os arquivos de \u00e1udio; Linhas 39 e 51: Ship recebe o som do tiro como argumento extra e armazena como atributo; Linha 68: toca o som do tiro; Linha 136: come\u00e7a a tocar o som de fundo em loop; Linhas 167 a 172: implementa o exerc\u00edcio 12. Verifica as colis\u00f5es entre todos os meteoros e todas as balas. Para cada meteoro que colidiu \u00e9 criado um novo meteoro para substitu\u00ed-lo; Linhas 178 e 179: toca o som de explos\u00e3o da nave e espera 1 segundo para o som terminar de tocar antes de finalizar o jogo. EXERC\u00cdCIO 13 \u00b6 Modifique o jogo_v13 . py para tocar o destroy_sound sempre que um meteoro for destru\u00eddo. Refatorando mais uma vez o c\u00f3digo \u00b6 O c\u00f3digo j\u00e1 est\u00e1 bastante complexo. Lembrando que \u00e9 sempre uma boa pr\u00e1tica tomar um tempo para melhorar o c\u00f3digo antes que ele se torne um caos completo, vamos refator\u00e1-lo mais um pouco. Um dos problemas \u00e9 a quantidade de argumentos que precisamos passar quando criamos um Ship (e tudo isso s\u00f3 por causa do tiro). Al\u00e9m disso, temos diversas vari\u00e1veis para as imagens e sons que carregamos. No arquivo jogo_v14 . py adicionamos todos os assets em um novo dicion\u00e1rio assets e os grupos em um dicion\u00e1rio groups . Agora \u00e9 poss\u00edvel diminuir a quantidade de argumentos recebidos na constru\u00e7\u00e3o do Ship sem ser necess\u00e1rio carregar os assets todas as vezes. referencia/jogo_v14.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random import time pygame . init () pygame . mixer . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets METEOR_WIDTH = 50 METEOR_HEIGHT = 38 SHIP_WIDTH = 50 SHIP_HEIGHT = 38 assets = {} assets [ 'background' ] = pygame . image . load ( 'assets/img/starfield.png' ) . convert () assets [ 'meteor_img' ] = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () assets [ 'meteor_img' ] = pygame . transform . scale ( assets [ 'meteor_img' ], ( METEOR_WIDTH , METEOR_HEIGHT )) assets [ 'ship_img' ] = pygame . image . load ( 'assets/img/playerShip1_orange.png' ) . convert_alpha () assets [ 'ship_img' ] = pygame . transform . scale ( assets [ 'ship_img' ], ( SHIP_WIDTH , SHIP_HEIGHT )) assets [ 'bullet_img' ] = pygame . image . load ( 'assets/img/laserRed16.png' ) . convert_alpha () # Carrega os sons do jogo pygame . mixer . music . load ( 'assets/snd/tgfcoder-FrozenJam-SeamlessLoop.ogg' ) pygame . mixer . music . set_volume ( 0.4 ) boom_sound = pygame . mixer . Sound ( 'assets/snd/expl3.wav' ) destroy_sound = pygame . mixer . Sound ( 'assets/snd/expl6.wav' ) assets [ 'pew_sound' ] = pygame . mixer . Sound ( 'assets/snd/pew.wav' ) # ----- Inicia estruturas de dados # Definindo os novos tipos class Ship ( pygame . sprite . Sprite ): def __init__ ( self , groups , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'ship_img' ] self . rect = self . image . get_rect () self . rect . centerx = WIDTH / 2 self . rect . bottom = HEIGHT - 10 self . speedx = 0 self . groups = groups self . assets = assets def update ( self ): # Atualiza\u00e7\u00e3o da posi\u00e7\u00e3o da nave self . rect . x += self . speedx # Mantem dentro da tela if self . rect . right > WIDTH : self . rect . right = WIDTH if self . rect . left < 0 : self . rect . left = 0 def shoot ( self ): # A nova bala vai ser criada logo acima e no centro horizontal da nave new_bullet = Bullet ( self . assets , self . rect . top , self . rect . centerx ) self . groups [ 'all_sprites' ] . add ( new_bullet ) self . groups [ 'all_bullets' ] . add ( new_bullet ) self . assets [ 'pew_sound' ] . play () class Meteor ( pygame . sprite . Sprite ): def __init__ ( self , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'meteor_img' ] self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) # Classe Bullet que representa os tiros class Bullet ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , assets , bottom , centerx ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'bullet_img' ] self . rect = self . image . get_rect () # Coloca no lugar inicial definido em x, y do constutor self . rect . centerx = centerx self . rect . bottom = bottom self . speedy = - 10 # Velocidade fixa para cima def update ( self ): # A bala s\u00f3 se move no eixo y self . rect . y += self . speedy # Se o tiro passar do inicio da tela, morre. if self . rect . bottom < 0 : self . kill () game = True # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () FPS = 30 # Criando um grupo de meteoros all_sprites = pygame . sprite . Group () all_meteors = pygame . sprite . Group () all_bullets = pygame . sprite . Group () groups = {} groups [ 'all_sprites' ] = all_sprites groups [ 'all_meteors' ] = all_meteors groups [ 'all_bullets' ] = all_bullets # Criando o jogador player = Ship ( groups , assets ) all_sprites . add ( player ) # Criando os meteoros for i in range ( 8 ): meteor = Meteor ( assets ) all_sprites . add ( meteor ) all_meteors . add ( meteor ) # ===== Loop principal ===== pygame . mixer . music . play ( loops =- 1 ) while game : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : game = False # Verifica se apertou alguma tecla. if event . type == pygame . KEYDOWN : # Dependendo da tecla, altera a velocidade. if event . key == pygame . K_LEFT : player . speedx -= 8 if event . key == pygame . K_RIGHT : player . speedx += 8 if event . key == pygame . K_SPACE : player . shoot () # Verifica se soltou alguma tecla. if event . type == pygame . KEYUP : # Dependendo da tecla, altera a velocidade. if event . key == pygame . K_LEFT : player . speedx += 8 if event . key == pygame . K_RIGHT : player . speedx -= 8 # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o dos meteoros all_sprites . update () # Verifica se houve colis\u00e3o entre tiro e meteoro hits = pygame . sprite . groupcollide ( all_meteors , all_bullets , True , True ) for meteor in hits : # As chaves s\u00e3o os elementos do primeiro grupo (meteoros) que colidiram com alguma bala # O meteoro e destruido e precisa ser recriado destroy_sound . play () m = Meteor ( assets ) all_sprites . add ( m ) all_meteors . add ( m ) # Verifica se houve colis\u00e3o entre nave e meteoro hits = pygame . sprite . spritecollide ( player , all_meteors , True ) if len ( hits ) > 0 : # Toca o som da colis\u00e3o boom_sound . play () time . sleep ( 1 ) # Precisa esperar sen\u00e3o fecha game = False # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( assets [ 'background' ], ( 0 , 0 )) # Desenhando meteoros all_sprites . draw ( window ) pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados EXERC\u00cdCIO 14 \u00b6 Os sons boom_sound e destroy_sound ainda n\u00e3o est\u00e3o armazenados em assets . Para manter a consist\u00eancia, adicione-os no dicion\u00e1rio e atualize o c\u00f3digo necess\u00e1rio (onde esses sons s\u00e3o tocados). Adicionando anima\u00e7\u00f5es \u00b6 As imagens do nosso jogo ainda s\u00e3o muito est\u00e1ticas. Elas se movem pela tela, mas s\u00e3o sempre as mesmas. Vamos adicionar uma anima\u00e7\u00e3o de explos\u00e3o. Para isso, vamos criar um novo sprite que atualiza a imagem em intervalos fixos de tempo. O jogo_v15 . py implementa essa anima\u00e7\u00e3o. As principais mudan\u00e7as s\u00e3o: referencia/jogo_v15.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random import time pygame . init () pygame . mixer . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets METEOR_WIDTH = 50 METEOR_HEIGHT = 38 SHIP_WIDTH = 50 SHIP_HEIGHT = 38 assets = {} assets [ 'background' ] = pygame . image . load ( 'assets/img/starfield.png' ) . convert () assets [ 'meteor_img' ] = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () assets [ 'meteor_img' ] = pygame . transform . scale ( assets [ 'meteor_img' ], ( METEOR_WIDTH , METEOR_HEIGHT )) assets [ 'ship_img' ] = pygame . image . load ( 'assets/img/playerShip1_orange.png' ) . convert_alpha () assets [ 'ship_img' ] = pygame . transform . scale ( assets [ 'ship_img' ], ( SHIP_WIDTH , SHIP_HEIGHT )) assets [ 'bullet_img' ] = pygame . image . load ( 'assets/img/laserRed16.png' ) . convert_alpha () explosion_anim = [] for i in range ( 9 ): # Os arquivos de anima\u00e7\u00e3o s\u00e3o numerados de 00 a 08 filename = 'assets/img/regularExplosion0 {} .png' . format ( i ) img = pygame . image . load ( filename ) . convert () img = pygame . transform . scale ( img , ( 32 , 32 )) explosion_anim . append ( img ) assets [ \"explosion_anim\" ] = explosion_anim # Carrega os sons do jogo pygame . mixer . music . load ( 'assets/snd/tgfcoder-FrozenJam-SeamlessLoop.ogg' ) pygame . mixer . music . set_volume ( 0.4 ) assets [ 'boom_sound' ] = pygame . mixer . Sound ( 'assets/snd/expl3.wav' ) assets [ 'destroy_sound' ] = pygame . mixer . Sound ( 'assets/snd/expl6.wav' ) assets [ 'pew_sound' ] = pygame . mixer . Sound ( 'assets/snd/pew.wav' ) # ----- Inicia estruturas de dados # Definindo os novos tipos class Ship ( pygame . sprite . Sprite ): def __init__ ( self , groups , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'ship_img' ] self . rect = self . image . get_rect () self . rect . centerx = WIDTH / 2 self . rect . bottom = HEIGHT - 10 self . speedx = 0 self . groups = groups self . assets = assets def update ( self ): # Atualiza\u00e7\u00e3o da posi\u00e7\u00e3o da nave self . rect . x += self . speedx # Mantem dentro da tela if self . rect . right > WIDTH : self . rect . right = WIDTH if self . rect . left < 0 : self . rect . left = 0 def shoot ( self ): # A nova bala vai ser criada logo acima e no centro horizontal da nave new_bullet = Bullet ( self . assets , self . rect . top , self . rect . centerx ) self . groups [ 'all_sprites' ] . add ( new_bullet ) self . groups [ 'all_bullets' ] . add ( new_bullet ) self . assets [ 'pew_sound' ] . play () class Meteor ( pygame . sprite . Sprite ): def __init__ ( self , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'meteor_img' ] self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) # Classe Bullet que representa os tiros class Bullet ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , assets , bottom , centerx ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'bullet_img' ] self . rect = self . image . get_rect () # Coloca no lugar inicial definido em x, y do constutor self . rect . centerx = centerx self . rect . bottom = bottom self . speedy = - 10 # Velocidade fixa para cima def update ( self ): # A bala s\u00f3 se move no eixo y self . rect . y += self . speedy # Se o tiro passar do inicio da tela, morre. if self . rect . bottom < 0 : self . kill () # Classe que representa uma explos\u00e3o de meteoro class Explosion ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , center , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) # Armazena a anima\u00e7\u00e3o de explos\u00e3o self . explosion_anim = assets [ 'explosion_anim' ] # Inicia o processo de anima\u00e7\u00e3o colocando a primeira imagem na tela. self . frame = 0 # Armazena o \u00edndice atual na anima\u00e7\u00e3o self . image = self . explosion_anim [ self . frame ] # Pega a primeira imagem self . rect = self . image . get_rect () self . rect . center = center # Posiciona o centro da imagem # Guarda o tick da primeira imagem, ou seja, o momento em que a imagem foi mostrada self . last_update = pygame . time . get_ticks () # Controle de ticks de anima\u00e7\u00e3o: troca de imagem a cada self.frame_ticks milissegundos. # Quando pygame.time.get_ticks() - self.last_update > self.frame_ticks a # pr\u00f3xima imagem da anima\u00e7\u00e3o ser\u00e1 mostrada self . frame_ticks = 50 def update ( self ): # Verifica o tick atual. now = pygame . time . get_ticks () # Verifica quantos ticks se passaram desde a ultima mudan\u00e7a de frame. elapsed_ticks = now - self . last_update # Se j\u00e1 est\u00e1 na hora de mudar de imagem... if elapsed_ticks > self . frame_ticks : # Marca o tick da nova imagem. self . last_update = now # Avan\u00e7a um quadro. self . frame += 1 # Verifica se j\u00e1 chegou no final da anima\u00e7\u00e3o. if self . frame == len ( self . explosion_anim ): # Se sim, tchau explos\u00e3o! self . kill () else : # Se ainda n\u00e3o chegou ao fim da explos\u00e3o, troca de imagem. center = self . rect . center self . image = self . explosion_anim [ self . frame ] self . rect = self . image . get_rect () self . rect . center = center game = True # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () FPS = 30 # Criando um grupo de meteoros all_sprites = pygame . sprite . Group () all_meteors = pygame . sprite . Group () all_bullets = pygame . sprite . Group () groups = {} groups [ 'all_sprites' ] = all_sprites groups [ 'all_meteors' ] = all_meteors groups [ 'all_bullets' ] = all_bullets # Criando o jogador player = Ship ( groups , assets ) all_sprites . add ( player ) # Criando os meteoros for i in range ( 8 ): meteor = Meteor ( assets ) all_sprites . add ( meteor ) all_meteors . add ( meteor ) # ===== Loop principal ===== pygame . mixer . music . play ( loops =- 1 ) while game : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : game = False # Verifica se apertou alguma tecla. if event . type == pygame . KEYDOWN : # Dependendo da tecla, altera a velocidade. if event . key == pygame . K_LEFT : player . speedx -= 8 if event . key == pygame . K_RIGHT : player . speedx += 8 if event . key == pygame . K_SPACE : player . shoot () # Verifica se soltou alguma tecla. if event . type == pygame . KEYUP : # Dependendo da tecla, altera a velocidade. if event . key == pygame . K_LEFT : player . speedx += 8 if event . key == pygame . K_RIGHT : player . speedx -= 8 # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o dos meteoros all_sprites . update () # Verifica se houve colis\u00e3o entre tiro e meteoro hits = pygame . sprite . groupcollide ( all_meteors , all_bullets , True , True ) for meteor in hits : # As chaves s\u00e3o os elementos do primeiro grupo (meteoros) que colidiram com alguma bala # O meteoro e destruido e precisa ser recriado assets [ 'destroy_sound' ] . play () m = Meteor ( assets ) all_sprites . add ( m ) all_meteors . add ( m ) # No lugar do meteoro antigo, adicionar uma explos\u00e3o. explosao = Explosion ( meteor . rect . center , assets ) all_sprites . add ( explosao ) # Verifica se houve colis\u00e3o entre nave e meteoro hits = pygame . sprite . spritecollide ( player , all_meteors , True ) if len ( hits ) > 0 : # Toca o som da colis\u00e3o assets [ 'boom_sound' ] . play () time . sleep ( 1 ) # Precisa esperar sen\u00e3o fecha game = False # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( assets [ 'background' ], ( 0 , 0 )) # Desenhando meteoros all_sprites . draw ( window ) pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados Linhas 28 a 35: carrega as imagens da anima\u00e7\u00e3o da explos\u00e3o e guarda em uma lista. Adiciona a lista no dicion\u00e1rio assets ; Linhas 124 a 170: classe Explosion : Linha 131: armazena a lista de imagens da anima\u00e7\u00e3o em um atributo. Uma anima\u00e7\u00e3o nada mais \u00e9 que uma sucess\u00e3o de imagens mostradas em um intervalo curto de tempo; Linhas 134 a 137: coloca a primeira imagem da anima\u00e7\u00e3o no atributo self . image e define sua posi\u00e7\u00e3o; Linha 140: armazena o instante de tempo atual. Depois que passar self . frame_ticks milissegundos a partir desse instante a pr\u00f3xima imagem ser\u00e1 mostrada; Linhas 154 a 170: m\u00e9todo de atualiza\u00e7\u00e3o. Verifica se j\u00e1 se passaram self . frame_ticks milissegundos desde que a \u00faltima imagem foi mostrada. Em caso afirmativo, mostra a pr\u00f3xima imagem. Se j\u00e1 n\u00e3o existem mais imagens para mostrar, mata o sprite. Linhas 236 e 237: cria o sprite de anima\u00e7\u00e3o de explos\u00e3o no mesmo lugar onde um meteoro foi explodido. EXERC\u00cdCIO 15 \u00b6 Limite os tiros da nave a um tiro a cada 500 milissegundos. Dica: a l\u00f3gica ser\u00e1 semelhante \u00e0 decis\u00e3o de mostrar a pr\u00f3xima imagem da anima\u00e7\u00e3o (a resposta estar\u00e1 no jogo_v16 . py ). Adicionando estados \u00b6 Agora os meteoros est\u00e3o bem legais, mas e a nave? Vamos agora introduzir um truque super \u00fatil para jogos (e v\u00e1rios outros programas de computador): a m\u00e1quina de estados . Com uma m\u00e1quina de estados, o programa apresenta comportamentos diferentes para cada estados. Esse \u00e9 apenas o nome que damos para uma forma de estruturar o nosso c\u00f3digo. Na pr\u00e1tica voc\u00ea vai perceber que essa modifica\u00e7\u00e3o n\u00e3o passa de um conjunto de ifs . No nosso jogo teremos a princ\u00edpio 3 estados: DONE : o jogo terminou; PLAYING : o jogador est\u00e1 jogando; EXPLODING : a nave est\u00e1 explodindo. Nesse estado o jogador n\u00e3o pode fazer nada (se ele apertar alguma coisa no teclado nada vai acontecer). A mudan\u00e7a para m\u00e1quina de estados foi aplicada no jogo_v16 . py . Observe que no novo arquivo mudamos o mecanismo do loop de jogo. Antes us\u00e1vamos uma vari\u00e1vel booleana para indicar se o jogo estava rodando ou n\u00e3o. Agora temos uma vari\u00e1vel com um n\u00famero inteiro que indica em qual estado estamos: rodando o jogo normalmente, estado de explos\u00e3o da nave, ou se o jogo acabou. As principais mudan\u00e7as s\u00e3o: referencia/jogo_v16.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random pygame . init () pygame . mixer . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets METEOR_WIDTH = 50 METEOR_HEIGHT = 38 SHIP_WIDTH = 50 SHIP_HEIGHT = 38 assets = {} assets [ 'background' ] = pygame . image . load ( 'assets/img/starfield.png' ) . convert () assets [ 'meteor_img' ] = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () assets [ 'meteor_img' ] = pygame . transform . scale ( assets [ 'meteor_img' ], ( METEOR_WIDTH , METEOR_HEIGHT )) assets [ 'ship_img' ] = pygame . image . load ( 'assets/img/playerShip1_orange.png' ) . convert_alpha () assets [ 'ship_img' ] = pygame . transform . scale ( assets [ 'ship_img' ], ( SHIP_WIDTH , SHIP_HEIGHT )) assets [ 'bullet_img' ] = pygame . image . load ( 'assets/img/laserRed16.png' ) . convert_alpha () explosion_anim = [] for i in range ( 9 ): # Os arquivos de anima\u00e7\u00e3o s\u00e3o numerados de 00 a 08 filename = 'assets/img/regularExplosion0 {} .png' . format ( i ) img = pygame . image . load ( filename ) . convert () img = pygame . transform . scale ( img , ( 32 , 32 )) explosion_anim . append ( img ) assets [ \"explosion_anim\" ] = explosion_anim # Carrega os sons do jogo pygame . mixer . music . load ( 'assets/snd/tgfcoder-FrozenJam-SeamlessLoop.ogg' ) pygame . mixer . music . set_volume ( 0.4 ) assets [ 'boom_sound' ] = pygame . mixer . Sound ( 'assets/snd/expl3.wav' ) assets [ 'destroy_sound' ] = pygame . mixer . Sound ( 'assets/snd/expl6.wav' ) assets [ 'pew_sound' ] = pygame . mixer . Sound ( 'assets/snd/pew.wav' ) # ----- Inicia estruturas de dados # Definindo os novos tipos class Ship ( pygame . sprite . Sprite ): def __init__ ( self , groups , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'ship_img' ] self . rect = self . image . get_rect () self . rect . centerx = WIDTH / 2 self . rect . bottom = HEIGHT - 10 self . speedx = 0 self . groups = groups self . assets = assets # S\u00f3 ser\u00e1 poss\u00edvel atirar uma vez a cada 500 milissegundos self . last_shot = pygame . time . get_ticks () self . shoot_ticks = 500 def update ( self ): # Atualiza\u00e7\u00e3o da posi\u00e7\u00e3o da nave self . rect . x += self . speedx # Mantem dentro da tela if self . rect . right > WIDTH : self . rect . right = WIDTH if self . rect . left < 0 : self . rect . left = 0 def shoot ( self ): # Verifica se pode atirar now = pygame . time . get_ticks () # Verifica quantos ticks se passaram desde o \u00faltimo tiro. elapsed_ticks = now - self . last_shot # Se j\u00e1 pode atirar novamente... if elapsed_ticks > self . shoot_ticks : # Marca o tick da nova imagem. self . last_shot = now # A nova bala vai ser criada logo acima e no centro horizontal da nave new_bullet = Bullet ( self . assets , self . rect . top , self . rect . centerx ) self . groups [ 'all_sprites' ] . add ( new_bullet ) self . groups [ 'all_bullets' ] . add ( new_bullet ) self . assets [ 'pew_sound' ] . play () class Meteor ( pygame . sprite . Sprite ): def __init__ ( self , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'meteor_img' ] self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) # Classe Bullet que representa os tiros class Bullet ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , assets , bottom , centerx ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'bullet_img' ] self . rect = self . image . get_rect () # Coloca no lugar inicial definido em x, y do constutor self . rect . centerx = centerx self . rect . bottom = bottom self . speedy = - 10 # Velocidade fixa para cima def update ( self ): # A bala s\u00f3 se move no eixo y self . rect . y += self . speedy # Se o tiro passar do inicio da tela, morre. if self . rect . bottom < 0 : self . kill () # Classe que representa uma explos\u00e3o de meteoro class Explosion ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , center , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) # Armazena a anima\u00e7\u00e3o de explos\u00e3o self . explosion_anim = assets [ 'explosion_anim' ] # Inicia o processo de anima\u00e7\u00e3o colocando a primeira imagem na tela. self . frame = 0 # Armazena o \u00edndice atual na anima\u00e7\u00e3o self . image = self . explosion_anim [ self . frame ] # Pega a primeira imagem self . rect = self . image . get_rect () self . rect . center = center # Posiciona o centro da imagem # Guarda o tick da primeira imagem, ou seja, o momento em que a imagem foi mostrada self . last_update = pygame . time . get_ticks () # Controle de ticks de anima\u00e7\u00e3o: troca de imagem a cada self.frame_ticks milissegundos. # Quando pygame.time.get_ticks() - self.last_update > self.frame_ticks a # pr\u00f3xima imagem da anima\u00e7\u00e3o ser\u00e1 mostrada self . frame_ticks = 50 def update ( self ): # Verifica o tick atual. now = pygame . time . get_ticks () # Verifica quantos ticks se passaram desde a ultima mudan\u00e7a de frame. elapsed_ticks = now - self . last_update # Se j\u00e1 est\u00e1 na hora de mudar de imagem... if elapsed_ticks > self . frame_ticks : # Marca o tick da nova imagem. self . last_update = now # Avan\u00e7a um quadro. self . frame += 1 # Verifica se j\u00e1 chegou no final da anima\u00e7\u00e3o. if self . frame == len ( self . explosion_anim ): # Se sim, tchau explos\u00e3o! self . kill () else : # Se ainda n\u00e3o chegou ao fim da explos\u00e3o, troca de imagem. center = self . rect . center self . image = self . explosion_anim [ self . frame ] self . rect = self . image . get_rect () self . rect . center = center # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () FPS = 30 # Criando um grupo de meteoros all_sprites = pygame . sprite . Group () all_meteors = pygame . sprite . Group () all_bullets = pygame . sprite . Group () groups = {} groups [ 'all_sprites' ] = all_sprites groups [ 'all_meteors' ] = all_meteors groups [ 'all_bullets' ] = all_bullets # Criando o jogador player = Ship ( groups , assets ) all_sprites . add ( player ) # Criando os meteoros for i in range ( 8 ): meteor = Meteor ( assets ) all_sprites . add ( meteor ) all_meteors . add ( meteor ) DONE = 0 PLAYING = 1 EXPLODING = 2 state = PLAYING # ===== Loop principal ===== pygame . mixer . music . play ( loops =- 1 ) while state != DONE : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : state = DONE # S\u00f3 verifica o teclado se est\u00e1 no estado de jogo if state == PLAYING : # Verifica se apertou alguma tecla. if event . type == pygame . KEYDOWN : # Dependendo da tecla, altera a velocidade. if event . key == pygame . K_LEFT : player . speedx -= 8 if event . key == pygame . K_RIGHT : player . speedx += 8 if event . key == pygame . K_SPACE : player . shoot () # Verifica se soltou alguma tecla. if event . type == pygame . KEYUP : # Dependendo da tecla, altera a velocidade. if event . key == pygame . K_LEFT : player . speedx += 8 if event . key == pygame . K_RIGHT : player . speedx -= 8 # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o dos meteoros all_sprites . update () if state == PLAYING : # Verifica se houve colis\u00e3o entre tiro e meteoro hits = pygame . sprite . groupcollide ( all_meteors , all_bullets , True , True ) for meteor in hits : # As chaves s\u00e3o os elementos do primeiro grupo (meteoros) que colidiram com alguma bala # O meteoro e destruido e precisa ser recriado assets [ 'destroy_sound' ] . play () m = Meteor ( assets ) all_sprites . add ( m ) all_meteors . add ( m ) # No lugar do meteoro antigo, adicionar uma explos\u00e3o. explosao = Explosion ( meteor . rect . center , assets ) all_sprites . add ( explosao ) # Verifica se houve colis\u00e3o entre nave e meteoro hits = pygame . sprite . spritecollide ( player , all_meteors , True ) if len ( hits ) > 0 : # Toca o som da colis\u00e3o assets [ 'boom_sound' ] . play () player . kill () explosao = Explosion ( player . rect . center , assets ) all_sprites . add ( explosao ) state = EXPLODING explosion_tick = pygame . time . get_ticks () explosion_duration = explosao . frame_ticks * len ( explosao . explosion_anim ) + 400 elif state == EXPLODING : now = pygame . time . get_ticks () if now - explosion_tick > explosion_duration : state = DONE # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( assets [ 'background' ], ( 0 , 0 )) # Desenhando meteoros all_sprites . draw ( window ) pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados Linhas 59, 60 e 74 a 81: resposta do exerc\u00edcio 15; Linhas 206 a 209: definindo constantes com o valor de cada estado (poderia ser qualquer valor) e definindo o estado inicial como PLAYING . Note que apagamos a vari\u00e1vel game do c\u00f3digo inteiro; Linha 213: condi\u00e7\u00e3o do loop principal depende do estado. O jogo para quando state \u00e9 igual a DONE , ou seja, 0 ; Linha 220: muda o estado para DONE se o jogador apertou no X para fechar a janela; Linha 222: s\u00f3 aplica as consequ\u00eancias de eventos de teclado se o estado for PLAYING ; Linha 244: verifica colis\u00f5es apenas se o estado for PLAYING ; Linhas 263 a 265: mata a nave (para ela sumir) e cria uma explos\u00e3o no lugar; Linhas 266 a 268: muda o estado para EXPLODING e armazena o instante de tempo em que esse estado come\u00e7ou. A vari\u00e1vel explosion_duration guarda a dura\u00e7\u00e3o da anima\u00e7\u00e3o de explos\u00e3o com um adicional de 400 milissegundos; Linhas 269 a 272: se o estado for EXPLODING verifica se j\u00e1 passou o tempo necess\u00e1rio para a anima\u00e7\u00e3o da explos\u00e3o e depois termina o jogo (muda o estado para DONE ). Note que com o uso da m\u00e1quina de estados n\u00e3o precisamos mais do time . sleep ( 1 ) para esperar antes do jogo terminar. EXERC\u00cdCIO 16 \u00b6 Modifique o jogo_v16 . py para que o jogo nunca acabe, ou seja, depois que a nave termina de explodir ela ressurge na posi\u00e7\u00e3o inicial (a resposta estar\u00e1 no jogo_v17 . py ). Adicionando um placar \u00b6 Vamos utilizar uma fonte com jeit\u00e3o de arcade dos anos 80. J\u00e1 vimos como desenhar texto na tela, ent\u00e3o juntando esses conhecimentos podemos mostrar o placar ao longo do jogo. O jogo_v17 . py implementa essa funcionalidade. As principais mudan\u00e7as s\u00e3o: referencia/jogo_v17.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random pygame . init () pygame . mixer . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets METEOR_WIDTH = 50 METEOR_HEIGHT = 38 SHIP_WIDTH = 50 SHIP_HEIGHT = 38 assets = {} assets [ 'background' ] = pygame . image . load ( 'assets/img/starfield.png' ) . convert () assets [ 'meteor_img' ] = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () assets [ 'meteor_img' ] = pygame . transform . scale ( assets [ 'meteor_img' ], ( METEOR_WIDTH , METEOR_HEIGHT )) assets [ 'ship_img' ] = pygame . image . load ( 'assets/img/playerShip1_orange.png' ) . convert_alpha () assets [ 'ship_img' ] = pygame . transform . scale ( assets [ 'ship_img' ], ( SHIP_WIDTH , SHIP_HEIGHT )) assets [ 'bullet_img' ] = pygame . image . load ( 'assets/img/laserRed16.png' ) . convert_alpha () explosion_anim = [] for i in range ( 9 ): # Os arquivos de anima\u00e7\u00e3o s\u00e3o numerados de 00 a 08 filename = 'assets/img/regularExplosion0 {} .png' . format ( i ) img = pygame . image . load ( filename ) . convert () img = pygame . transform . scale ( img , ( 32 , 32 )) explosion_anim . append ( img ) assets [ \"explosion_anim\" ] = explosion_anim assets [ \"score_font\" ] = pygame . font . Font ( 'assets/font/PressStart2P.ttf' , 28 ) # Carrega os sons do jogo pygame . mixer . music . load ( 'assets/snd/tgfcoder-FrozenJam-SeamlessLoop.ogg' ) pygame . mixer . music . set_volume ( 0.4 ) assets [ 'boom_sound' ] = pygame . mixer . Sound ( 'assets/snd/expl3.wav' ) assets [ 'destroy_sound' ] = pygame . mixer . Sound ( 'assets/snd/expl6.wav' ) assets [ 'pew_sound' ] = pygame . mixer . Sound ( 'assets/snd/pew.wav' ) # ----- Inicia estruturas de dados # Definindo os novos tipos class Ship ( pygame . sprite . Sprite ): def __init__ ( self , groups , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'ship_img' ] self . rect = self . image . get_rect () self . rect . centerx = WIDTH / 2 self . rect . bottom = HEIGHT - 10 self . speedx = 0 self . groups = groups self . assets = assets # S\u00f3 ser\u00e1 poss\u00edvel atirar uma vez a cada 500 milissegundos self . last_shot = pygame . time . get_ticks () self . shoot_ticks = 500 def update ( self ): # Atualiza\u00e7\u00e3o da posi\u00e7\u00e3o da nave self . rect . x += self . speedx # Mantem dentro da tela if self . rect . right > WIDTH : self . rect . right = WIDTH if self . rect . left < 0 : self . rect . left = 0 def shoot ( self ): # Verifica se pode atirar now = pygame . time . get_ticks () # Verifica quantos ticks se passaram desde o \u00faltimo tiro. elapsed_ticks = now - self . last_shot # Se j\u00e1 pode atirar novamente... if elapsed_ticks > self . shoot_ticks : # Marca o tick da nova imagem. self . last_shot = now # A nova bala vai ser criada logo acima e no centro horizontal da nave new_bullet = Bullet ( self . assets , self . rect . top , self . rect . centerx ) self . groups [ 'all_sprites' ] . add ( new_bullet ) self . groups [ 'all_bullets' ] . add ( new_bullet ) self . assets [ 'pew_sound' ] . play () class Meteor ( pygame . sprite . Sprite ): def __init__ ( self , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'meteor_img' ] self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) # Classe Bullet que representa os tiros class Bullet ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , assets , bottom , centerx ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'bullet_img' ] self . rect = self . image . get_rect () # Coloca no lugar inicial definido em x, y do constutor self . rect . centerx = centerx self . rect . bottom = bottom self . speedy = - 10 # Velocidade fixa para cima def update ( self ): # A bala s\u00f3 se move no eixo y self . rect . y += self . speedy # Se o tiro passar do inicio da tela, morre. if self . rect . bottom < 0 : self . kill () # Classe que representa uma explos\u00e3o de meteoro class Explosion ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , center , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) # Armazena a anima\u00e7\u00e3o de explos\u00e3o self . explosion_anim = assets [ 'explosion_anim' ] # Inicia o processo de anima\u00e7\u00e3o colocando a primeira imagem na tela. self . frame = 0 # Armazena o \u00edndice atual na anima\u00e7\u00e3o self . image = self . explosion_anim [ self . frame ] # Pega a primeira imagem self . rect = self . image . get_rect () self . rect . center = center # Posiciona o centro da imagem # Guarda o tick da primeira imagem, ou seja, o momento em que a imagem foi mostrada self . last_update = pygame . time . get_ticks () # Controle de ticks de anima\u00e7\u00e3o: troca de imagem a cada self.frame_ticks milissegundos. # Quando pygame.time.get_ticks() - self.last_update > self.frame_ticks a # pr\u00f3xima imagem da anima\u00e7\u00e3o ser\u00e1 mostrada self . frame_ticks = 50 def update ( self ): # Verifica o tick atual. now = pygame . time . get_ticks () # Verifica quantos ticks se passaram desde a ultima mudan\u00e7a de frame. elapsed_ticks = now - self . last_update # Se j\u00e1 est\u00e1 na hora de mudar de imagem... if elapsed_ticks > self . frame_ticks : # Marca o tick da nova imagem. self . last_update = now # Avan\u00e7a um quadro. self . frame += 1 # Verifica se j\u00e1 chegou no final da anima\u00e7\u00e3o. if self . frame == len ( self . explosion_anim ): # Se sim, tchau explos\u00e3o! self . kill () else : # Se ainda n\u00e3o chegou ao fim da explos\u00e3o, troca de imagem. center = self . rect . center self . image = self . explosion_anim [ self . frame ] self . rect = self . image . get_rect () self . rect . center = center # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () FPS = 30 # Criando um grupo de meteoros all_sprites = pygame . sprite . Group () all_meteors = pygame . sprite . Group () all_bullets = pygame . sprite . Group () groups = {} groups [ 'all_sprites' ] = all_sprites groups [ 'all_meteors' ] = all_meteors groups [ 'all_bullets' ] = all_bullets # Criando o jogador player = Ship ( groups , assets ) all_sprites . add ( player ) # Criando os meteoros for i in range ( 8 ): meteor = Meteor ( assets ) all_sprites . add ( meteor ) all_meteors . add ( meteor ) DONE = 0 PLAYING = 1 EXPLODING = 2 state = PLAYING score = 0 keys_down = {} # ===== Loop principal ===== pygame . mixer . music . play ( loops =- 1 ) while state != DONE : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : state = DONE # S\u00f3 verifica o teclado se est\u00e1 no estado de jogo if state == PLAYING : # Verifica se apertou alguma tecla. if event . type == pygame . KEYDOWN : # Dependendo da tecla, altera a velocidade. keys_down [ event . key ] = True if event . key == pygame . K_LEFT : player . speedx -= 8 if event . key == pygame . K_RIGHT : player . speedx += 8 if event . key == pygame . K_SPACE : player . shoot () # Verifica se soltou alguma tecla. if event . type == pygame . KEYUP : # Dependendo da tecla, altera a velocidade. if event . key in keys_down and keys_down [ event . key ]: if event . key == pygame . K_LEFT : player . speedx += 8 if event . key == pygame . K_RIGHT : player . speedx -= 8 # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o dos meteoros all_sprites . update () if state == PLAYING : # Verifica se houve colis\u00e3o entre tiro e meteoro hits = pygame . sprite . groupcollide ( all_meteors , all_bullets , True , True ) for meteor in hits : # As chaves s\u00e3o os elementos do primeiro grupo (meteoros) que colidiram com alguma bala # O meteoro e destruido e precisa ser recriado assets [ 'destroy_sound' ] . play () m = Meteor ( assets ) all_sprites . add ( m ) all_meteors . add ( m ) # No lugar do meteoro antigo, adicionar uma explos\u00e3o. explosao = Explosion ( meteor . rect . center , assets ) all_sprites . add ( explosao ) # Ganhou pontos! score += 100 # Verifica se houve colis\u00e3o entre nave e meteoro hits = pygame . sprite . spritecollide ( player , all_meteors , True ) if len ( hits ) > 0 : # Toca o som da colis\u00e3o assets [ 'boom_sound' ] . play () player . kill () explosao = Explosion ( player . rect . center , assets ) all_sprites . add ( explosao ) state = EXPLODING keys_down = {} explosion_tick = pygame . time . get_ticks () explosion_duration = explosao . frame_ticks * len ( explosao . explosion_anim ) + 400 elif state == EXPLODING : now = pygame . time . get_ticks () if now - explosion_tick > explosion_duration : state = PLAYING player = Ship ( groups , assets ) all_sprites . add ( player ) # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( assets [ 'background' ], ( 0 , 0 )) # Desenhando meteoros all_sprites . draw ( window ) # Desenhando o score text_surface = assets [ 'score_font' ] . render ( \" {:08d} \" . format ( score ), True , ( 255 , 255 , 0 )) text_rect = text_surface . get_rect () text_rect . midtop = ( WIDTH / 2 , 10 ) window . blit ( text_surface , text_rect ) pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados Linha 35: carrega a fonte que ser\u00e1 utilizada para mostrar o placar; Linhas 212 e 265: inicializa o placar com 0 . Toda vez que um meteoro explode o jogador ganha 100 pontos; Linhas 213, 230, 240 e 276: cria um dicion\u00e1rio de teclas que guarda se uma tecla estava pressionada ou n\u00e3o. Quando ocorre um evento de tecla levantada ( pygame . KEYUP ), verifica se essa tecla estava previamente pressionada. Isso \u00e9 necess\u00e1rio para evitar um problema quando a nave explode enquanto uma tecla est\u00e1 apertada. Nesse caso, quando a nave \u00e9 recriada e o jogador solta a tecla seria aplicada uma velocidade contr\u00e1ria. Por esse motivo, na linha 276 o dicion\u00e1rio \u00e9 apagado quando o estado muda para EXPLODING ; Linhas 282 a 284: resposta do exerc\u00edcio 16; Linhas 293 a 296: desenha o placar. EXERC\u00cdCIO 17 \u00b6 Modifique o jogo_v17 . py para que o placar seja zerado quando a nave explode. Sistema de vidas \u00b6 O jogo_v18 . py implementa um sistema de vidas. O jogador ter\u00e1 3 vidas. Depois que morrer 3 vezes o jogo termina. As principais mudan\u00e7as s\u00e3o: referencia/jogo_v18.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random pygame . init () pygame . mixer . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets METEOR_WIDTH = 50 METEOR_HEIGHT = 38 SHIP_WIDTH = 50 SHIP_HEIGHT = 38 assets = {} assets [ 'background' ] = pygame . image . load ( 'assets/img/starfield.png' ) . convert () assets [ 'meteor_img' ] = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () assets [ 'meteor_img' ] = pygame . transform . scale ( assets [ 'meteor_img' ], ( METEOR_WIDTH , METEOR_HEIGHT )) assets [ 'ship_img' ] = pygame . image . load ( 'assets/img/playerShip1_orange.png' ) . convert_alpha () assets [ 'ship_img' ] = pygame . transform . scale ( assets [ 'ship_img' ], ( SHIP_WIDTH , SHIP_HEIGHT )) assets [ 'bullet_img' ] = pygame . image . load ( 'assets/img/laserRed16.png' ) . convert_alpha () explosion_anim = [] for i in range ( 9 ): # Os arquivos de anima\u00e7\u00e3o s\u00e3o numerados de 00 a 08 filename = 'assets/img/regularExplosion0 {} .png' . format ( i ) img = pygame . image . load ( filename ) . convert () img = pygame . transform . scale ( img , ( 32 , 32 )) explosion_anim . append ( img ) assets [ \"explosion_anim\" ] = explosion_anim assets [ \"score_font\" ] = pygame . font . Font ( 'assets/font/PressStart2P.ttf' , 28 ) # Carrega os sons do jogo pygame . mixer . music . load ( 'assets/snd/tgfcoder-FrozenJam-SeamlessLoop.ogg' ) pygame . mixer . music . set_volume ( 0.4 ) assets [ 'boom_sound' ] = pygame . mixer . Sound ( 'assets/snd/expl3.wav' ) assets [ 'destroy_sound' ] = pygame . mixer . Sound ( 'assets/snd/expl6.wav' ) assets [ 'pew_sound' ] = pygame . mixer . Sound ( 'assets/snd/pew.wav' ) # ----- Inicia estruturas de dados # Definindo os novos tipos class Ship ( pygame . sprite . Sprite ): def __init__ ( self , groups , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'ship_img' ] self . rect = self . image . get_rect () self . rect . centerx = WIDTH / 2 self . rect . bottom = HEIGHT - 10 self . speedx = 0 self . groups = groups self . assets = assets # S\u00f3 ser\u00e1 poss\u00edvel atirar uma vez a cada 500 milissegundos self . last_shot = pygame . time . get_ticks () self . shoot_ticks = 500 def update ( self ): # Atualiza\u00e7\u00e3o da posi\u00e7\u00e3o da nave self . rect . x += self . speedx # Mantem dentro da tela if self . rect . right > WIDTH : self . rect . right = WIDTH if self . rect . left < 0 : self . rect . left = 0 def shoot ( self ): # Verifica se pode atirar now = pygame . time . get_ticks () # Verifica quantos ticks se passaram desde o \u00faltimo tiro. elapsed_ticks = now - self . last_shot # Se j\u00e1 pode atirar novamente... if elapsed_ticks > self . shoot_ticks : # Marca o tick da nova imagem. self . last_shot = now # A nova bala vai ser criada logo acima e no centro horizontal da nave new_bullet = Bullet ( self . assets , self . rect . top , self . rect . centerx ) self . groups [ 'all_sprites' ] . add ( new_bullet ) self . groups [ 'all_bullets' ] . add ( new_bullet ) self . assets [ 'pew_sound' ] . play () class Meteor ( pygame . sprite . Sprite ): def __init__ ( self , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'meteor_img' ] self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) # Classe Bullet que representa os tiros class Bullet ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , assets , bottom , centerx ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'bullet_img' ] self . rect = self . image . get_rect () # Coloca no lugar inicial definido em x, y do constutor self . rect . centerx = centerx self . rect . bottom = bottom self . speedy = - 10 # Velocidade fixa para cima def update ( self ): # A bala s\u00f3 se move no eixo y self . rect . y += self . speedy # Se o tiro passar do inicio da tela, morre. if self . rect . bottom < 0 : self . kill () # Classe que representa uma explos\u00e3o de meteoro class Explosion ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , center , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) # Armazena a anima\u00e7\u00e3o de explos\u00e3o self . explosion_anim = assets [ 'explosion_anim' ] # Inicia o processo de anima\u00e7\u00e3o colocando a primeira imagem na tela. self . frame = 0 # Armazena o \u00edndice atual na anima\u00e7\u00e3o self . image = self . explosion_anim [ self . frame ] # Pega a primeira imagem self . rect = self . image . get_rect () self . rect . center = center # Posiciona o centro da imagem # Guarda o tick da primeira imagem, ou seja, o momento em que a imagem foi mostrada self . last_update = pygame . time . get_ticks () # Controle de ticks de anima\u00e7\u00e3o: troca de imagem a cada self.frame_ticks milissegundos. # Quando pygame.time.get_ticks() - self.last_update > self.frame_ticks a # pr\u00f3xima imagem da anima\u00e7\u00e3o ser\u00e1 mostrada self . frame_ticks = 50 def update ( self ): # Verifica o tick atual. now = pygame . time . get_ticks () # Verifica quantos ticks se passaram desde a ultima mudan\u00e7a de frame. elapsed_ticks = now - self . last_update # Se j\u00e1 est\u00e1 na hora de mudar de imagem... if elapsed_ticks > self . frame_ticks : # Marca o tick da nova imagem. self . last_update = now # Avan\u00e7a um quadro. self . frame += 1 # Verifica se j\u00e1 chegou no final da anima\u00e7\u00e3o. if self . frame == len ( self . explosion_anim ): # Se sim, tchau explos\u00e3o! self . kill () else : # Se ainda n\u00e3o chegou ao fim da explos\u00e3o, troca de imagem. center = self . rect . center self . image = self . explosion_anim [ self . frame ] self . rect = self . image . get_rect () self . rect . center = center # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () FPS = 30 # Criando um grupo de meteoros all_sprites = pygame . sprite . Group () all_meteors = pygame . sprite . Group () all_bullets = pygame . sprite . Group () groups = {} groups [ 'all_sprites' ] = all_sprites groups [ 'all_meteors' ] = all_meteors groups [ 'all_bullets' ] = all_bullets # Criando o jogador player = Ship ( groups , assets ) all_sprites . add ( player ) # Criando os meteoros for i in range ( 8 ): meteor = Meteor ( assets ) all_sprites . add ( meteor ) all_meteors . add ( meteor ) DONE = 0 PLAYING = 1 EXPLODING = 2 state = PLAYING keys_down = {} score = 0 lives = 3 # ===== Loop principal ===== pygame . mixer . music . play ( loops =- 1 ) while state != DONE : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : state = DONE # S\u00f3 verifica o teclado se est\u00e1 no estado de jogo if state == PLAYING : # Verifica se apertou alguma tecla. if event . type == pygame . KEYDOWN : # Dependendo da tecla, altera a velocidade. keys_down [ event . key ] = True if event . key == pygame . K_LEFT : player . speedx -= 8 if event . key == pygame . K_RIGHT : player . speedx += 8 if event . key == pygame . K_SPACE : player . shoot () # Verifica se soltou alguma tecla. if event . type == pygame . KEYUP : # Dependendo da tecla, altera a velocidade. if event . key in keys_down and keys_down [ event . key ]: if event . key == pygame . K_LEFT : player . speedx += 8 if event . key == pygame . K_RIGHT : player . speedx -= 8 # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o dos meteoros all_sprites . update () if state == PLAYING : # Verifica se houve colis\u00e3o entre tiro e meteoro hits = pygame . sprite . groupcollide ( all_meteors , all_bullets , True , True ) for meteor in hits : # As chaves s\u00e3o os elementos do primeiro grupo (meteoros) que colidiram com alguma bala # O meteoro e destruido e precisa ser recriado assets [ 'destroy_sound' ] . play () m = Meteor ( assets ) all_sprites . add ( m ) all_meteors . add ( m ) # No lugar do meteoro antigo, adicionar uma explos\u00e3o. explosao = Explosion ( meteor . rect . center , assets ) all_sprites . add ( explosao ) # Ganhou pontos! score += 100 # Verifica se houve colis\u00e3o entre nave e meteoro hits = pygame . sprite . spritecollide ( player , all_meteors , True ) if len ( hits ) > 0 : # Toca o som da colis\u00e3o assets [ 'boom_sound' ] . play () player . kill () lives -= 1 explosao = Explosion ( player . rect . center , assets ) all_sprites . add ( explosao ) state = EXPLODING keys_down = {} explosion_tick = pygame . time . get_ticks () explosion_duration = explosao . frame_ticks * len ( explosao . explosion_anim ) + 400 elif state == EXPLODING : now = pygame . time . get_ticks () if now - explosion_tick > explosion_duration : if lives == 0 : state = DONE else : state = PLAYING player = Ship ( groups , assets ) all_sprites . add ( player ) # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( assets [ 'background' ], ( 0 , 0 )) # Desenhando meteoros all_sprites . draw ( window ) # Desenhando o score text_surface = assets [ 'score_font' ] . render ( \" {:08d} \" . format ( score ), True , ( 255 , 255 , 0 )) text_rect = text_surface . get_rect () text_rect . midtop = ( WIDTH / 2 , 10 ) window . blit ( text_surface , text_rect ) # Desenhando as vidas text_surface = assets [ 'score_font' ] . render ( chr ( 9829 ) * lives , True , ( 255 , 0 , 0 )) text_rect = text_surface . get_rect () text_rect . bottomleft = ( 10 , HEIGHT - 10 ) window . blit ( text_surface , text_rect ) pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados Linhas 214 e 274: inicializa o n\u00famero de vidas com 3 e diminui toda vez que a nave explode; Linhas 284 a 286: se a quantidade de vidas chegar a zero o jogo termina; Linhas 304 a 307: desenha as vidas. EXERC\u00cdCIO 18 \u00b6 Modifique o jogo_v18 . py para que o jogador ganhe automaticamente uma vida a cada 1.000 pontos. A resposta estar\u00e1 no jogo_v19 . py . Melhorando a colis\u00e3o \u00b6 Talvez voc\u00ea tenha percebido que a colis\u00e3o entre sprites nem sempre \u00e9 muito boa. Isso acontece porque as colis\u00f5es s\u00e3o feitas por padr\u00e3o entre as imagens, ou seja, entre os ret\u00e2ngulos (mesmo que sejam transparentes). O jogo_v19 . py utiliza uma fun\u00e7\u00e3o mais precisa de colis\u00e3o. Para isso \u00e9 necess\u00e1rio criar m\u00e1scaras de colis\u00e3o. Uma m\u00e1scara de colis\u00e3o \u00e9 uma imagem na qual os valores iguais a zero ser\u00e3o ignorados no teste de colis\u00e3o. Para utilizar a colis\u00e3o entre m\u00e1scaras \u00e9 necess\u00e1rio que o sprite possua um atributo mask . As principais mudan\u00e7as s\u00e3o: referencia/jogo_v19.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random pygame . init () pygame . mixer . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets METEOR_WIDTH = 50 METEOR_HEIGHT = 38 SHIP_WIDTH = 50 SHIP_HEIGHT = 38 assets = {} assets [ 'background' ] = pygame . image . load ( 'assets/img/starfield.png' ) . convert () assets [ 'meteor_img' ] = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () assets [ 'meteor_img' ] = pygame . transform . scale ( assets [ 'meteor_img' ], ( METEOR_WIDTH , METEOR_HEIGHT )) assets [ 'ship_img' ] = pygame . image . load ( 'assets/img/playerShip1_orange.png' ) . convert_alpha () assets [ 'ship_img' ] = pygame . transform . scale ( assets [ 'ship_img' ], ( SHIP_WIDTH , SHIP_HEIGHT )) assets [ 'bullet_img' ] = pygame . image . load ( 'assets/img/laserRed16.png' ) . convert_alpha () explosion_anim = [] for i in range ( 9 ): # Os arquivos de anima\u00e7\u00e3o s\u00e3o numerados de 00 a 08 filename = 'assets/img/regularExplosion0 {} .png' . format ( i ) img = pygame . image . load ( filename ) . convert () img = pygame . transform . scale ( img , ( 32 , 32 )) explosion_anim . append ( img ) assets [ \"explosion_anim\" ] = explosion_anim assets [ \"score_font\" ] = pygame . font . Font ( 'assets/font/PressStart2P.ttf' , 28 ) # Carrega os sons do jogo pygame . mixer . music . load ( 'assets/snd/tgfcoder-FrozenJam-SeamlessLoop.ogg' ) pygame . mixer . music . set_volume ( 0.4 ) assets [ 'boom_sound' ] = pygame . mixer . Sound ( 'assets/snd/expl3.wav' ) assets [ 'destroy_sound' ] = pygame . mixer . Sound ( 'assets/snd/expl6.wav' ) assets [ 'pew_sound' ] = pygame . mixer . Sound ( 'assets/snd/pew.wav' ) # ----- Inicia estruturas de dados # Definindo os novos tipos class Ship ( pygame . sprite . Sprite ): def __init__ ( self , groups , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'ship_img' ] self . mask = pygame . mask . from_surface ( self . image ) self . rect = self . image . get_rect () self . rect . centerx = WIDTH / 2 self . rect . bottom = HEIGHT - 10 self . speedx = 0 self . groups = groups self . assets = assets # S\u00f3 ser\u00e1 poss\u00edvel atirar uma vez a cada 500 milissegundos self . last_shot = pygame . time . get_ticks () self . shoot_ticks = 500 def update ( self ): # Atualiza\u00e7\u00e3o da posi\u00e7\u00e3o da nave self . rect . x += self . speedx # Mantem dentro da tela if self . rect . right > WIDTH : self . rect . right = WIDTH if self . rect . left < 0 : self . rect . left = 0 def shoot ( self ): # Verifica se pode atirar now = pygame . time . get_ticks () # Verifica quantos ticks se passaram desde o \u00faltimo tiro. elapsed_ticks = now - self . last_shot # Se j\u00e1 pode atirar novamente... if elapsed_ticks > self . shoot_ticks : # Marca o tick da nova imagem. self . last_shot = now # A nova bala vai ser criada logo acima e no centro horizontal da nave new_bullet = Bullet ( self . assets , self . rect . top , self . rect . centerx ) self . groups [ 'all_sprites' ] . add ( new_bullet ) self . groups [ 'all_bullets' ] . add ( new_bullet ) self . assets [ 'pew_sound' ] . play () class Meteor ( pygame . sprite . Sprite ): def __init__ ( self , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'meteor_img' ] self . mask = pygame . mask . from_surface ( self . image ) self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) # Classe Bullet que representa os tiros class Bullet ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , assets , bottom , centerx ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'bullet_img' ] self . mask = pygame . mask . from_surface ( self . image ) self . rect = self . image . get_rect () # Coloca no lugar inicial definido em x, y do constutor self . rect . centerx = centerx self . rect . bottom = bottom self . speedy = - 10 # Velocidade fixa para cima def update ( self ): # A bala s\u00f3 se move no eixo y self . rect . y += self . speedy # Se o tiro passar do inicio da tela, morre. if self . rect . bottom < 0 : self . kill () # Classe que representa uma explos\u00e3o de meteoro class Explosion ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , center , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) # Armazena a anima\u00e7\u00e3o de explos\u00e3o self . explosion_anim = assets [ 'explosion_anim' ] # Inicia o processo de anima\u00e7\u00e3o colocando a primeira imagem na tela. self . frame = 0 # Armazena o \u00edndice atual na anima\u00e7\u00e3o self . image = self . explosion_anim [ self . frame ] # Pega a primeira imagem self . rect = self . image . get_rect () self . rect . center = center # Posiciona o centro da imagem # Guarda o tick da primeira imagem, ou seja, o momento em que a imagem foi mostrada self . last_update = pygame . time . get_ticks () # Controle de ticks de anima\u00e7\u00e3o: troca de imagem a cada self.frame_ticks milissegundos. # Quando pygame.time.get_ticks() - self.last_update > self.frame_ticks a # pr\u00f3xima imagem da anima\u00e7\u00e3o ser\u00e1 mostrada self . frame_ticks = 50 def update ( self ): # Verifica o tick atual. now = pygame . time . get_ticks () # Verifica quantos ticks se passaram desde a ultima mudan\u00e7a de frame. elapsed_ticks = now - self . last_update # Se j\u00e1 est\u00e1 na hora de mudar de imagem... if elapsed_ticks > self . frame_ticks : # Marca o tick da nova imagem. self . last_update = now # Avan\u00e7a um quadro. self . frame += 1 # Verifica se j\u00e1 chegou no final da anima\u00e7\u00e3o. if self . frame == len ( self . explosion_anim ): # Se sim, tchau explos\u00e3o! self . kill () else : # Se ainda n\u00e3o chegou ao fim da explos\u00e3o, troca de imagem. center = self . rect . center self . image = self . explosion_anim [ self . frame ] self . rect = self . image . get_rect () self . rect . center = center # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () FPS = 30 # Criando um grupo de meteoros all_sprites = pygame . sprite . Group () all_meteors = pygame . sprite . Group () all_bullets = pygame . sprite . Group () groups = {} groups [ 'all_sprites' ] = all_sprites groups [ 'all_meteors' ] = all_meteors groups [ 'all_bullets' ] = all_bullets # Criando o jogador player = Ship ( groups , assets ) all_sprites . add ( player ) # Criando os meteoros for i in range ( 8 ): meteor = Meteor ( assets ) all_sprites . add ( meteor ) all_meteors . add ( meteor ) DONE = 0 PLAYING = 1 EXPLODING = 2 state = PLAYING keys_down = {} score = 0 lives = 3 # ===== Loop principal ===== pygame . mixer . music . play ( loops =- 1 ) while state != DONE : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : state = DONE # S\u00f3 verifica o teclado se est\u00e1 no estado de jogo if state == PLAYING : # Verifica se apertou alguma tecla. if event . type == pygame . KEYDOWN : # Dependendo da tecla, altera a velocidade. keys_down [ event . key ] = True if event . key == pygame . K_LEFT : player . speedx -= 8 if event . key == pygame . K_RIGHT : player . speedx += 8 if event . key == pygame . K_SPACE : player . shoot () # Verifica se soltou alguma tecla. if event . type == pygame . KEYUP : # Dependendo da tecla, altera a velocidade. if event . key in keys_down and keys_down [ event . key ]: if event . key == pygame . K_LEFT : player . speedx += 8 if event . key == pygame . K_RIGHT : player . speedx -= 8 # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o dos meteoros all_sprites . update () if state == PLAYING : # Verifica se houve colis\u00e3o entre tiro e meteoro hits = pygame . sprite . groupcollide ( all_meteors , all_bullets , True , True , pygame . sprite . collide_mask ) for meteor in hits : # As chaves s\u00e3o os elementos do primeiro grupo (meteoros) que colidiram com alguma bala # O meteoro e destruido e precisa ser recriado assets [ 'destroy_sound' ] . play () m = Meteor ( assets ) all_sprites . add ( m ) all_meteors . add ( m ) # No lugar do meteoro antigo, adicionar uma explos\u00e3o. explosao = Explosion ( meteor . rect . center , assets ) all_sprites . add ( explosao ) # Ganhou pontos! score += 100 if score % 1000 == 0 : lives += 1 # Verifica se houve colis\u00e3o entre nave e meteoro hits = pygame . sprite . spritecollide ( player , all_meteors , True , pygame . sprite . collide_mask ) if len ( hits ) > 0 : # Toca o som da colis\u00e3o assets [ 'boom_sound' ] . play () player . kill () lives -= 1 explosao = Explosion ( player . rect . center , assets ) all_sprites . add ( explosao ) state = EXPLODING keys_down = {} explosion_tick = pygame . time . get_ticks () explosion_duration = explosao . frame_ticks * len ( explosao . explosion_anim ) + 400 elif state == EXPLODING : now = pygame . time . get_ticks () if now - explosion_tick > explosion_duration : if lives == 0 : state = DONE else : state = PLAYING player = Ship ( groups , assets ) all_sprites . add ( player ) # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( assets [ 'background' ], ( 0 , 0 )) # Desenhando meteoros all_sprites . draw ( window ) # Desenhando o score text_surface = assets [ 'score_font' ] . render ( \" {:08d} \" . format ( score ), True , ( 255 , 255 , 0 )) text_rect = text_surface . get_rect () text_rect . midtop = ( WIDTH / 2 , 10 ) window . blit ( text_surface , text_rect ) # Desenhando as vidas text_surface = assets [ 'score_font' ] . render ( chr ( 9829 ) * lives , True , ( 255 , 0 , 0 )) text_rect = text_surface . get_rect () text_rect . bottomleft = ( 10 , HEIGHT - 10 ) window . blit ( text_surface , text_rect ) pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados Linhas 52, 96 e 123: cria as m\u00e1scaras de colis\u00e3o a partir da imagem do sprite; Linhas 256 e 274: define que as colis\u00f5es devem ser realizadas usando m\u00e1scaras; Linhas 270 e 271: resposta do exerc\u00edcio 18. Separando o c\u00f3digo em mais fun\u00e7\u00f5es \u00b6 Este c\u00f3digo est\u00e1 ficando muito grande! Est\u00e1 na hora de quebrar esse monolito em fun\u00e7\u00f5es simples. Isso vai facilitar o desenvolvimento de novas telas de jogo. O jogo_v20 . py cria as fun\u00e7\u00f5es load_assets e game_screen que extraem o carregamento dos assets e a l\u00f3gica do jogo. Nessa vers\u00e3o n\u00e3o existe nenhuma mudan\u00e7a, visualmente falando, mas essa refatora\u00e7\u00e3o vai ser bastante \u00fatil para o pr\u00f3ximo passo. Principais mudan\u00e7as: referencia/jogo_v20.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random pygame . init () pygame . mixer . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets FPS = 30 METEOR_WIDTH = 50 METEOR_HEIGHT = 38 SHIP_WIDTH = 50 SHIP_HEIGHT = 38 def load_assets (): assets = {} assets [ 'background' ] = pygame . image . load ( 'assets/img/starfield.png' ) . convert () assets [ 'meteor_img' ] = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () assets [ 'meteor_img' ] = pygame . transform . scale ( assets [ 'meteor_img' ], ( METEOR_WIDTH , METEOR_HEIGHT )) assets [ 'ship_img' ] = pygame . image . load ( 'assets/img/playerShip1_orange.png' ) . convert_alpha () assets [ 'ship_img' ] = pygame . transform . scale ( assets [ 'ship_img' ], ( SHIP_WIDTH , SHIP_HEIGHT )) assets [ 'bullet_img' ] = pygame . image . load ( 'assets/img/laserRed16.png' ) . convert_alpha () explosion_anim = [] for i in range ( 9 ): # Os arquivos de anima\u00e7\u00e3o s\u00e3o numerados de 00 a 08 filename = 'assets/img/regularExplosion0 {} .png' . format ( i ) img = pygame . image . load ( filename ) . convert () img = pygame . transform . scale ( img , ( 32 , 32 )) explosion_anim . append ( img ) assets [ \"explosion_anim\" ] = explosion_anim assets [ \"score_font\" ] = pygame . font . Font ( 'assets/font/PressStart2P.ttf' , 28 ) # Carrega os sons do jogo pygame . mixer . music . load ( 'assets/snd/tgfcoder-FrozenJam-SeamlessLoop.ogg' ) pygame . mixer . music . set_volume ( 0.4 ) assets [ 'boom_sound' ] = pygame . mixer . Sound ( 'assets/snd/expl3.wav' ) assets [ 'destroy_sound' ] = pygame . mixer . Sound ( 'assets/snd/expl6.wav' ) assets [ 'pew_sound' ] = pygame . mixer . Sound ( 'assets/snd/pew.wav' ) return assets # ----- Inicia estruturas de dados # Definindo os novos tipos class Ship ( pygame . sprite . Sprite ): def __init__ ( self , groups , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'ship_img' ] self . mask = pygame . mask . from_surface ( self . image ) self . rect = self . image . get_rect () self . rect . centerx = WIDTH / 2 self . rect . bottom = HEIGHT - 10 self . speedx = 0 self . groups = groups self . assets = assets # S\u00f3 ser\u00e1 poss\u00edvel atirar uma vez a cada 500 milissegundos self . last_shot = pygame . time . get_ticks () self . shoot_ticks = 500 def update ( self ): # Atualiza\u00e7\u00e3o da posi\u00e7\u00e3o da nave self . rect . x += self . speedx # Mantem dentro da tela if self . rect . right > WIDTH : self . rect . right = WIDTH if self . rect . left < 0 : self . rect . left = 0 def shoot ( self ): # Verifica se pode atirar now = pygame . time . get_ticks () # Verifica quantos ticks se passaram desde o \u00faltimo tiro. elapsed_ticks = now - self . last_shot # Se j\u00e1 pode atirar novamente... if elapsed_ticks > self . shoot_ticks : # Marca o tick da nova imagem. self . last_shot = now # A nova bala vai ser criada logo acima e no centro horizontal da nave new_bullet = Bullet ( self . assets , self . rect . top , self . rect . centerx ) self . groups [ 'all_sprites' ] . add ( new_bullet ) self . groups [ 'all_bullets' ] . add ( new_bullet ) self . assets [ 'pew_sound' ] . play () class Meteor ( pygame . sprite . Sprite ): def __init__ ( self , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'meteor_img' ] self . mask = pygame . mask . from_surface ( self . image ) self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) # Classe Bullet que representa os tiros class Bullet ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , assets , bottom , centerx ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'bullet_img' ] self . mask = pygame . mask . from_surface ( self . image ) self . rect = self . image . get_rect () # Coloca no lugar inicial definido em x, y do constutor self . rect . centerx = centerx self . rect . bottom = bottom self . speedy = - 10 # Velocidade fixa para cima def update ( self ): # A bala s\u00f3 se move no eixo y self . rect . y += self . speedy # Se o tiro passar do inicio da tela, morre. if self . rect . bottom < 0 : self . kill () # Classe que representa uma explos\u00e3o de meteoro class Explosion ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , center , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) # Armazena a anima\u00e7\u00e3o de explos\u00e3o self . explosion_anim = assets [ 'explosion_anim' ] # Inicia o processo de anima\u00e7\u00e3o colocando a primeira imagem na tela. self . frame = 0 # Armazena o \u00edndice atual na anima\u00e7\u00e3o self . image = self . explosion_anim [ self . frame ] # Pega a primeira imagem self . rect = self . image . get_rect () self . rect . center = center # Posiciona o centro da imagem # Guarda o tick da primeira imagem, ou seja, o momento em que a imagem foi mostrada self . last_update = pygame . time . get_ticks () # Controle de ticks de anima\u00e7\u00e3o: troca de imagem a cada self.frame_ticks milissegundos. # Quando pygame.time.get_ticks() - self.last_update > self.frame_ticks a # pr\u00f3xima imagem da anima\u00e7\u00e3o ser\u00e1 mostrada self . frame_ticks = 50 def update ( self ): # Verifica o tick atual. now = pygame . time . get_ticks () # Verifica quantos ticks se passaram desde a ultima mudan\u00e7a de frame. elapsed_ticks = now - self . last_update # Se j\u00e1 est\u00e1 na hora de mudar de imagem... if elapsed_ticks > self . frame_ticks : # Marca o tick da nova imagem. self . last_update = now # Avan\u00e7a um quadro. self . frame += 1 # Verifica se j\u00e1 chegou no final da anima\u00e7\u00e3o. if self . frame == len ( self . explosion_anim ): # Se sim, tchau explos\u00e3o! self . kill () else : # Se ainda n\u00e3o chegou ao fim da explos\u00e3o, troca de imagem. center = self . rect . center self . image = self . explosion_anim [ self . frame ] self . rect = self . image . get_rect () self . rect . center = center def game_screen ( window ): # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () assets = load_assets () # Criando um grupo de meteoros all_sprites = pygame . sprite . Group () all_meteors = pygame . sprite . Group () all_bullets = pygame . sprite . Group () groups = {} groups [ 'all_sprites' ] = all_sprites groups [ 'all_meteors' ] = all_meteors groups [ 'all_bullets' ] = all_bullets # Criando o jogador player = Ship ( groups , assets ) all_sprites . add ( player ) # Criando os meteoros for i in range ( 8 ): meteor = Meteor ( assets ) all_sprites . add ( meteor ) all_meteors . add ( meteor ) DONE = 0 PLAYING = 1 EXPLODING = 2 state = PLAYING keys_down = {} score = 0 lives = 3 # ===== Loop principal ===== pygame . mixer . music . play ( loops =- 1 ) while state != DONE : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : state = DONE # S\u00f3 verifica o teclado se est\u00e1 no estado de jogo if state == PLAYING : # Verifica se apertou alguma tecla. if event . type == pygame . KEYDOWN : # Dependendo da tecla, altera a velocidade. keys_down [ event . key ] = True if event . key == pygame . K_LEFT : player . speedx -= 8 if event . key == pygame . K_RIGHT : player . speedx += 8 if event . key == pygame . K_SPACE : player . shoot () # Verifica se soltou alguma tecla. if event . type == pygame . KEYUP : # Dependendo da tecla, altera a velocidade. if event . key in keys_down and keys_down [ event . key ]: if event . key == pygame . K_LEFT : player . speedx += 8 if event . key == pygame . K_RIGHT : player . speedx -= 8 # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o dos meteoros all_sprites . update () if state == PLAYING : # Verifica se houve colis\u00e3o entre tiro e meteoro hits = pygame . sprite . groupcollide ( all_meteors , all_bullets , True , True , pygame . sprite . collide_mask ) for meteor in hits : # As chaves s\u00e3o os elementos do primeiro grupo (meteoros) que colidiram com alguma bala # O meteoro e destruido e precisa ser recriado assets [ 'destroy_sound' ] . play () m = Meteor ( assets ) all_sprites . add ( m ) all_meteors . add ( m ) # No lugar do meteoro antigo, adicionar uma explos\u00e3o. explosao = Explosion ( meteor . rect . center , assets ) all_sprites . add ( explosao ) # Ganhou pontos! score += 100 if score % 1000 == 0 : lives += 1 # Verifica se houve colis\u00e3o entre nave e meteoro hits = pygame . sprite . spritecollide ( player , all_meteors , True , pygame . sprite . collide_mask ) if len ( hits ) > 0 : # Toca o som da colis\u00e3o assets [ 'boom_sound' ] . play () player . kill () lives -= 1 explosao = Explosion ( player . rect . center , assets ) all_sprites . add ( explosao ) state = EXPLODING keys_down = {} explosion_tick = pygame . time . get_ticks () explosion_duration = explosao . frame_ticks * len ( explosao . explosion_anim ) + 400 elif state == EXPLODING : now = pygame . time . get_ticks () if now - explosion_tick > explosion_duration : if lives == 0 : state = DONE else : state = PLAYING player = Ship ( groups , assets ) all_sprites . add ( player ) # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( assets [ 'background' ], ( 0 , 0 )) # Desenhando meteoros all_sprites . draw ( window ) # Desenhando o score text_surface = assets [ 'score_font' ] . render ( \" {:08d} \" . format ( score ), True , ( 255 , 255 , 0 )) text_rect = text_surface . get_rect () text_rect . midtop = ( WIDTH / 2 , 10 ) window . blit ( text_surface , text_rect ) # Desenhando as vidas text_surface = assets [ 'score_font' ] . render ( chr ( 9829 ) * lives , True , ( 255 , 0 , 0 )) text_rect = text_surface . get_rect () text_rect . bottomleft = ( 10 , HEIGHT - 10 ) window . blit ( text_surface , text_rect ) pygame . display . update () # Mostra o novo frame para o jogador game_screen ( window ) # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados Linhas 22 a 46: fun\u00e7\u00e3o que carrega os assets. \u00c9 exatamente o mesmo c\u00f3digo de antes, mas agora dentro de uma fun\u00e7\u00e3o; Linhas 192 a 320: fun\u00e7\u00e3o que executa o loop principal. \u00c9 exatamente o mesmo c\u00f3digo de antes, mas agora dentro de uma fun\u00e7\u00e3o. Separando o c\u00f3digo em arquivos diferentes \u00b6 Abra o arquivo jogo_21 . py . Onde est\u00e1 todo aquele c\u00f3digo? O c\u00f3digo do arquivo jogo_20 . py foi separado em 5 arquivos: jogo_21 . py - possui apenas a l\u00f3gica mais geral do jogo: inicializa o pygame, chama a tela do jogo e finaliza o pygame; referencia/jogo_v21.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random from config import WIDTH , HEIGHT from game_screen import game_screen pygame . init () pygame . mixer . init () # ----- Gera tela principal window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) game_screen ( window ) # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados game_screen . py - fun\u00e7\u00e3o com o loop principal do jogo; referencia/game_screen.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 import pygame from config import FPS , WIDTH , HEIGHT , BLACK , YELLOW , RED from assets import load_assets , DESTROY_SOUND , BOOM_SOUND , BACKGROUND , SCORE_FONT from sprites import Ship , Meteor , Bullet , Explosion def game_screen ( window ): # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () assets = load_assets () # Criando um grupo de meteoros all_sprites = pygame . sprite . Group () all_meteors = pygame . sprite . Group () all_bullets = pygame . sprite . Group () groups = {} groups [ 'all_sprites' ] = all_sprites groups [ 'all_meteors' ] = all_meteors groups [ 'all_bullets' ] = all_bullets # Criando o jogador player = Ship ( groups , assets ) all_sprites . add ( player ) # Criando os meteoros for i in range ( 8 ): meteor = Meteor ( assets ) all_sprites . add ( meteor ) all_meteors . add ( meteor ) DONE = 0 PLAYING = 1 EXPLODING = 2 state = PLAYING keys_down = {} score = 0 lives = 3 # ===== Loop principal ===== pygame . mixer . music . play ( loops =- 1 ) while state != DONE : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : state = DONE # S\u00f3 verifica o teclado se est\u00e1 no estado de jogo if state == PLAYING : # Verifica se apertou alguma tecla. if event . type == pygame . KEYDOWN : # Dependendo da tecla, altera a velocidade. keys_down [ event . key ] = True if event . key == pygame . K_LEFT : player . speedx -= 8 if event . key == pygame . K_RIGHT : player . speedx += 8 if event . key == pygame . K_SPACE : player . shoot () # Verifica se soltou alguma tecla. if event . type == pygame . KEYUP : # Dependendo da tecla, altera a velocidade. if event . key in keys_down and keys_down [ event . key ]: if event . key == pygame . K_LEFT : player . speedx += 8 if event . key == pygame . K_RIGHT : player . speedx -= 8 # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o dos meteoros all_sprites . update () if state == PLAYING : # Verifica se houve colis\u00e3o entre tiro e meteoro hits = pygame . sprite . groupcollide ( all_meteors , all_bullets , True , True , pygame . sprite . collide_mask ) for meteor in hits : # As chaves s\u00e3o os elementos do primeiro grupo (meteoros) que colidiram com alguma bala # O meteoro e destruido e precisa ser recriado assets [ DESTROY_SOUND ] . play () m = Meteor ( assets ) all_sprites . add ( m ) all_meteors . add ( m ) # No lugar do meteoro antigo, adicionar uma explos\u00e3o. explosao = Explosion ( meteor . rect . center , assets ) all_sprites . add ( explosao ) # Ganhou pontos! score += 100 if score % 1000 == 0 : lives += 1 # Verifica se houve colis\u00e3o entre nave e meteoro hits = pygame . sprite . spritecollide ( player , all_meteors , True , pygame . sprite . collide_mask ) if len ( hits ) > 0 : # Toca o som da colis\u00e3o assets [ BOOM_SOUND ] . play () player . kill () lives -= 1 explosao = Explosion ( player . rect . center , assets ) all_sprites . add ( explosao ) state = EXPLODING keys_down = {} explosion_tick = pygame . time . get_ticks () explosion_duration = explosao . frame_ticks * len ( explosao . explosion_anim ) + 400 elif state == EXPLODING : now = pygame . time . get_ticks () if now - explosion_tick > explosion_duration : if lives == 0 : state = DONE else : state = PLAYING player = Ship ( groups , assets ) all_sprites . add ( player ) # ----- Gera sa\u00eddas window . fill ( BLACK ) # Preenche com a cor branca window . blit ( assets [ BACKGROUND ], ( 0 , 0 )) # Desenhando meteoros all_sprites . draw ( window ) # Desenhando o score text_surface = assets [ SCORE_FONT ] . render ( \" {:08d} \" . format ( score ), True , YELLOW ) text_rect = text_surface . get_rect () text_rect . midtop = ( WIDTH / 2 , 10 ) window . blit ( text_surface , text_rect ) # Desenhando as vidas text_surface = assets [ SCORE_FONT ] . render ( chr ( 9829 ) * lives , True , RED ) text_rect = text_surface . get_rect () text_rect . bottomleft = ( 10 , HEIGHT - 10 ) window . blit ( text_surface , text_rect ) pygame . display . update () # Mostra o novo frame para o jogador sprites . py - defini\u00e7\u00e3o das classes do jogo; referencia/sprites.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 import random import pygame from config import WIDTH , HEIGHT , METEOR_WIDTH , METEOR_HEIGHT , SHIP_WIDTH , SHIP_HEIGHT from assets import SHIP_IMG , PEW_SOUND , METEOR_IMG , BULLET_IMG , EXPLOSION_ANIM class Ship ( pygame . sprite . Sprite ): def __init__ ( self , groups , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ SHIP_IMG ] self . mask = pygame . mask . from_surface ( self . image ) self . rect = self . image . get_rect () self . rect . centerx = WIDTH / 2 self . rect . bottom = HEIGHT - 10 self . speedx = 0 self . groups = groups self . assets = assets # S\u00f3 ser\u00e1 poss\u00edvel atirar uma vez a cada 500 milissegundos self . last_shot = pygame . time . get_ticks () self . shoot_ticks = 500 def update ( self ): # Atualiza\u00e7\u00e3o da posi\u00e7\u00e3o da nave self . rect . x += self . speedx # Mantem dentro da tela if self . rect . right > WIDTH : self . rect . right = WIDTH if self . rect . left < 0 : self . rect . left = 0 def shoot ( self ): # Verifica se pode atirar now = pygame . time . get_ticks () # Verifica quantos ticks se passaram desde o \u00faltimo tiro. elapsed_ticks = now - self . last_shot # Se j\u00e1 pode atirar novamente... if elapsed_ticks > self . shoot_ticks : # Marca o tick da nova imagem. self . last_shot = now # A nova bala vai ser criada logo acima e no centro horizontal da nave new_bullet = Bullet ( self . assets , self . rect . top , self . rect . centerx ) self . groups [ 'all_sprites' ] . add ( new_bullet ) self . groups [ 'all_bullets' ] . add ( new_bullet ) self . assets [ PEW_SOUND ] . play () class Meteor ( pygame . sprite . Sprite ): def __init__ ( self , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ METEOR_IMG ] self . mask = pygame . mask . from_surface ( self . image ) self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) # Classe Bullet que representa os tiros class Bullet ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , assets , bottom , centerx ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ BULLET_IMG ] self . mask = pygame . mask . from_surface ( self . image ) self . rect = self . image . get_rect () # Coloca no lugar inicial definido em x, y do constutor self . rect . centerx = centerx self . rect . bottom = bottom self . speedy = - 10 # Velocidade fixa para cima def update ( self ): # A bala s\u00f3 se move no eixo y self . rect . y += self . speedy # Se o tiro passar do inicio da tela, morre. if self . rect . bottom < 0 : self . kill () # Classe que representa uma explos\u00e3o de meteoro class Explosion ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , center , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) # Armazena a anima\u00e7\u00e3o de explos\u00e3o self . explosion_anim = assets [ EXPLOSION_ANIM ] # Inicia o processo de anima\u00e7\u00e3o colocando a primeira imagem na tela. self . frame = 0 # Armazena o \u00edndice atual na anima\u00e7\u00e3o self . image = self . explosion_anim [ self . frame ] # Pega a primeira imagem self . rect = self . image . get_rect () self . rect . center = center # Posiciona o centro da imagem # Guarda o tick da primeira imagem, ou seja, o momento em que a imagem foi mostrada self . last_update = pygame . time . get_ticks () # Controle de ticks de anima\u00e7\u00e3o: troca de imagem a cada self.frame_ticks milissegundos. # Quando pygame.time.get_ticks() - self.last_update > self.frame_ticks a # pr\u00f3xima imagem da anima\u00e7\u00e3o ser\u00e1 mostrada self . frame_ticks = 50 def update ( self ): # Verifica o tick atual. now = pygame . time . get_ticks () # Verifica quantos ticks se passaram desde a ultima mudan\u00e7a de frame. elapsed_ticks = now - self . last_update # Se j\u00e1 est\u00e1 na hora de mudar de imagem... if elapsed_ticks > self . frame_ticks : # Marca o tick da nova imagem. self . last_update = now # Avan\u00e7a um quadro. self . frame += 1 # Verifica se j\u00e1 chegou no final da anima\u00e7\u00e3o. if self . frame == len ( self . explosion_anim ): # Se sim, tchau explos\u00e3o! self . kill () else : # Se ainda n\u00e3o chegou ao fim da explos\u00e3o, troca de imagem. center = self . rect . center self . image = self . explosion_anim [ self . frame ] self . rect = self . image . get_rect () self . rect . center = center assets . py - fun\u00e7\u00e3o de carregamento de assets do jogo; referencia/assets.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import pygame import os from config import METEOR_WIDTH , METEOR_HEIGHT , SHIP_WIDTH , SHIP_HEIGHT , IMG_DIR , SND_DIR , FNT_DIR BACKGROUND = 'background' METEOR_IMG = 'meteor_img' METEOR_IMG = 'meteor_img' SHIP_IMG = 'ship_img' SHIP_IMG = 'ship_img' BULLET_IMG = 'bullet_img' EXPLOSION_ANIM = 'explosion_anim' SCORE_FONT = 'score_font' BOOM_SOUND = 'boom_sound' DESTROY_SOUND = 'destroy_sound' PEW_SOUND = 'pew_sound' def load_assets (): assets = {} assets [ BACKGROUND ] = pygame . image . load ( os . path . join ( IMG_DIR , 'starfield.png' )) . convert () assets [ METEOR_IMG ] = pygame . image . load ( os . path . join ( IMG_DIR , 'meteorBrown_med1.png' )) . convert_alpha () assets [ METEOR_IMG ] = pygame . transform . scale ( assets [ 'meteor_img' ], ( METEOR_WIDTH , METEOR_HEIGHT )) assets [ SHIP_IMG ] = pygame . image . load ( os . path . join ( IMG_DIR , 'playerShip1_orange.png' )) . convert_alpha () assets [ SHIP_IMG ] = pygame . transform . scale ( assets [ 'ship_img' ], ( SHIP_WIDTH , SHIP_HEIGHT )) assets [ BULLET_IMG ] = pygame . image . load ( os . path . join ( IMG_DIR , 'laserRed16.png' )) . convert_alpha () explosion_anim = [] for i in range ( 9 ): # Os arquivos de anima\u00e7\u00e3o s\u00e3o numerados de 00 a 08 filename = os . path . join ( IMG_DIR , 'regularExplosion0 {} .png' . format ( i )) img = pygame . image . load ( filename ) . convert () img = pygame . transform . scale ( img , ( 32 , 32 )) explosion_anim . append ( img ) assets [ EXPLOSION_ANIM ] = explosion_anim assets [ SCORE_FONT ] = pygame . font . Font ( os . path . join ( FNT_DIR , 'PressStart2P.ttf' ), 28 ) # Carrega os sons do jogo pygame . mixer . music . load ( os . path . join ( SND_DIR , 'tgfcoder-FrozenJam-SeamlessLoop.ogg' )) pygame . mixer . music . set_volume ( 0.4 ) assets [ BOOM_SOUND ] = pygame . mixer . Sound ( os . path . join ( SND_DIR , 'expl3.wav' )) assets [ DESTROY_SOUND ] = pygame . mixer . Sound ( os . path . join ( SND_DIR , 'expl6.wav' )) assets [ PEW_SOUND ] = pygame . mixer . Sound ( os . path . join ( SND_DIR , 'pew.wav' )) return assets config . py - constantes. referencia/config.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from os import path # Estabelece a pasta que contem as figuras e sons. IMG_DIR = path . join ( path . dirname ( __file__ ), 'assets' , 'img' ) SND_DIR = path . join ( path . dirname ( __file__ ), 'assets' , 'snd' ) FNT_DIR = path . join ( path . dirname ( __file__ ), 'assets' , 'font' ) # Dados gerais do jogo. WIDTH = 480 # Largura da tela HEIGHT = 600 # Altura da tela FPS = 60 # Frames por segundo # Define tamanhos METEOR_WIDTH = 50 METEOR_HEIGHT = 38 SHIP_WIDTH = 50 SHIP_HEIGHT = 38 # Define algumas vari\u00e1veis com as cores b\u00e1sicas WHITE = ( 255 , 255 , 255 ) BLACK = ( 0 , 0 , 0 ) RED = ( 255 , 0 , 0 ) GREEN = ( 0 , 255 , 0 ) BLUE = ( 0 , 0 , 255 ) YELLOW = ( 255 , 255 , 0 ) # Estados para controle do fluxo da aplica\u00e7\u00e3o INIT = 0 GAME = 1 QUIT = 2 Lembra quando precisamos de uma fun\u00e7\u00e3o da biblioteca de matem\u00e1tica e damos um import math ? Quando queremos utilizar um valor ou fun\u00e7\u00e3o que foi definida em outro arquivo tamb\u00e9m usamos o import . Essa divis\u00e3o em arquivos facilita o desenvolvimento concorrente do jogo pelos membros da equipe. Adicionando uma tela inicial \u00b6 Essa refatora\u00e7\u00e3o toda n\u00e3o foi em v\u00e3o. No jogo_v22 . py vemos como essa refatora\u00e7\u00e3o ajudou a desenvolver uma nova tela de jogo! Vemos tamb\u00e9m o truque da m\u00e1quina de estados para organizar a aplica\u00e7\u00e3o principal. Agora n\u00e3o temos muitas, linhas, mas as mudan\u00e7as est\u00e3o nas linhas 17 a 24. referencia/jogo_v22.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random from config import WIDTH , HEIGHT , INIT , GAME , QUIT from init_screen import init_screen from game_screen import game_screen pygame . init () pygame . mixer . init () # ----- Gera tela principal window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) state = INIT while state != QUIT : if state == INIT : state = init_screen ( window ) elif state == GAME : state = game_screen ( window ) else : state = QUIT # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados EXERC\u00cdCIO 19 \u00b6 Modifique o jogo_v22 . py para adicionar uma tela de game over. Refer\u00eancias \u00b6 https://www.pygame.org/docs/ http://kidscancode.org/blog/2016/08/pygame_shmup_part_1/","title":"Handout"},{"location":"aulas/10-pygame/#10-pygame","text":"Neste handout vamos come\u00e7ar a nos preparar para desenvolver o projeto final de Design de Software. Para isso vamos apresentar uma biblioteca de desenvolvimento de jogos em Python chamada pygame. Ao final deste handout voc\u00ea ter\u00e1 implementado um jogo simples baseado no Asteroids usando pygame.","title":"10 - PyGame"},{"location":"aulas/10-pygame/#estrutura-basica-de-um-jogo","text":"Vamos come\u00e7ar entendendo a estrutura de um jogo qualquer. Note que este conhecimento independe da biblioteca ou linguagem de programa\u00e7\u00e3o utilizada. Essa estrutura pode ser resumida da seguinte maneira: Nas se\u00e7\u00f5es a seguir explicamos o que o programa faz em cada um desses blocos.","title":"Estrutura b\u00e1sica de um jogo"},{"location":"aulas/10-pygame/#inicializacao","text":"Importa e inicia pacotes: por exemplo, realiza os imports no Python; Inicia estruturas de dados: por exemplo, inicia listas, dicion\u00e1rios, vari\u00e1veis, etc. com seus valores padr\u00e3o; Inicia assets: exemplos de assets s\u00e3o imagens, sons, sprites, modelos 3D, etc. que s\u00e3o utilizados pelo jogo; Gera tela principal: criar a janela onde o jogo ser\u00e1 apresentado; Dispara loop principal: depois que toda a inicializa\u00e7\u00e3o est\u00e1 conclu\u00edda o jogo propriamente dito se inicia.","title":"Inicializa\u00e7\u00e3o"},{"location":"aulas/10-pygame/#loop-principal","text":"O jogo e toda a intera\u00e7\u00e3o acontece durante esta fase. O loop principal, tamb\u00e9m chamado de game loop , se repete enquanto o jogo estiver rodando. Em geral, ao final de uma itera\u00e7\u00e3o do loop principal ser\u00e1 gerado um novo frame para ser apresentado para o usu\u00e1rio. Trata eventos: por exemplo, movimentos/cliques de mouse, input de teclado, timer, clique do usu\u00e1rio no X para fechar a janela, etc. Verifica consequ\u00eancias: verifica se houve colis\u00f5es, aplica as a\u00e7\u00f5es do usu\u00e1rio (por exemplo, muda a dire\u00e7\u00e3o do personagem se o jogador apertou uma tecla), etc. de acordo com as regras e mec\u00e2nica do jogo; Atualiza estado do jogo: move os objetos na tela, atualiza os estados dos assets (por exemplo, muda a anima\u00e7\u00e3o) e as estruturas de dados utilizadas (por exemplo, atualiza a lista de personagens vivos); Gera sa\u00eddas: exibe as mudan\u00e7as para o jogador (gera uma nova imagem/frame, toca um som, etc.).","title":"Loop principal"},{"location":"aulas/10-pygame/#finalizacao","text":"Na finaliza\u00e7\u00e3o pode ser realizado o fechamento de arquivos, salvar o placar do jogo, fechar a janela do jogo, etc. O pygame \u00e9 um framework (ou game engine ) para desenvolvimento de jogos em Python, baseado na biblioteca SDL2 (Simple DirectMedia Layer).","title":"Finaliza\u00e7\u00e3o"},{"location":"aulas/10-pygame/#instalacao","text":"","title":"Instala\u00e7\u00e3o"},{"location":"aulas/10-pygame/#windows-e-linux","text":"Abra o seu terminal (Linux) ou Anaconda Prompt (Windows) e digite: pip install pygame","title":"Windows e Linux"},{"location":"aulas/10-pygame/#mac-osx","text":"A instala\u00e7\u00e3o no Mac \u00e9 um pouco mais complicada, infelizmente. Se voc\u00ea n\u00e3o tiver o Homebrew instalado, instale-o seguindo as instru\u00e7\u00f5es dispon\u00edveis neste link (se voc\u00ea n\u00e3o sabe se tem o Homebrew instalado, provavelmente n\u00e3o tem): https://brew.sh/ Abra o terminal e digite: brew install sdl2 sdl2_gfx sdl2_image sdl2_mixer sdl2_net sdl2_ttf brew install Caskroom/cask/xquartz git clone -b 1.9.6 --single-branch https://github.com/pygame/pygame.git cd pygame python setup.py -config -auto -sdl2 python setup.py install cd .. rm -rf pygame Para mais detalhes e outras op\u00e7\u00f5es de instala\u00e7\u00e3o no Mac, consulte a documenta\u00e7\u00e3o: https://www.pygame.org/wiki/MacCompile","title":"Mac OSX"},{"location":"aulas/10-pygame/#preparo-para-o-tutorial","text":"Antes de seguir com o tutorial de pygame, fa\u00e7a o download do arquivo referencia.zip (dispon\u00edvel neste link) . Descompacte os arquivos em uma pasta, sem alterar a estrutura de pastas. Importante Consulte a documenta\u00e7\u00e3o se n\u00e3o entender algum dos comandos.","title":"Preparo para o tutorial"},{"location":"aulas/10-pygame/#criando-uma-janela","text":"Veremos que ser\u00e1 necess\u00e1rio utilizarmos muitos comandos para fazer coisas aparentemente simples, como mostrar uma janela em branco. N\u00e3o se assuste. Muito desse c\u00f3digo se repete de maneira muito semelhante em qualquer jogo que voc\u00ea for desenvolver. Vamos come\u00e7ar ent\u00e3o com o exemplo que acabamos de comentar: como mostrar uma janela do pygame. Abra o arquivo referencia / jogo_v1 . py . Esse arquivo cont\u00e9m coment\u00e1rios que separam o c\u00f3digo nos blocos descritos no in\u00edcio deste handout. Vamos entender o que esses comandos fazem: referencia/jogo_v1.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame pygame . init () # ----- Gera tela principal window = pygame . display . set_mode (( 500 , 400 )) pygame . display . set_caption ( 'Hello World!' ) # ----- Inicia estruturas de dados game = True # ===== Loop principal ===== while game : # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : game = False # ----- Gera sa\u00eddas window . fill (( 255 , 255 , 255 )) # Preenche com a cor branca # ----- Atualiza estado do jogo pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados pygame . init () (linha 5): o framework pygame \u00e9 iniciado. Apenas ap\u00f3s este comando \u00e9 que os recursos do pacote podem ser utilizados; pygame . display . set_mode (( 500 , 400 )) (linha 8): cria uma janela com 500 pixels de largura e 400 pixels de altura; pygame . display . set_caption ( 'Hello World!' ) (linha 9): define o t\u00edtulo da janela (que aparece na barra superior) como o texto 'Hello World!' ; game = True (linha 12): a vari\u00e1vel game ser\u00e1 utilizada para indicar que o jogo deve continuar; while game : (linha 15): continua o jogo enquanto game for True ; for event in pygame . event . get (): (linha 17): pygame . event . get () devolve uma lista com todos os eventos (cliques/movimentos de mouse, teclas apertadas, bot\u00f5es da janela apertados, etc.) que ocorreram desde a \u00faltima vez que essa fun\u00e7\u00e3o foi chamada. O for percorre cada um desses eventos, aplicando as consequ\u00eancias necess\u00e1rias a cada caso; if event . type == pygame . QUIT : (linha 19): verifica se o tipo do evento \u00e9 pygame . QUIT , ou seja, se o usu\u00e1rio clicou no bot\u00e3o de fechar a janela (consulte a documenta\u00e7\u00e3o para ver mais eventos poss\u00edveis); game = False (linha 20): muda o valor para False para que a pr\u00f3xima itera\u00e7\u00e3o do loop principal n\u00e3o seja mais executada. Depois disso o programa termina; window . fill (( 255 , 255 , 255 )) (linha 23): preenche a janela com a cor branca. As cores s\u00e3o valores RGB (Red, Green, Blue) que variam entre 0 e 255. Note que existe um par\u00eanteses ao redor dos tr\u00eas valores. Esse par\u00eanteses \u00e9 muito importante, pois define uma tupla (uma sequ\u00eancia de valores, semelhante a uma lista); pygame . display . update () (linha 26): tudo o que \u00e9 feito na tela ( window ) n\u00e3o \u00e9 mostrado para o usu\u00e1rio imediatamente, assim \u00e9 poss\u00edvel desenhar v\u00e1rias coisas e somente depois de terminar de desenhar mostramos a nova tela (ou frame) para o usu\u00e1rio. Essa fun\u00e7\u00e3o \u00e9 respons\u00e1vel por mostrar a nova tela que foi desenhada; pygame . quit () (linha 29): finaliza o pygame. \u00c9 importante chamar essa fun\u00e7\u00e3o para que ele feche todos os recursos que abriu (por exemplo a janela).","title":"Criando uma janela"},{"location":"aulas/10-pygame/#exercicio-1","text":"Aplique as seguintes modifica\u00e7\u00f5es ao c\u00f3digo do jogo_v1 . py : Utilize uma janela de 600 X 300 pixels; Mude o t\u00edtulo para Jogo da / do NOME (onde NOME \u00e9 o seu nome); Mude a cor da janela para azul ao inv\u00e9s de branco; Fa\u00e7a o jogo fechar assim que o usu\u00e1rio apertar qualquer tecla do teclado. Dica: procure pelo evento pygame . KEYUP .","title":"EXERC\u00cdCIO 1"},{"location":"aulas/10-pygame/#desenhando-na-tela","text":"Vamos come\u00e7ar desenhando pol\u00edgono na tela. Para isso precisamos entender o sistema de coordenadas da tela do pygame (imagem extra\u00edda de: https://medium.com/iothincvit/pygame-for-beginners-234da7d3c56f ): No pygame, o canto superior esquerdo da janela \u00e9 a origem (ponto ( 0 , 0 ) ). O eixo X aumenta para a direita e o eixo Y aumenta para baixo . Assim, se queremos mostrar uma informa\u00e7\u00e3o \"mais para baixo\", devemos aumentar o valor de Y. Abra o arquivo jogo_v2 . py . A \u00fanica diferen\u00e7a para a vers\u00e3o 1 s\u00e3o as linhas 24 a 26. Nas linhas 24 e 25 n\u00f3s definimos uma cor (vermelha) e os v\u00e9rtices de um pol\u00edgono. Na linha 26 chamamos a fun\u00e7\u00e3o pygame . draw . polygon , que recebe uma superf\u00edcie na qual o pol\u00edgono ser\u00e1 desenhado (no nosso caso, a janela), a cor e os v\u00e9rtices do pol\u00edgono. referencia/jogo_v2.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame pygame . init () # ----- Gera tela principal window = pygame . display . set_mode (( 500 , 400 )) pygame . display . set_caption ( 'Hello World!' ) # ----- Inicia estruturas de dados game = True # ===== Loop principal ===== while game : # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : game = False # ----- Gera sa\u00eddas window . fill (( 255 , 255 , 255 )) # Preenche com a cor branca cor = ( 255 , 0 , 0 ) vertices = [( 250 , 0 ), ( 500 , 200 ), ( 250 , 400 ), ( 0 , 200 )] pygame . draw . polygon ( window , cor , vertices ) # ----- Atualiza estado do jogo pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados","title":"Desenhando na tela"},{"location":"aulas/10-pygame/#exercicio-2","text":"Modifique o c\u00f3digo do jogo_v2 . py para que ele desenhe a bandeira do Brasil (simplificada, s\u00f3 a parte verde, amarela e azul). Dica: voc\u00ea provavelmente vai querer utilizar a fun\u00e7\u00e3o pygame . draw . circle (consulte a documenta\u00e7\u00e3o para entender como utiliz\u00e1-la). Tente mudar a ordem dos desenhos (desenhe primeiro o c\u00edrculo, depois o pol\u00edgono). O que acontece? A ordem dos desenhos importa. O novo desenho \u00e9 sempre feito sobrepondo os desenhos anteriores.","title":"EXERC\u00cdCIO 2"},{"location":"aulas/10-pygame/#desenhando-um-texto","text":"Talvez voc\u00ea tenha estranhado o t\u00edtulo desta se\u00e7\u00e3o, mas qualquer texto deve realmente ser desenhado para aparecer na tela. Os caracteres de um texto tamb\u00e9m s\u00e3o desenhados como pixels. Vamos entender o arquivo jogo_v3 . py . Antes de abrir o arquivo, execute-o para ver o resultado. referencia/jogo_v3.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame pygame . init () # ----- Gera tela principal window = pygame . display . set_mode (( 500 , 400 )) pygame . display . set_caption ( 'Hello World!' ) # ----- Inicia estruturas de dados game = True # ----- Inicia assets font = pygame . font . SysFont ( None , 48 ) text = font . render ( 'HELLO WORLD' , True , ( 0 , 0 , 255 )) # ===== Loop principal ===== while game : # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : game = False # ----- Gera sa\u00eddas window . fill (( 255 , 255 , 255 )) # Preenche com a cor branca window . blit ( text , ( 10 , 10 )) # ----- Atualiza estado do jogo pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados Agora que voc\u00ea j\u00e1 viu o HELLO WORLD na tela, vamos entender o c\u00f3digo. As mudan\u00e7as est\u00e3o nas linhas 15, 16 e 28: font = pygame . font . SysFont ( None , 48 ) (linha 15): carrega uma nova fonte de texto. Como n\u00e3o passamos nada como o primeiro argumento ( None ), o PyGame vai utilizar a fonte padr\u00e3o. O segundo argumento \u00e9 o tamanho da fonte; text = font . render ( 'HELLO WORLD' , True , ( 0 , 0 , 255 )) (linha 16): cria uma imagem a partir da fonte criada na linha anterior com o texto 'HELLO WORLD' . O segundo argumento neste momento pode ser sempre True (ele faz com que as curvas sejam desenhadas de maneira mais suave). O terceiro argumento \u00e9 a cor; window . blit ( text , ( 10 , 10 )) (linha 28): desenha em window a imagem text na posi\u00e7\u00e3o ( 10 , 10 ) (lembrando que a origem - ponto (0, 0) - \u00e9 no canto superior esquerdo). A imagem \u00e9 delimitada por um ret\u00e2ngulo. A posi\u00e7\u00e3o passada como segundo argumento define a localiza\u00e7\u00e3o do ponto superior esquerdo desse ret\u00e2ngulo. Por padr\u00e3o, sempre que nos referimos \u00e0 posi\u00e7\u00e3o da imagem (coordenada (x, y) (x, y) ) queremos dizer o seu canto superior esquerdo.","title":"Desenhando um texto"},{"location":"aulas/10-pygame/#exercicio-3","text":"Modifique o jogo_v3 . py para que ele desenhe o texto HELLO em uma posi\u00e7\u00e3o (por exemplo, no ponto (10, 10), onde ele j\u00e1 est\u00e1) e o texto WORLD em outro lugar da janela (por exemplo, no ponto (100, 100)).","title":"EXERC\u00cdCIO 3"},{"location":"aulas/10-pygame/#desenhando-uma-imagem","text":"Como vimos na se\u00e7\u00e3o anterior, text j\u00e1 era uma imagem que foi desenhada na tela. Assim, n\u00e3o precisamos mudar muito o c\u00f3digo para desenhar uma imagem qualquer. Execute o arquivo jogo_v4 . py e depois abra o c\u00f3digo. A principal mudan\u00e7a est\u00e1 na linha 17, na qual carregamos uma imagem de um arquivo ao inv\u00e9s de desenhar um texto em uma imagem. O . convert () no final da linha \u00e9 uma otimiza\u00e7\u00e3o para acelerar o desenho da imagem. \u00c9 uma boa pr\u00e1tica sempre chamar esse m\u00e9todo ao carregar uma imagem. Alternativamente pode-se utilizar o . convert_alpha () quando a imagem possui transpar\u00eancia. referencia/jogo_v4.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame pygame . init () # ----- Gera tela principal WIDTH = 500 HEIGHT = 400 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Hello World!' ) # ----- Inicia estruturas de dados game = True # ----- Inicia assets image = pygame . image . load ( 'assets/img/logo-madfox.png' ) . convert () # ===== Loop principal ===== while game : # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : game = False # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( image , ( 10 , 10 )) # ----- Atualiza estado do jogo pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados Aproveitamos para come\u00e7ar a organizar melhor o c\u00f3digo. Foram criadas duas constantes, WIDTH e HEIGHT , para guardar o valor da largura e altura da janela. Assim, sempre que precisarmos dessa informa\u00e7\u00e3o podemos usar as constantes ao inv\u00e9s de colocar os n\u00fameros diretamente. Isso facilita muito quando queremos alterar o tamanho da janela. Nesse caso n\u00e3o ser\u00e1 necess\u00e1rio procurar em todos os lugares do c\u00f3digo onde o n\u00famero aparece. Basta mudar o valor da constante.","title":"Desenhando uma imagem"},{"location":"aulas/10-pygame/#exercicio-4","text":"A imagem est\u00e1 grande demais. Modifique o jogo_v4 . py para mostrar uma imagem menor. Dica: use o comando image = pygame . transform . scale ( image , ( 125 , 166 )) para obter uma nova imagem de 125 X 166 pixels.","title":"EXERC\u00cdCIO 4"},{"location":"aulas/10-pygame/#recriando-o-asteroids","text":"Asteroids \u00e9 um jogo de nave que foi muito famoso na d\u00e9cada de 80. Consiste em destruir os meteoros que vem em sua dire\u00e7\u00e3o atrav\u00e9s de tiros. Nesse tutorial, vamos replicar uma vers\u00e3o simplificada do jogo usando o pygame. Esse tutorial foi baseado no site KidsCanCode , o qual possui mais tutoriais com mais t\u00e9cnicas de desenvolvimento de jogos. O arquivo jogo_v5 . py apresenta uma primeira vers\u00e3o com um \u00fanico meteoro que fica caindo do topo da tela. Quando sai da tela, ele retorna \u00e0 posi\u00e7\u00e3o inicial. Execute o jogo_v5 . py e depois abra o arquivo para entender o que ele faz. referencia/jogo_v5.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random pygame . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets METEOR_WIDTH = 50 METEOR_HEIGHT = 38 font = pygame . font . SysFont ( None , 48 ) background = pygame . image . load ( 'assets/img/starfield.png' ) . convert () meteor_img = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () meteor_img_small = pygame . transform . scale ( meteor_img , ( METEOR_WIDTH , METEOR_HEIGHT )) # ----- Inicia estruturas de dados game = True meteor_x = 200 # y negativo significa que est\u00e1 acima do topo da janela. O meteoro come\u00e7a fora da janela meteor_y = - METEOR_HEIGHT meteor_speedx = 3 meteor_speedy = 4 # ===== Loop principal ===== while game : # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : game = False # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o do meteoro meteor_x += meteor_speedx meteor_y += meteor_speedy # Se o meteoro passar do final da tela, volta para cima if meteor_y > HEIGHT or meteor_x + METEOR_WIDTH < 0 or meteor_x > WIDTH : meteor_x = 200 meteor_y = - METEOR_HEIGHT # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( background , ( 0 , 0 )) window . blit ( meteor_img_small , ( meteor_x , meteor_y )) pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados Este arquivo possui algumas modifica\u00e7\u00f5es: Linhas 18 a 20: carrega as imagens de fundo e do meteoro; Linhas 24 a 28: inicializa as vari\u00e1veis que armazenam a posi\u00e7\u00e3o e a velocidade do meteoro; Linhas 40 e 41: atualiza a posi\u00e7\u00e3o do meteoro; Linhas 43 a 45: verifica se o meteoro saiu da tela. Nesse caso, faz ele voltar para a posi\u00e7\u00e3o inicial. Linhas 49 e 50: desenha a imagem de fundo e depois a imagem do meteoro (note que a imagem de fundo s\u00f3 cobre a janela inteira porque mudamos o tamanho da janela para 480 X 600 pixels - caso contr\u00e1rio uma parte dela ficaria com a cor de fundo).","title":"Recriando o Asteroids"},{"location":"aulas/10-pygame/#exercicio-5","text":"O meteoro sempre come\u00e7a na mesma posi\u00e7\u00e3o e sempre se move na mesma dire\u00e7\u00e3o. Vamos deixar o jogo mais interessante sorteando uma posi\u00e7\u00e3o aleat\u00f3ria. Sorteie valores aleat\u00f3rios para meteor_x , meteor_y , meteor_speedx , meteor_speedy na inicializa\u00e7\u00e3o do jogo (a partir da linha 24) e quando o meteoro sai da tela ( if da linha 43). Sugest\u00f5es de valores aleat\u00f3rios: meteor_x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) - o valor de x pode estar entre 0 e a largura da janela menos a largura da imagem do meteoro. Lembre-se que x \u00e9 a esquerda do ret\u00e2ngulo que define a imagem; meteor_y = random . randint ( - 100 , - METEOR_HEIGHT ) - valores negativos significam que o meteoro est\u00e1 acima da janela. Vamos sortear valores de maneira que ele sempre comece o movimento de fora da janela, ou seja, o mais baixo poss\u00edvel \u00e9 - METEOR_HEIGHT . Lembrando que y \u00e9 a coordenada de cima do ret\u00e2ngulo da imagem; meteor_speedx = random . randint ( - 3 , 3 ) - se os valores da componente x da velocidade forem muito altos o meteoro vai se mover para um dos lados sem descer muito; meteor_speedy = random . randint ( 2 , 9 ) - velocidades positivas em y significam que o meteoro vai se mover para baixo.","title":"EXERC\u00cdCIO 5"},{"location":"aulas/10-pygame/#controlando-a-velocidade-do-jogo","text":"Voc\u00ea percebeu que o meteoro se move muito rapidamente? Isso acontece porque estamos em um loop infinito, cuja velocidade de execu\u00e7\u00e3o depende da CPU (processador), mem\u00f3ria e outras caracter\u00edsticas do equipamento onde estiver sendo executado. Dessa forma a velocidade de deslocamento da nave vai variar conforme a m\u00e1quina em que o jogo for executado e os programas que estejam nela rodando. Para controlar o n\u00famero de itera\u00e7\u00f5es do loop por segundo usaremos o seguinte artif\u00edcio: ser\u00e1 criado um rel\u00f3gio, a partir da classe Clock do pygame. Essa classe possui um m\u00e9todo chamado tick que conta quantos milissegundos j\u00e1 se passaram desde a \u00faltima vez que ele foi chamado. Pegaremos o tempo transcorrido mas n\u00e3o utilizaremos para nada. Mas ao pegar esse tempo especificaremos para o m\u00e9todo tick que queremos que ele seja executado no m\u00e1ximo 30 vezes por segundo. Dessa forma teremos um efeito colateral \u00fatil: o loop ser\u00e1 limitado por essa chamada e s\u00f3 executar\u00e1 30 vezes por segundo tamb\u00e9m. Assim, em qualquer m\u00e1quina que o c\u00f3digo for executado a velocidade de atualiza\u00e7\u00e3o do jogo ser\u00e1 a mesma (exceto, claro, se a m\u00e1quina for t\u00e3o lenta que n\u00e3o conseguir executar nessa velocidade). Aplicamos essas mudan\u00e7as no arquivo jogo_v6 . py (linhas 34, 35 e 39). Execute o programa para ver o resultado da mudan\u00e7a. referencia/jogo_v6.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random pygame . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets METEOR_WIDTH = 50 METEOR_HEIGHT = 38 font = pygame . font . SysFont ( None , 48 ) background = pygame . image . load ( 'assets/img/starfield.png' ) . convert () meteor_img = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () meteor_img_small = pygame . transform . scale ( meteor_img , ( METEOR_WIDTH , METEOR_HEIGHT )) # ----- Inicia estruturas de dados game = True # Sorteia posi\u00e7\u00e3o aleat\u00f3ria # Como x \u00e9 o lado esquerdo da imagem, ele s\u00f3 pode ir at\u00e9 a largura da # janela menos a largura da imagem meteor_x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) # y negativo significa que est\u00e1 acima do topo da janela. O meteoro come\u00e7a fora da janela meteor_y = random . randint ( - 100 , - METEOR_HEIGHT ) # Sorteia velocidade do meteoro meteor_speedx = random . randint ( - 3 , 3 ) meteor_speedy = random . randint ( 2 , 9 ) # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () FPS = 15 # ===== Loop principal ===== while game : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : game = False # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o do meteoro meteor_x += meteor_speedx meteor_y += meteor_speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if meteor_y > HEIGHT or meteor_x + METEOR_WIDTH < 0 or meteor_x > WIDTH : meteor_x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) meteor_y = random . randint ( - 100 , - METEOR_HEIGHT ) meteor_speedx = random . randint ( - 3 , 3 ) meteor_speedy = random . randint ( 2 , 9 ) # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( background , ( 0 , 0 )) window . blit ( meteor_img_small , ( meteor_x , meteor_y )) pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados","title":"Controlando a velocidade do jogo"},{"location":"aulas/10-pygame/#exercicio-6","text":"Agora parece que limitamos demais o n\u00famero de execu\u00e7\u00f5es do loop principal. A anima\u00e7\u00e3o parece um pouco travada. Altere a velocidade do jogo para que ele execute 30 frames por segundo ao inv\u00e9s de 15.","title":"EXERC\u00cdCIO 6"},{"location":"aulas/10-pygame/#adicionando-mais-meteoros","text":"Vamos adicionar mais meteoros ao jogo. Para isso, onde ser\u00e1 necess\u00e1rio alterar o nosso c\u00f3digo? Temos a inicializa\u00e7\u00e3o da posi\u00e7\u00e3o e velocidade do meteoro no come\u00e7o do c\u00f3digo e depois temos a reinicializa\u00e7\u00e3o desses valores quando o meteoro sai da tela. Al\u00e9m disso, precisamos desenhar os meteoros em um outro lugar. Est\u00e1 come\u00e7ando a ficar complexo, n\u00e3o \u00e9 mesmo?","title":"Adicionando mais meteoros"},{"location":"aulas/10-pygame/#classes-em-python","text":"Antes de criar mais meteoros, vamos ent\u00e3o melhorar o nosso c\u00f3digo. Para isso vamos utilizar um recurso dispon\u00edvel no Python chamado classes. Em Design de Software n\u00e3o vamos entrar em detalhes sobre o que s\u00e3o classes, nem como montar boas classes. Queremos apenas saber o m\u00ednimo para poder utiliz\u00e1-las. Neste primeiro momento voc\u00ea pode entender uma classe como um tipo de dados do Python. Na verdade, j\u00e1 trabalhamos com algumas classes, por mais que n\u00e3o tenhamos chamado-as assim: listas, strings e dicion\u00e1rios s\u00e3o algumas das classes dispon\u00edveis na linguagem. O interessante \u00e9 que podemos criar novas classes (ou tipos) no Python. A ideia \u00e9 semelhante ao que fazemos com um def . Primeiro definimos a classe e depois usamos quando for necess\u00e1rio. Suponha, por exemplo, que queremos criar um novo tipo que represente um ponto com coordenadas x e y . Ele poderia ser feito da seguinte maneira (o exemplo completo est\u00e1 no arquivo teste_ponto . py ): class Point : def __init__ ( self ): self . x = 0 self . y = 0 Isso define uma classe Point que possui coordenadas x e y ambas iguais a zero. Note que apenas definimos esse novo tipo, mas ainda n\u00e3o usamos. A partir desse momento o Python sabe o que \u00e9 uma lista, o que \u00e9 uma string e agora tamb\u00e9m o que \u00e9 um Point . Vamos utilizar esse nosso novo tipo: ponto = Point () print ( 'O ponto est\u00e1 nas coordenadas x= {0} e y= {1} ' . format ( ponto . x , ponto . y )) O c\u00f3digo acima vai imprimir: O ponto est\u00e1 nas coordenadas x = 0 e y = 0 . O x e y s\u00e3o vari\u00e1veis (chamamos de atributos) que est\u00e3o ligadas \u00e0quele ponto espec\u00edfico. Podemos inclusive mudar o seu valor: ponto = Point () ponto . x = 2 ponto . y = 5 print ( 'O ponto est\u00e1 nas coordenadas x= {0} e y= {1} ' . format ( ponto . x , ponto . y )) Esse novo c\u00f3digo vai imprimir: O ponto est\u00e1 nas coordenadas x = 2 e y = 5 . Podemos modificar a nossa classe para que ela receba como argumentos os valores das coordenadas assim que um novo ponto \u00e9 criado: class Point : def __init__ ( self , x_coord , y_coord ): self . x = x_coord self . y = y_coord ponto = Point ( 4 , 1 ) print ( 'O ponto est\u00e1 nas coordenadas x= {0} e y= {1} ' . format ( ponto . x , ponto . y )) Esse novo c\u00f3digo vai imprimir: O ponto est\u00e1 nas coordenadas x = 4 e y = 1 . A fun\u00e7\u00e3o __init__ \u00e9 um tipo de fun\u00e7\u00e3o especial que \u00e9 chamada quando o novo ponto \u00e9 criado. Duas observa\u00e7\u00f5es importantes: S\u00e3o dois underscores no come\u00e7o e dois underscores no fim (chamamos esse par de dois underscores de dunder , ou double underscore ); Essas fun\u00e7\u00f5es que fazem parte de uma classe sempre recebem um primeiro argumento chamado self . Ele \u00e9 uma vari\u00e1vel que guarda o pr\u00f3prio objeto. No nosso exemplo, self \u00e9 o pr\u00f3prio ponto. Por isso, quando fazemos self . x = 0 estamos guardando na vari\u00e1vel (atributo) x desse ponto espec\u00edfico o valor 0 . Vamos ver mais um exemplo de uma fun\u00e7\u00e3o definida dentro da classe (tamb\u00e9m chamada de m\u00e9todo): class Point : def __init__ ( self , x_coord , y_coord ): self . x = x_coord self . y = y_coord def distance_to ( self , other_point ): dx = other_point . x - self . x dy = other_point . y - self . y return (( dx ** 2 ) + ( dy ** 2 )) ** 0.5 p1 = Point ( 4 , 1 ) p2 = Point ( 7 , 5 ) d = p1 . distance_to ( p2 ) print ( 'A dist\u00e2ncia de ( {0} , {1} ) a ( {2} , {3} ) \u00e9 {4} ' . format ( p1 . x , p1 . y , p2 . x , p2 . y , d )) O programa acima vai imprimir: A dist\u00e2ncia de ( 4 , 1 ) a ( 7 , 5 ) \u00e9 5 . Considere o comando na pen\u00faltima linha: d = p1 . distance_to ( p2 ) . Ele segue uma estrutura muito parecida com o que j\u00e1 faz\u00edamos com strings, por exemplo: s = 'Insper' t = s . replace ( 'Ins' , 'Su' ) print ( t ) Se voc\u00ea quiser praticar um pouco o uso de classes, fa\u00e7a os exerc\u00edcios 88 e 89 do servidor.","title":"Classes em Python"},{"location":"aulas/10-pygame/#classes-no-pygame","text":"O pygame define algumas novas classes que facilitam o desenvolvimento de jogos. Uma dessas classes \u00e9 o pygame . sprite . Sprite . Vamos aprender como usar esse tipo com o exemplo do meteoro. O exemplo a seguir define uma classe do tipo Meteor , que estende as funcionalidades de um pygame . sprite . Sprite (ou seja, faz tudo que um Sprite faz e mais um pouco): class Meteor ( pygame . sprite . Sprite ): def __init__ ( self ): self . image = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () self . image = pygame . transform . scale ( self . image , ( METEOR_WIDTH , METEOR_HEIGHT )) self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) Na inicializa\u00e7\u00e3o do tipo Meteor temos o carregamento da imagem e o sorteio das posi\u00e7\u00f5es e velocidades do meteoro. Todo Sprite deve definir um atributo image e um rect . Eles s\u00e3o utilizados para desenhar a imagem. O rect define a posi\u00e7\u00e3o do ret\u00e2ngulo da imagem e oferece algumas vantagens, como podemos ver na condi\u00e7\u00e3o do if . Um ret\u00e2ngulo \u00e9 um outro tipo definido pelo pygame, que possui, al\u00e9m da posi\u00e7\u00e3o x e y , outros atributos \u00fateis, como top , left , right , bottom , centerx e centery . Usamos alguns desses exemplos no if , simplificando as compara\u00e7\u00f5es. O m\u00e9todo update ser\u00e1 chamado quando quisermos atualizar a posi\u00e7\u00e3o do meteoro, ou seja, em cada itera\u00e7\u00e3o do loop principal. O arquivo jogo_v7 . py cria a classe Meteor e substitui o c\u00f3digo referente ao meteoro da vers\u00e3o anterior. Execute-o para ver o resultado e depois abra o c\u00f3digo. Note que a classe Meteor est\u00e1 ligeiramente diferente da que apresentamos acima. A diferen\u00e7a \u00e9 que ao inv\u00e9s de carregar a imagem dentro do __init__ , n\u00f3s j\u00e1 recebemos uma imagem carregada no __init__ (linha 25). Essa diferen\u00e7a \u00e9 importante, pois ao inv\u00e9s de carregar uma nova imagem para cada novo meteoro, n\u00f3s carregamos a imagem apenas uma vez e usamos a mesma imagem carregada em todos os meteoros. Tamb\u00e9m adicionamos uma linha no come\u00e7o do __init__ , com pygame . sprite . Sprite . __init__ ( self ) . Como o Meteor \u00e9 uma estens\u00e3o da classe pygame . sprite . Sprite , n\u00f3s precisamos inicializar o resto do Sprite . N\u00e3o se preocupe se n\u00e3o entender todos os detalhes. Por enquanto basta saber que essa linha \u00e9 obrigat\u00f3ria. referencia/jogo_v7.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random pygame . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets METEOR_WIDTH = 50 METEOR_HEIGHT = 38 font = pygame . font . SysFont ( None , 48 ) background = pygame . image . load ( 'assets/img/starfield.png' ) . convert () meteor_img = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () meteor_img = pygame . transform . scale ( meteor_img , ( METEOR_WIDTH , METEOR_HEIGHT )) # ----- Inicia estruturas de dados # Definindo os novos tipos class Meteor ( pygame . sprite . Sprite ): def __init__ ( self , img ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = img self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) game = True # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () FPS = 30 # Criando dois meteoros meteor1 = Meteor ( meteor_img ) meteor2 = Meteor ( meteor_img ) # ===== Loop principal ===== while game : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : game = False # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o dos meteoros meteor1 . update () meteor2 . update () # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( background , ( 0 , 0 )) # Desenhando meteoros window . blit ( meteor1 . image , meteor1 . rect ) window . blit ( meteor2 . image , meteor2 . rect ) pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados As principais mudan\u00e7as nesta vers\u00e3o s\u00e3o: Linhas 24 a 46: defini\u00e7\u00e3o da classe Meteor ; Linhas 54 e 55: cria\u00e7\u00e3o de dois meteoros. Note que o c\u00f3digo que sorteava a posi\u00e7\u00e3o do meteoro (linhas 27 a 32 do jogo_v6 . py ) agora est\u00e1 na inicializa\u00e7\u00e3o (construtor) da classe Meteor , assim, ao criar dois meteoros, cada um ser\u00e1 sorteado com posi\u00e7\u00f5es e velocidades distintas; Linhas 69 e 70: atualiza\u00e7\u00e3o da posi\u00e7\u00e3o dos meteoros. A l\u00f3gica de atualiza\u00e7\u00e3o da posi\u00e7\u00e3o agora est\u00e1 concentrada na classe Meteor , assim n\u00e3o precisamos mais das linhas 49 a 57 do jogo_v6 . py ; Linhas 76 e 77: desenhando os meteoros. O c\u00f3digo \u00e9 bastante semelhante ao que t\u00ednhamos antes, mas agora utilizamos a imagem e o rect (que define a posi\u00e7\u00e3o da imagem) guardados como atributos de cada meteoro.","title":"Classes no pygame"},{"location":"aulas/10-pygame/#exercicio-7","text":"Modifique o jogo_v7 . py para que ele tenha 4 meteoros ao inv\u00e9s de 2.","title":"EXERC\u00cdCIO 7"},{"location":"aulas/10-pygame/#adicionando-mais-meteoros-ainda","text":"Conforme criamos mais meteoros, come\u00e7a a ficar invi\u00e1vel utilizarmos uma vari\u00e1vel para cada meteoro. Uma solu\u00e7\u00f5es (que j\u00e1 ajudaria muito), seria criarmos uma lista com todos os meteoros. O pygame define um novo tipo chamado pygame . sprite . Group , que \u00e9 como uma lista, mas que tem algumas funcionalidades adicionais. O jogo_v8 utiliza o pygame . sprite . Group para criar v\u00e1rios grupos de uma vez. As principais mudan\u00e7as neste arquivo s\u00e3o: referencia/jogo_v8.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random pygame . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets METEOR_WIDTH = 50 METEOR_HEIGHT = 38 font = pygame . font . SysFont ( None , 48 ) background = pygame . image . load ( 'assets/img/starfield.png' ) . convert () meteor_img = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () meteor_img = pygame . transform . scale ( meteor_img , ( METEOR_WIDTH , METEOR_HEIGHT )) # ----- Inicia estruturas de dados # Definindo os novos tipos class Meteor ( pygame . sprite . Sprite ): def __init__ ( self , img ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = img self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) game = True # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () FPS = 30 # Criando um grupo de meteoros all_meteors = pygame . sprite . Group () # Criando os meteoros for i in range ( 8 ): meteor = Meteor ( meteor_img ) all_meteors . add ( meteor ) # ===== Loop principal ===== while game : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : game = False # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o dos meteoros all_meteors . update () # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( background , ( 0 , 0 )) # Desenhando meteoros all_meteors . draw ( window ) pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados Linhas 54 a 58: cria\u00e7\u00e3o de um grupo de sprites e um for que cria e adiciona v\u00e1rios meteoros no grupo; Linha 72: atualiza todos os sprites de uma vez. Por tr\u00e1s dos panos o pygame percorre todos os sprites dentro daquele grupo e chama o m\u00e9todo update de cada um deles; Linha 78: desenha todos os sprites de uma vez. Por tr\u00e1s dos panos o pygame percorre todos os sprites, desenhando um por um.","title":"Adicionando mais meteoros ainda"},{"location":"aulas/10-pygame/#exercicio-8","text":"Modifique o jogo_v8 . py para que ele tenha 15 meteoros ao inv\u00e9s de 8. Al\u00e9m disso, vamos come\u00e7ar a nos preparar para implementar o jogador. Crie uma nova classe chamada Ship que tamb\u00e9m estende o tipo pygame . sprite . Sprite com a imagem assets / img / playerShip1_orange . png . A nave n\u00e3o deve se mover (n\u00e3o precisa implementar o update ). Utilize os valores self . rect . centerx = WIDTH / 2 e self . rect . bottom = HEIGHT - 10 .","title":"EXERC\u00cdCIO 8"},{"location":"aulas/10-pygame/#adicionando-a-nave","text":"O jogo_v9 . py adiciona a classe Ship e cria uma nave. Ainda n\u00e3o \u00e9 poss\u00edvel mover a nave, mas a classe j\u00e1 est\u00e1 preparada para isso. As principais mudan\u00e7as s\u00e3o: referencia/jogo_v9.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random pygame . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets METEOR_WIDTH = 50 METEOR_HEIGHT = 38 SHIP_WIDTH = 50 SHIP_HEIGHT = 38 font = pygame . font . SysFont ( None , 48 ) background = pygame . image . load ( 'assets/img/starfield.png' ) . convert () meteor_img = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () meteor_img = pygame . transform . scale ( meteor_img , ( METEOR_WIDTH , METEOR_HEIGHT )) ship_img = pygame . image . load ( 'assets/img/playerShip1_orange.png' ) . convert_alpha () ship_img = pygame . transform . scale ( ship_img , ( SHIP_WIDTH , SHIP_HEIGHT )) # ----- Inicia estruturas de dados # Definindo os novos tipos class Ship ( pygame . sprite . Sprite ): def __init__ ( self , img ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = img self . rect = self . image . get_rect () self . rect . centerx = WIDTH / 2 self . rect . bottom = HEIGHT - 10 self . speedx = 0 def update ( self ): # Atualiza\u00e7\u00e3o da posi\u00e7\u00e3o da nave self . rect . x += self . speedx # Mantem dentro da tela if self . rect . right > WIDTH : self . rect . right = WIDTH if self . rect . left < 0 : self . rect . left = 0 class Meteor ( pygame . sprite . Sprite ): def __init__ ( self , img ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = img self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) game = True # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () FPS = 30 # Criando um grupo de meteoros all_sprites = pygame . sprite . Group () # Criando o jogador player = Ship ( ship_img ) all_sprites . add ( player ) # Criando os meteoros for i in range ( 8 ): meteor = Meteor ( meteor_img ) all_sprites . add ( meteor ) # ===== Loop principal ===== while game : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : game = False # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o dos meteoros all_sprites . update () # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( background , ( 0 , 0 )) # Desenhando meteoros all_sprites . draw ( window ) pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados Linhas 23 e 24: carrega a imagem da nave e redimensiona para um tamanho menor; Linhas 28 a 47: define a classe Ship . O m\u00e9todo update atualiza a posi\u00e7\u00e3o x aplicando a velocidade e o if garante que a nave n\u00e3o saia da janela. Sempre que a nave sai da janela ela \u00e9 movida para dentro da janela novamente. Note que a nave ainda n\u00e3o vai se mover, pois a velocidade no eixo x \u00e9 zero. Al\u00e9m disso, n\u00e3o implementamos o movimento no eixo y, pois queremos que a nave apenas se mova para os lados; Linhas 79 a 82: mudan\u00e7a do nome do grupo para all_sprites , pois agora guardaremos todos os sprites nesse mesmo grupo. Uma nave \u00e9 criada e armazenada na vari\u00e1vel player . Esse player \u00e9 adicionado ao all_sprites , assim ao chamar all_sprites . update () e all_sprites . draw ( window ) , todos os meteoros e a nave ser\u00e3o atualizados e desenhados em um \u00fanico comando.","title":"Adicionando a nave"},{"location":"aulas/10-pygame/#exercicio-9","text":"Modifique o jogo_v9 . py para que a nave se mova com velocidade 5 para a esquerda. Se quiser, fa\u00e7a o seguinte teste adicional. Comente os blocos do if e else do update da nave e veja o que acontece.","title":"EXERC\u00cdCIO 9"},{"location":"aulas/10-pygame/#movimento-da-nave","text":"Finalmente vamos adicionar alguma intera\u00e7\u00e3o! Queremos que o jogador possa controlar o movimento da nave usando o teclado. Assim, quando ele apertar as setas do teclado para a esquerda ou para a direita, a nave deve se mover. Lembre-se que no in\u00edcio deste handout falamos que teclas apertadas s\u00e3o eventos. O tratamento de eventos \u00e9 uma das etapas do loop principal. At\u00e9 agora s\u00f3 utilizamos o tratamento de eventos para verificar se o usu\u00e1rio fechou a janela do jogo. O jogo_v10 . py adiciona o tratamento dos eventos das setas do teclado. As principais mudan\u00e7as est\u00e3o nas linhas 98 a 110. referencia/jogo_v10.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random pygame . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets METEOR_WIDTH = 50 METEOR_HEIGHT = 38 SHIP_WIDTH = 50 SHIP_HEIGHT = 38 font = pygame . font . SysFont ( None , 48 ) background = pygame . image . load ( 'assets/img/starfield.png' ) . convert () meteor_img = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () meteor_img = pygame . transform . scale ( meteor_img , ( METEOR_WIDTH , METEOR_HEIGHT )) ship_img = pygame . image . load ( 'assets/img/playerShip1_orange.png' ) . convert_alpha () ship_img = pygame . transform . scale ( ship_img , ( SHIP_WIDTH , SHIP_HEIGHT )) # ----- Inicia estruturas de dados # Definindo os novos tipos class Ship ( pygame . sprite . Sprite ): def __init__ ( self , img ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = img self . rect = self . image . get_rect () self . rect . centerx = WIDTH / 2 self . rect . bottom = HEIGHT - 10 self . speedx = 0 def update ( self ): # Atualiza\u00e7\u00e3o da posi\u00e7\u00e3o da nave self . rect . x += self . speedx # Mantem dentro da tela if self . rect . right > WIDTH : self . rect . right = WIDTH if self . rect . left < 0 : self . rect . left = 0 class Meteor ( pygame . sprite . Sprite ): def __init__ ( self , img ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = img self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) game = True # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () FPS = 30 # Criando um grupo de meteoros all_sprites = pygame . sprite . Group () # Criando o jogador player = Ship ( ship_img ) all_sprites . add ( player ) # Criando os meteoros for i in range ( 8 ): meteor = Meteor ( meteor_img ) all_sprites . add ( meteor ) # ===== Loop principal ===== while game : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : game = False # Verifica se apertou alguma tecla. if event . type == pygame . KEYDOWN : # Dependendo da tecla, altera a velocidade. if event . key == pygame . K_LEFT : player . speedx -= 8 if event . key == pygame . K_RIGHT : player . speedx += 8 # Verifica se soltou alguma tecla. if event . type == pygame . KEYUP : # Dependendo da tecla, altera a velocidade. if event . key == pygame . K_LEFT : player . speedx += 8 if event . key == pygame . K_RIGHT : player . speedx -= 8 # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o dos meteoros all_sprites . update () # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( background , ( 0 , 0 )) # Desenhando meteoros all_sprites . draw ( window ) pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados Quando o jogador aperta uma tecla (evento do tipo pygame . KEYDOWN ), se a tecla apertada for a seta para a direita ou para a esquerda, n\u00f3s aumentamos ou diminuimos a velocidade da nave. QUando o jogador solta a tecla (evento do tipo pygame . KEYUP ), se a tecla apertada for a seta para a direita ou para a esquerda, n\u00f3s desfazemos a a\u00e7\u00e3o daquela tecla (diminuir ou aumentar a velocidade da nave). Note que esses eventos s\u00f3 ocorrem no instante em que a tecla \u00e9 apertada. Se o jogador apertar a tecla e n\u00e3o soltar, o evento pygame . KEYDOWN s\u00f3 ser\u00e1 recebido uma vez e assim a velocidade s\u00f3 vai aumentar uma vez.","title":"Movimento da nave"},{"location":"aulas/10-pygame/#exercicio-10","text":"Modifique o jogo_v10 . py para que a nave se mova com metade da velocidade.","title":"EXERC\u00cdCIO 10"},{"location":"aulas/10-pygame/#tratamento-de-colisoes-da-nave-com-os-meteoros","text":"J\u00e1 podemos movimentar a nave, mas quando um meteoro encosta na nave, nada acontece. Queremos que o jogo acabe quando um meteoro encostar na nave. O jogo_v11 . py implementa essa funcionalidade. O pygame disponibiliza uma fun\u00e7\u00e3o que verifica se houve uma colis\u00e3o entre um sprite e um grupo de sprites, o pygame . sprite . spritecollide . Essa fun\u00e7\u00e3o recebe um sprite, um grupo de sprites e um valor booleano que indica se, ao ocorrer uma colis\u00e3o, o elemento do grupo que colidiu com o sprite deve morrer ou n\u00e3o (morrer nesse caso significa que o sprite deixar\u00e1 de existir). As principais mudan\u00e7as neste arquivo s\u00e3o: referencia/jogo_v11.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random pygame . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets METEOR_WIDTH = 50 METEOR_HEIGHT = 38 SHIP_WIDTH = 50 SHIP_HEIGHT = 38 font = pygame . font . SysFont ( None , 48 ) background = pygame . image . load ( 'assets/img/starfield.png' ) . convert () meteor_img = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () meteor_img = pygame . transform . scale ( meteor_img , ( METEOR_WIDTH , METEOR_HEIGHT )) ship_img = pygame . image . load ( 'assets/img/playerShip1_orange.png' ) . convert_alpha () ship_img = pygame . transform . scale ( ship_img , ( SHIP_WIDTH , SHIP_HEIGHT )) # ----- Inicia estruturas de dados # Definindo os novos tipos class Ship ( pygame . sprite . Sprite ): def __init__ ( self , img ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = img self . rect = self . image . get_rect () self . rect . centerx = WIDTH / 2 self . rect . bottom = HEIGHT - 10 self . speedx = 0 def update ( self ): # Atualiza\u00e7\u00e3o da posi\u00e7\u00e3o da nave self . rect . x += self . speedx # Mantem dentro da tela if self . rect . right > WIDTH : self . rect . right = WIDTH if self . rect . left < 0 : self . rect . left = 0 class Meteor ( pygame . sprite . Sprite ): def __init__ ( self , img ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = img self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) game = True # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () FPS = 30 # Criando um grupo de meteoros all_sprites = pygame . sprite . Group () all_meteors = pygame . sprite . Group () # Criando o jogador player = Ship ( ship_img ) all_sprites . add ( player ) # Criando os meteoros for i in range ( 8 ): meteor = Meteor ( meteor_img ) all_sprites . add ( meteor ) all_meteors . add ( meteor ) # ===== Loop principal ===== while game : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : game = False # Verifica se apertou alguma tecla. if event . type == pygame . KEYDOWN : # Dependendo da tecla, altera a velocidade. if event . key == pygame . K_LEFT : player . speedx -= 8 if event . key == pygame . K_RIGHT : player . speedx += 8 # Verifica se soltou alguma tecla. if event . type == pygame . KEYUP : # Dependendo da tecla, altera a velocidade. if event . key == pygame . K_LEFT : player . speedx += 8 if event . key == pygame . K_RIGHT : player . speedx -= 8 # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o dos meteoros all_sprites . update () # Verifica se houve colis\u00e3o entre nave e meteoro hits = pygame . sprite . spritecollide ( player , all_meteors , True ) # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( background , ( 0 , 0 )) # Desenhando meteoros all_sprites . draw ( window ) pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados Linhas 80 e 88: cria\u00e7\u00e3o de mais um grupo de sprites. Cada meteoro \u00e9 colocado em dois grupos, no grupo de todos os sprites ( all_sprites ), que \u00e9 utilizado para atualizar e desenhar todos os sprites na tela, e o grupo dos meteoros ( all_meteors ), que ser\u00e1 utilizado para verificar a colis\u00e3o da nave com todos os meteoros de uma vez; Linha 119: verifica a colis\u00e3o do player (nave) com o all_meteors . A fun\u00e7\u00e3o retorna uma lista com todos os meteoros que colidiram com a nave. Se ela n\u00e3o estiver vazia significa que houve uma colis\u00e3o.","title":"Tratamento de colis\u00f5es da nave com os meteoros"},{"location":"aulas/10-pygame/#exercicio-11","text":"A vers\u00e3o atual faz com que os meteoros morram ao encostar na nave, mas nada al\u00e9m disso acontece. Modifique o jogo_v11 . py para que o jogo acabe se a nave colidir com um meteoro (dica: basta verificar uma condi\u00e7\u00e3o e modificar game para False ).","title":"EXERC\u00cdCIO 11"},{"location":"aulas/10-pygame/#fazendo-a-nave-atirar","text":"Vamos implementar a funcionalidade de tiro. Queremos que um tiro seja criado quando o jogador apertar a tecla ESPA\u00c7O . Execute o jogo_v12 . py para ver o resultado. Depois abra o c\u00f3digo. referencia/jogo_v12.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random pygame . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets METEOR_WIDTH = 50 METEOR_HEIGHT = 38 SHIP_WIDTH = 50 SHIP_HEIGHT = 38 font = pygame . font . SysFont ( None , 48 ) background = pygame . image . load ( 'assets/img/starfield.png' ) . convert () meteor_img = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () meteor_img = pygame . transform . scale ( meteor_img , ( METEOR_WIDTH , METEOR_HEIGHT )) ship_img = pygame . image . load ( 'assets/img/playerShip1_orange.png' ) . convert_alpha () ship_img = pygame . transform . scale ( ship_img , ( SHIP_WIDTH , SHIP_HEIGHT )) bullet_img = pygame . image . load ( 'assets/img/laserRed16.png' ) . convert_alpha () # ----- Inicia estruturas de dados # Definindo os novos tipos class Ship ( pygame . sprite . Sprite ): def __init__ ( self , img , all_sprites , all_bullets , bullet_img ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = img self . rect = self . image . get_rect () self . rect . centerx = WIDTH / 2 self . rect . bottom = HEIGHT - 10 self . speedx = 0 self . all_sprites = all_sprites self . all_bullets = all_bullets self . bullet_img = bullet_img def update ( self ): # Atualiza\u00e7\u00e3o da posi\u00e7\u00e3o da nave self . rect . x += self . speedx # Mantem dentro da tela if self . rect . right > WIDTH : self . rect . right = WIDTH if self . rect . left < 0 : self . rect . left = 0 def shoot ( self ): # A nova bala vai ser criada logo acima e no centro horizontal da nave new_bullet = Bullet ( self . bullet_img , self . rect . top , self . rect . centerx ) self . all_sprites . add ( new_bullet ) self . all_bullets . add ( new_bullet ) class Meteor ( pygame . sprite . Sprite ): def __init__ ( self , img ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = img self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) # Classe Bullet que representa os tiros class Bullet ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , img , bottom , centerx ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = img self . rect = self . image . get_rect () # Coloca no lugar inicial definido em x, y do constutor self . rect . centerx = centerx self . rect . bottom = bottom self . speedy = - 10 # Velocidade fixa para cima def update ( self ): # A bala s\u00f3 se move no eixo y self . rect . y += self . speedy # Se o tiro passar do inicio da tela, morre. if self . rect . bottom < 0 : self . kill () game = True # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () FPS = 30 # Criando um grupo de meteoros all_sprites = pygame . sprite . Group () all_meteors = pygame . sprite . Group () all_bullets = pygame . sprite . Group () # Criando o jogador player = Ship ( ship_img , all_sprites , all_bullets , bullet_img ) all_sprites . add ( player ) # Criando os meteoros for i in range ( 8 ): meteor = Meteor ( meteor_img ) all_sprites . add ( meteor ) all_meteors . add ( meteor ) # ===== Loop principal ===== while game : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : game = False # Verifica se apertou alguma tecla. if event . type == pygame . KEYDOWN : # Dependendo da tecla, altera a velocidade. if event . key == pygame . K_LEFT : player . speedx -= 8 if event . key == pygame . K_RIGHT : player . speedx += 8 if event . key == pygame . K_SPACE : player . shoot () # Verifica se soltou alguma tecla. if event . type == pygame . KEYUP : # Dependendo da tecla, altera a velocidade. if event . key == pygame . K_LEFT : player . speedx += 8 if event . key == pygame . K_RIGHT : player . speedx -= 8 # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o dos meteoros all_sprites . update () # Verifica se houve colis\u00e3o entre nave e meteoro hits = pygame . sprite . spritecollide ( player , all_meteors , True ) if len ( hits ) > 0 : game = False # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( background , ( 0 , 0 )) # Desenhando meteoros all_sprites . draw ( window ) pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados Neste c\u00f3digo, criamos um sprite Bullet e um novo m\u00e9todo shoot na classe Ship . Esse m\u00e9todo ser\u00e1 chamado sempre que quisermos que a nave atire. O problema \u00e9 que o sprite precisa ser adicionado ao grupo de sprites para ser desenhado, mas como ele ser\u00e1 criado dentro do m\u00e9todo shoot , n\u00f3s n\u00e3o temos acesso \u00e0s vari\u00e1veis que est\u00e3o no nosso programa. A solu\u00e7\u00e3o para esse problema \u00e9 guardar o grupo dentro do jogador. Assim, quando ele atirar ele j\u00e1 ter\u00e1 acesso ao grupo para adicionar a nova bala. Fazemos isso modificando o __init__ (construtor) do Ship . Al\u00e9m da imagem da nave ele passar\u00e1 a receber o grupo de todos os sprites, um grupo para guardar as balas e a imagem da bala. Esses valores s\u00e3o guardados dentro da nave nas linhas 39 a 41. Esses valores s\u00e3o utilizados pelo m\u00e9todo shoot (linhas 53 a 57). As principais mudan\u00e7as nesta vers\u00e3o s\u00e3o: Linhas 30 e 39 a 41: quando \u00e9 criada, a nave recebe o grupo de sprites, o grupo de balas e a imagem da bala. Ela armazena esses valores nos atributos (vari\u00e1veis dispon\u00edveis no self ) para usar quando o shoot for chamado; Linhas 53 a 57: m\u00e9todo shoot . Esse m\u00e9todo ser\u00e1 chamado quando a tecla espa\u00e7o for apertada. Uma nova bala \u00e9 criada e adicionada nos grupos de sprites e de balas; Linhas 84 a 104: classe Bullet . Uma bala s\u00f3 se move para cima com velocidade 10. Quando ela n\u00e3o est\u00e1 mais vis\u00edvel ela morre ( self . kill () ); Linhas 114 e 116: um novo grupo de balas \u00e9 criado. O grupo de sprites, o grupo de balas e a imagem da bala s\u00e3o utilizadas para que um Ship seja criado. Esse Ship vai armazenar esses valores dentro de si mesmo; Linhas 140 e 141: quando a tecla ESPA\u00c7O \u00e9 apertada a nave atira. Note que n\u00e3o precisamos mudar as linhas que chamam o update dos sprites e que desenham ( draw ) todos os sprites, pois as balas tamb\u00e9m ser\u00e3o adicionadas no grupo de todos os sprites ( all_sprites ).","title":"Fazendo a nave atirar"},{"location":"aulas/10-pygame/#exercicio-12","text":"As balas ainda n\u00e3o tem nenhum efeito sobre os meteoros. Implemente a colis\u00e3o das balas com os meteoros. A fun\u00e7\u00e3o pygame . sprite . spritecollide verificava se um sprite havia colidido com algum sprite de um grupo . Agora queremos verificar se algum sprite do grupo de balas colidiu com algum sprite do grupo de meteoros. Para isso temos a fun\u00e7\u00e3o pygame . sprite . groupcollide , que recebe dois grupos de sprites e dois valores booleanos ( True ou False ) que indicam se um elemento do primeiro grupo deve morrer ao colidir com algum elemento do segundo grupo e vice-versa. Importante: essa fun\u00e7\u00e3o retorna um dicion\u00e1rio no qual as chaves s\u00e3o elementos do primeiro grupo (primeiro argumento da fun\u00e7\u00e3o) e os valores s\u00e3o listas de elementos do segundo grupo (segundo argumento) que colidiram com ele. Se esse dicion\u00e1rio estiver vazio significa que n\u00e3o houve nenhuma colis\u00e3o entre os dois grupos. Fa\u00e7a com que, ao colidirem, tanto a bala, quanto o meteoro morram. Voc\u00ea vai notar que depois de um tempo n\u00e3o haver\u00e1 mais nenhum meteoro. N\u00e3o se preocupe com isso por enquanto.","title":"EXERC\u00cdCIO 12"},{"location":"aulas/10-pygame/#adicionando-som","text":"O pygame tamb\u00e9m \u00e9 capaz de tocar sons. Para isso, al\u00e9m de carregar os arquivos de \u00e1udio, \u00e9 necess\u00e1rio inicializar o uso de sons no pygame com a fun\u00e7\u00e3o pygame . mixer . init () . O jogo_v13 . py implementa os sons de explos\u00e3o e tiro da nave. As principais modifica\u00e7\u00f5es s\u00e3o: referencia/jogo_v13.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random import time pygame . init () pygame . mixer . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets METEOR_WIDTH = 50 METEOR_HEIGHT = 38 SHIP_WIDTH = 50 SHIP_HEIGHT = 38 font = pygame . font . SysFont ( None , 48 ) background = pygame . image . load ( 'assets/img/starfield.png' ) . convert () meteor_img = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () meteor_img = pygame . transform . scale ( meteor_img , ( METEOR_WIDTH , METEOR_HEIGHT )) ship_img = pygame . image . load ( 'assets/img/playerShip1_orange.png' ) . convert_alpha () ship_img = pygame . transform . scale ( ship_img , ( SHIP_WIDTH , SHIP_HEIGHT )) bullet_img = pygame . image . load ( 'assets/img/laserRed16.png' ) . convert_alpha () # Carrega os sons do jogo pygame . mixer . music . load ( 'assets/snd/tgfcoder-FrozenJam-SeamlessLoop.ogg' ) pygame . mixer . music . set_volume ( 0.4 ) boom_sound = pygame . mixer . Sound ( 'assets/snd/expl3.wav' ) destroy_sound = pygame . mixer . Sound ( 'assets/snd/expl6.wav' ) pew_sound = pygame . mixer . Sound ( 'assets/snd/pew.wav' ) # ----- Inicia estruturas de dados # Definindo os novos tipos class Ship ( pygame . sprite . Sprite ): def __init__ ( self , img , all_sprites , all_bullets , bullet_img , pew_sound ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = img self . rect = self . image . get_rect () self . rect . centerx = WIDTH / 2 self . rect . bottom = HEIGHT - 10 self . speedx = 0 self . all_sprites = all_sprites self . all_bullets = all_bullets self . bullet_img = bullet_img self . pew_sound = pew_sound def update ( self ): # Atualiza\u00e7\u00e3o da posi\u00e7\u00e3o da nave self . rect . x += self . speedx # Mantem dentro da tela if self . rect . right > WIDTH : self . rect . right = WIDTH if self . rect . left < 0 : self . rect . left = 0 def shoot ( self ): # A nova bala vai ser criada logo acima e no centro horizontal da nave new_bullet = Bullet ( self . bullet_img , self . rect . top , self . rect . centerx ) self . all_sprites . add ( new_bullet ) self . all_bullets . add ( new_bullet ) self . pew_sound . play () class Meteor ( pygame . sprite . Sprite ): def __init__ ( self , img ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = img self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) # Classe Bullet que representa os tiros class Bullet ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , img , bottom , centerx ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = img self . rect = self . image . get_rect () # Coloca no lugar inicial definido em x, y do constutor self . rect . centerx = centerx self . rect . bottom = bottom self . speedy = - 10 # Velocidade fixa para cima def update ( self ): # A bala s\u00f3 se move no eixo y self . rect . y += self . speedy # Se o tiro passar do inicio da tela, morre. if self . rect . bottom < 0 : self . kill () game = True # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () FPS = 30 # Criando um grupo de meteoros all_sprites = pygame . sprite . Group () all_meteors = pygame . sprite . Group () all_bullets = pygame . sprite . Group () # Criando o jogador player = Ship ( ship_img , all_sprites , all_bullets , bullet_img , pew_sound ) all_sprites . add ( player ) # Criando os meteoros for i in range ( 8 ): meteor = Meteor ( meteor_img ) all_sprites . add ( meteor ) all_meteors . add ( meteor ) # ===== Loop principal ===== pygame . mixer . music . play ( loops =- 1 ) while game : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : game = False # Verifica se apertou alguma tecla. if event . type == pygame . KEYDOWN : # Dependendo da tecla, altera a velocidade. if event . key == pygame . K_LEFT : player . speedx -= 8 if event . key == pygame . K_RIGHT : player . speedx += 8 if event . key == pygame . K_SPACE : player . shoot () # Verifica se soltou alguma tecla. if event . type == pygame . KEYUP : # Dependendo da tecla, altera a velocidade. if event . key == pygame . K_LEFT : player . speedx += 8 if event . key == pygame . K_RIGHT : player . speedx -= 8 # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o dos meteoros all_sprites . update () # Verifica se houve colis\u00e3o entre tiro e meteoro hits = pygame . sprite . groupcollide ( all_meteors , all_bullets , True , True ) for meteor in hits : # As chaves s\u00e3o os elementos do primeiro grupo (meteoros) que colidiram com alguma bala # O meteoro e destruido e precisa ser recriado m = Meteor ( meteor_img ) all_sprites . add ( m ) all_meteors . add ( m ) # Verifica se houve colis\u00e3o entre nave e meteoro hits = pygame . sprite . spritecollide ( player , all_meteors , True ) if len ( hits ) > 0 : # Toca o som da colis\u00e3o boom_sound . play () time . sleep ( 1 ) # Precisa esperar sen\u00e3o fecha game = False # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( background , ( 0 , 0 )) # Desenhando meteoros all_sprites . draw ( window ) pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados Linha 8: inicializa\u00e7\u00e3o do m\u00f3dulo de \u00e1udio do pygame; Linhas 30 a 34: carrega os arquivos de \u00e1udio; Linhas 39 e 51: Ship recebe o som do tiro como argumento extra e armazena como atributo; Linha 68: toca o som do tiro; Linha 136: come\u00e7a a tocar o som de fundo em loop; Linhas 167 a 172: implementa o exerc\u00edcio 12. Verifica as colis\u00f5es entre todos os meteoros e todas as balas. Para cada meteoro que colidiu \u00e9 criado um novo meteoro para substitu\u00ed-lo; Linhas 178 e 179: toca o som de explos\u00e3o da nave e espera 1 segundo para o som terminar de tocar antes de finalizar o jogo.","title":"Adicionando som"},{"location":"aulas/10-pygame/#exercicio-13","text":"Modifique o jogo_v13 . py para tocar o destroy_sound sempre que um meteoro for destru\u00eddo.","title":"EXERC\u00cdCIO 13"},{"location":"aulas/10-pygame/#refatorando-mais-uma-vez-o-codigo","text":"O c\u00f3digo j\u00e1 est\u00e1 bastante complexo. Lembrando que \u00e9 sempre uma boa pr\u00e1tica tomar um tempo para melhorar o c\u00f3digo antes que ele se torne um caos completo, vamos refator\u00e1-lo mais um pouco. Um dos problemas \u00e9 a quantidade de argumentos que precisamos passar quando criamos um Ship (e tudo isso s\u00f3 por causa do tiro). Al\u00e9m disso, temos diversas vari\u00e1veis para as imagens e sons que carregamos. No arquivo jogo_v14 . py adicionamos todos os assets em um novo dicion\u00e1rio assets e os grupos em um dicion\u00e1rio groups . Agora \u00e9 poss\u00edvel diminuir a quantidade de argumentos recebidos na constru\u00e7\u00e3o do Ship sem ser necess\u00e1rio carregar os assets todas as vezes. referencia/jogo_v14.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random import time pygame . init () pygame . mixer . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets METEOR_WIDTH = 50 METEOR_HEIGHT = 38 SHIP_WIDTH = 50 SHIP_HEIGHT = 38 assets = {} assets [ 'background' ] = pygame . image . load ( 'assets/img/starfield.png' ) . convert () assets [ 'meteor_img' ] = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () assets [ 'meteor_img' ] = pygame . transform . scale ( assets [ 'meteor_img' ], ( METEOR_WIDTH , METEOR_HEIGHT )) assets [ 'ship_img' ] = pygame . image . load ( 'assets/img/playerShip1_orange.png' ) . convert_alpha () assets [ 'ship_img' ] = pygame . transform . scale ( assets [ 'ship_img' ], ( SHIP_WIDTH , SHIP_HEIGHT )) assets [ 'bullet_img' ] = pygame . image . load ( 'assets/img/laserRed16.png' ) . convert_alpha () # Carrega os sons do jogo pygame . mixer . music . load ( 'assets/snd/tgfcoder-FrozenJam-SeamlessLoop.ogg' ) pygame . mixer . music . set_volume ( 0.4 ) boom_sound = pygame . mixer . Sound ( 'assets/snd/expl3.wav' ) destroy_sound = pygame . mixer . Sound ( 'assets/snd/expl6.wav' ) assets [ 'pew_sound' ] = pygame . mixer . Sound ( 'assets/snd/pew.wav' ) # ----- Inicia estruturas de dados # Definindo os novos tipos class Ship ( pygame . sprite . Sprite ): def __init__ ( self , groups , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'ship_img' ] self . rect = self . image . get_rect () self . rect . centerx = WIDTH / 2 self . rect . bottom = HEIGHT - 10 self . speedx = 0 self . groups = groups self . assets = assets def update ( self ): # Atualiza\u00e7\u00e3o da posi\u00e7\u00e3o da nave self . rect . x += self . speedx # Mantem dentro da tela if self . rect . right > WIDTH : self . rect . right = WIDTH if self . rect . left < 0 : self . rect . left = 0 def shoot ( self ): # A nova bala vai ser criada logo acima e no centro horizontal da nave new_bullet = Bullet ( self . assets , self . rect . top , self . rect . centerx ) self . groups [ 'all_sprites' ] . add ( new_bullet ) self . groups [ 'all_bullets' ] . add ( new_bullet ) self . assets [ 'pew_sound' ] . play () class Meteor ( pygame . sprite . Sprite ): def __init__ ( self , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'meteor_img' ] self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) # Classe Bullet que representa os tiros class Bullet ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , assets , bottom , centerx ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'bullet_img' ] self . rect = self . image . get_rect () # Coloca no lugar inicial definido em x, y do constutor self . rect . centerx = centerx self . rect . bottom = bottom self . speedy = - 10 # Velocidade fixa para cima def update ( self ): # A bala s\u00f3 se move no eixo y self . rect . y += self . speedy # Se o tiro passar do inicio da tela, morre. if self . rect . bottom < 0 : self . kill () game = True # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () FPS = 30 # Criando um grupo de meteoros all_sprites = pygame . sprite . Group () all_meteors = pygame . sprite . Group () all_bullets = pygame . sprite . Group () groups = {} groups [ 'all_sprites' ] = all_sprites groups [ 'all_meteors' ] = all_meteors groups [ 'all_bullets' ] = all_bullets # Criando o jogador player = Ship ( groups , assets ) all_sprites . add ( player ) # Criando os meteoros for i in range ( 8 ): meteor = Meteor ( assets ) all_sprites . add ( meteor ) all_meteors . add ( meteor ) # ===== Loop principal ===== pygame . mixer . music . play ( loops =- 1 ) while game : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : game = False # Verifica se apertou alguma tecla. if event . type == pygame . KEYDOWN : # Dependendo da tecla, altera a velocidade. if event . key == pygame . K_LEFT : player . speedx -= 8 if event . key == pygame . K_RIGHT : player . speedx += 8 if event . key == pygame . K_SPACE : player . shoot () # Verifica se soltou alguma tecla. if event . type == pygame . KEYUP : # Dependendo da tecla, altera a velocidade. if event . key == pygame . K_LEFT : player . speedx += 8 if event . key == pygame . K_RIGHT : player . speedx -= 8 # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o dos meteoros all_sprites . update () # Verifica se houve colis\u00e3o entre tiro e meteoro hits = pygame . sprite . groupcollide ( all_meteors , all_bullets , True , True ) for meteor in hits : # As chaves s\u00e3o os elementos do primeiro grupo (meteoros) que colidiram com alguma bala # O meteoro e destruido e precisa ser recriado destroy_sound . play () m = Meteor ( assets ) all_sprites . add ( m ) all_meteors . add ( m ) # Verifica se houve colis\u00e3o entre nave e meteoro hits = pygame . sprite . spritecollide ( player , all_meteors , True ) if len ( hits ) > 0 : # Toca o som da colis\u00e3o boom_sound . play () time . sleep ( 1 ) # Precisa esperar sen\u00e3o fecha game = False # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( assets [ 'background' ], ( 0 , 0 )) # Desenhando meteoros all_sprites . draw ( window ) pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados","title":"Refatorando mais uma vez o c\u00f3digo"},{"location":"aulas/10-pygame/#exercicio-14","text":"Os sons boom_sound e destroy_sound ainda n\u00e3o est\u00e3o armazenados em assets . Para manter a consist\u00eancia, adicione-os no dicion\u00e1rio e atualize o c\u00f3digo necess\u00e1rio (onde esses sons s\u00e3o tocados).","title":"EXERC\u00cdCIO 14"},{"location":"aulas/10-pygame/#adicionando-animacoes","text":"As imagens do nosso jogo ainda s\u00e3o muito est\u00e1ticas. Elas se movem pela tela, mas s\u00e3o sempre as mesmas. Vamos adicionar uma anima\u00e7\u00e3o de explos\u00e3o. Para isso, vamos criar um novo sprite que atualiza a imagem em intervalos fixos de tempo. O jogo_v15 . py implementa essa anima\u00e7\u00e3o. As principais mudan\u00e7as s\u00e3o: referencia/jogo_v15.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random import time pygame . init () pygame . mixer . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets METEOR_WIDTH = 50 METEOR_HEIGHT = 38 SHIP_WIDTH = 50 SHIP_HEIGHT = 38 assets = {} assets [ 'background' ] = pygame . image . load ( 'assets/img/starfield.png' ) . convert () assets [ 'meteor_img' ] = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () assets [ 'meteor_img' ] = pygame . transform . scale ( assets [ 'meteor_img' ], ( METEOR_WIDTH , METEOR_HEIGHT )) assets [ 'ship_img' ] = pygame . image . load ( 'assets/img/playerShip1_orange.png' ) . convert_alpha () assets [ 'ship_img' ] = pygame . transform . scale ( assets [ 'ship_img' ], ( SHIP_WIDTH , SHIP_HEIGHT )) assets [ 'bullet_img' ] = pygame . image . load ( 'assets/img/laserRed16.png' ) . convert_alpha () explosion_anim = [] for i in range ( 9 ): # Os arquivos de anima\u00e7\u00e3o s\u00e3o numerados de 00 a 08 filename = 'assets/img/regularExplosion0 {} .png' . format ( i ) img = pygame . image . load ( filename ) . convert () img = pygame . transform . scale ( img , ( 32 , 32 )) explosion_anim . append ( img ) assets [ \"explosion_anim\" ] = explosion_anim # Carrega os sons do jogo pygame . mixer . music . load ( 'assets/snd/tgfcoder-FrozenJam-SeamlessLoop.ogg' ) pygame . mixer . music . set_volume ( 0.4 ) assets [ 'boom_sound' ] = pygame . mixer . Sound ( 'assets/snd/expl3.wav' ) assets [ 'destroy_sound' ] = pygame . mixer . Sound ( 'assets/snd/expl6.wav' ) assets [ 'pew_sound' ] = pygame . mixer . Sound ( 'assets/snd/pew.wav' ) # ----- Inicia estruturas de dados # Definindo os novos tipos class Ship ( pygame . sprite . Sprite ): def __init__ ( self , groups , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'ship_img' ] self . rect = self . image . get_rect () self . rect . centerx = WIDTH / 2 self . rect . bottom = HEIGHT - 10 self . speedx = 0 self . groups = groups self . assets = assets def update ( self ): # Atualiza\u00e7\u00e3o da posi\u00e7\u00e3o da nave self . rect . x += self . speedx # Mantem dentro da tela if self . rect . right > WIDTH : self . rect . right = WIDTH if self . rect . left < 0 : self . rect . left = 0 def shoot ( self ): # A nova bala vai ser criada logo acima e no centro horizontal da nave new_bullet = Bullet ( self . assets , self . rect . top , self . rect . centerx ) self . groups [ 'all_sprites' ] . add ( new_bullet ) self . groups [ 'all_bullets' ] . add ( new_bullet ) self . assets [ 'pew_sound' ] . play () class Meteor ( pygame . sprite . Sprite ): def __init__ ( self , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'meteor_img' ] self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) # Classe Bullet que representa os tiros class Bullet ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , assets , bottom , centerx ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'bullet_img' ] self . rect = self . image . get_rect () # Coloca no lugar inicial definido em x, y do constutor self . rect . centerx = centerx self . rect . bottom = bottom self . speedy = - 10 # Velocidade fixa para cima def update ( self ): # A bala s\u00f3 se move no eixo y self . rect . y += self . speedy # Se o tiro passar do inicio da tela, morre. if self . rect . bottom < 0 : self . kill () # Classe que representa uma explos\u00e3o de meteoro class Explosion ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , center , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) # Armazena a anima\u00e7\u00e3o de explos\u00e3o self . explosion_anim = assets [ 'explosion_anim' ] # Inicia o processo de anima\u00e7\u00e3o colocando a primeira imagem na tela. self . frame = 0 # Armazena o \u00edndice atual na anima\u00e7\u00e3o self . image = self . explosion_anim [ self . frame ] # Pega a primeira imagem self . rect = self . image . get_rect () self . rect . center = center # Posiciona o centro da imagem # Guarda o tick da primeira imagem, ou seja, o momento em que a imagem foi mostrada self . last_update = pygame . time . get_ticks () # Controle de ticks de anima\u00e7\u00e3o: troca de imagem a cada self.frame_ticks milissegundos. # Quando pygame.time.get_ticks() - self.last_update > self.frame_ticks a # pr\u00f3xima imagem da anima\u00e7\u00e3o ser\u00e1 mostrada self . frame_ticks = 50 def update ( self ): # Verifica o tick atual. now = pygame . time . get_ticks () # Verifica quantos ticks se passaram desde a ultima mudan\u00e7a de frame. elapsed_ticks = now - self . last_update # Se j\u00e1 est\u00e1 na hora de mudar de imagem... if elapsed_ticks > self . frame_ticks : # Marca o tick da nova imagem. self . last_update = now # Avan\u00e7a um quadro. self . frame += 1 # Verifica se j\u00e1 chegou no final da anima\u00e7\u00e3o. if self . frame == len ( self . explosion_anim ): # Se sim, tchau explos\u00e3o! self . kill () else : # Se ainda n\u00e3o chegou ao fim da explos\u00e3o, troca de imagem. center = self . rect . center self . image = self . explosion_anim [ self . frame ] self . rect = self . image . get_rect () self . rect . center = center game = True # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () FPS = 30 # Criando um grupo de meteoros all_sprites = pygame . sprite . Group () all_meteors = pygame . sprite . Group () all_bullets = pygame . sprite . Group () groups = {} groups [ 'all_sprites' ] = all_sprites groups [ 'all_meteors' ] = all_meteors groups [ 'all_bullets' ] = all_bullets # Criando o jogador player = Ship ( groups , assets ) all_sprites . add ( player ) # Criando os meteoros for i in range ( 8 ): meteor = Meteor ( assets ) all_sprites . add ( meteor ) all_meteors . add ( meteor ) # ===== Loop principal ===== pygame . mixer . music . play ( loops =- 1 ) while game : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : game = False # Verifica se apertou alguma tecla. if event . type == pygame . KEYDOWN : # Dependendo da tecla, altera a velocidade. if event . key == pygame . K_LEFT : player . speedx -= 8 if event . key == pygame . K_RIGHT : player . speedx += 8 if event . key == pygame . K_SPACE : player . shoot () # Verifica se soltou alguma tecla. if event . type == pygame . KEYUP : # Dependendo da tecla, altera a velocidade. if event . key == pygame . K_LEFT : player . speedx += 8 if event . key == pygame . K_RIGHT : player . speedx -= 8 # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o dos meteoros all_sprites . update () # Verifica se houve colis\u00e3o entre tiro e meteoro hits = pygame . sprite . groupcollide ( all_meteors , all_bullets , True , True ) for meteor in hits : # As chaves s\u00e3o os elementos do primeiro grupo (meteoros) que colidiram com alguma bala # O meteoro e destruido e precisa ser recriado assets [ 'destroy_sound' ] . play () m = Meteor ( assets ) all_sprites . add ( m ) all_meteors . add ( m ) # No lugar do meteoro antigo, adicionar uma explos\u00e3o. explosao = Explosion ( meteor . rect . center , assets ) all_sprites . add ( explosao ) # Verifica se houve colis\u00e3o entre nave e meteoro hits = pygame . sprite . spritecollide ( player , all_meteors , True ) if len ( hits ) > 0 : # Toca o som da colis\u00e3o assets [ 'boom_sound' ] . play () time . sleep ( 1 ) # Precisa esperar sen\u00e3o fecha game = False # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( assets [ 'background' ], ( 0 , 0 )) # Desenhando meteoros all_sprites . draw ( window ) pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados Linhas 28 a 35: carrega as imagens da anima\u00e7\u00e3o da explos\u00e3o e guarda em uma lista. Adiciona a lista no dicion\u00e1rio assets ; Linhas 124 a 170: classe Explosion : Linha 131: armazena a lista de imagens da anima\u00e7\u00e3o em um atributo. Uma anima\u00e7\u00e3o nada mais \u00e9 que uma sucess\u00e3o de imagens mostradas em um intervalo curto de tempo; Linhas 134 a 137: coloca a primeira imagem da anima\u00e7\u00e3o no atributo self . image e define sua posi\u00e7\u00e3o; Linha 140: armazena o instante de tempo atual. Depois que passar self . frame_ticks milissegundos a partir desse instante a pr\u00f3xima imagem ser\u00e1 mostrada; Linhas 154 a 170: m\u00e9todo de atualiza\u00e7\u00e3o. Verifica se j\u00e1 se passaram self . frame_ticks milissegundos desde que a \u00faltima imagem foi mostrada. Em caso afirmativo, mostra a pr\u00f3xima imagem. Se j\u00e1 n\u00e3o existem mais imagens para mostrar, mata o sprite. Linhas 236 e 237: cria o sprite de anima\u00e7\u00e3o de explos\u00e3o no mesmo lugar onde um meteoro foi explodido.","title":"Adicionando anima\u00e7\u00f5es"},{"location":"aulas/10-pygame/#exercicio-15","text":"Limite os tiros da nave a um tiro a cada 500 milissegundos. Dica: a l\u00f3gica ser\u00e1 semelhante \u00e0 decis\u00e3o de mostrar a pr\u00f3xima imagem da anima\u00e7\u00e3o (a resposta estar\u00e1 no jogo_v16 . py ).","title":"EXERC\u00cdCIO 15"},{"location":"aulas/10-pygame/#adicionando-estados","text":"Agora os meteoros est\u00e3o bem legais, mas e a nave? Vamos agora introduzir um truque super \u00fatil para jogos (e v\u00e1rios outros programas de computador): a m\u00e1quina de estados . Com uma m\u00e1quina de estados, o programa apresenta comportamentos diferentes para cada estados. Esse \u00e9 apenas o nome que damos para uma forma de estruturar o nosso c\u00f3digo. Na pr\u00e1tica voc\u00ea vai perceber que essa modifica\u00e7\u00e3o n\u00e3o passa de um conjunto de ifs . No nosso jogo teremos a princ\u00edpio 3 estados: DONE : o jogo terminou; PLAYING : o jogador est\u00e1 jogando; EXPLODING : a nave est\u00e1 explodindo. Nesse estado o jogador n\u00e3o pode fazer nada (se ele apertar alguma coisa no teclado nada vai acontecer). A mudan\u00e7a para m\u00e1quina de estados foi aplicada no jogo_v16 . py . Observe que no novo arquivo mudamos o mecanismo do loop de jogo. Antes us\u00e1vamos uma vari\u00e1vel booleana para indicar se o jogo estava rodando ou n\u00e3o. Agora temos uma vari\u00e1vel com um n\u00famero inteiro que indica em qual estado estamos: rodando o jogo normalmente, estado de explos\u00e3o da nave, ou se o jogo acabou. As principais mudan\u00e7as s\u00e3o: referencia/jogo_v16.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random pygame . init () pygame . mixer . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets METEOR_WIDTH = 50 METEOR_HEIGHT = 38 SHIP_WIDTH = 50 SHIP_HEIGHT = 38 assets = {} assets [ 'background' ] = pygame . image . load ( 'assets/img/starfield.png' ) . convert () assets [ 'meteor_img' ] = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () assets [ 'meteor_img' ] = pygame . transform . scale ( assets [ 'meteor_img' ], ( METEOR_WIDTH , METEOR_HEIGHT )) assets [ 'ship_img' ] = pygame . image . load ( 'assets/img/playerShip1_orange.png' ) . convert_alpha () assets [ 'ship_img' ] = pygame . transform . scale ( assets [ 'ship_img' ], ( SHIP_WIDTH , SHIP_HEIGHT )) assets [ 'bullet_img' ] = pygame . image . load ( 'assets/img/laserRed16.png' ) . convert_alpha () explosion_anim = [] for i in range ( 9 ): # Os arquivos de anima\u00e7\u00e3o s\u00e3o numerados de 00 a 08 filename = 'assets/img/regularExplosion0 {} .png' . format ( i ) img = pygame . image . load ( filename ) . convert () img = pygame . transform . scale ( img , ( 32 , 32 )) explosion_anim . append ( img ) assets [ \"explosion_anim\" ] = explosion_anim # Carrega os sons do jogo pygame . mixer . music . load ( 'assets/snd/tgfcoder-FrozenJam-SeamlessLoop.ogg' ) pygame . mixer . music . set_volume ( 0.4 ) assets [ 'boom_sound' ] = pygame . mixer . Sound ( 'assets/snd/expl3.wav' ) assets [ 'destroy_sound' ] = pygame . mixer . Sound ( 'assets/snd/expl6.wav' ) assets [ 'pew_sound' ] = pygame . mixer . Sound ( 'assets/snd/pew.wav' ) # ----- Inicia estruturas de dados # Definindo os novos tipos class Ship ( pygame . sprite . Sprite ): def __init__ ( self , groups , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'ship_img' ] self . rect = self . image . get_rect () self . rect . centerx = WIDTH / 2 self . rect . bottom = HEIGHT - 10 self . speedx = 0 self . groups = groups self . assets = assets # S\u00f3 ser\u00e1 poss\u00edvel atirar uma vez a cada 500 milissegundos self . last_shot = pygame . time . get_ticks () self . shoot_ticks = 500 def update ( self ): # Atualiza\u00e7\u00e3o da posi\u00e7\u00e3o da nave self . rect . x += self . speedx # Mantem dentro da tela if self . rect . right > WIDTH : self . rect . right = WIDTH if self . rect . left < 0 : self . rect . left = 0 def shoot ( self ): # Verifica se pode atirar now = pygame . time . get_ticks () # Verifica quantos ticks se passaram desde o \u00faltimo tiro. elapsed_ticks = now - self . last_shot # Se j\u00e1 pode atirar novamente... if elapsed_ticks > self . shoot_ticks : # Marca o tick da nova imagem. self . last_shot = now # A nova bala vai ser criada logo acima e no centro horizontal da nave new_bullet = Bullet ( self . assets , self . rect . top , self . rect . centerx ) self . groups [ 'all_sprites' ] . add ( new_bullet ) self . groups [ 'all_bullets' ] . add ( new_bullet ) self . assets [ 'pew_sound' ] . play () class Meteor ( pygame . sprite . Sprite ): def __init__ ( self , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'meteor_img' ] self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) # Classe Bullet que representa os tiros class Bullet ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , assets , bottom , centerx ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'bullet_img' ] self . rect = self . image . get_rect () # Coloca no lugar inicial definido em x, y do constutor self . rect . centerx = centerx self . rect . bottom = bottom self . speedy = - 10 # Velocidade fixa para cima def update ( self ): # A bala s\u00f3 se move no eixo y self . rect . y += self . speedy # Se o tiro passar do inicio da tela, morre. if self . rect . bottom < 0 : self . kill () # Classe que representa uma explos\u00e3o de meteoro class Explosion ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , center , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) # Armazena a anima\u00e7\u00e3o de explos\u00e3o self . explosion_anim = assets [ 'explosion_anim' ] # Inicia o processo de anima\u00e7\u00e3o colocando a primeira imagem na tela. self . frame = 0 # Armazena o \u00edndice atual na anima\u00e7\u00e3o self . image = self . explosion_anim [ self . frame ] # Pega a primeira imagem self . rect = self . image . get_rect () self . rect . center = center # Posiciona o centro da imagem # Guarda o tick da primeira imagem, ou seja, o momento em que a imagem foi mostrada self . last_update = pygame . time . get_ticks () # Controle de ticks de anima\u00e7\u00e3o: troca de imagem a cada self.frame_ticks milissegundos. # Quando pygame.time.get_ticks() - self.last_update > self.frame_ticks a # pr\u00f3xima imagem da anima\u00e7\u00e3o ser\u00e1 mostrada self . frame_ticks = 50 def update ( self ): # Verifica o tick atual. now = pygame . time . get_ticks () # Verifica quantos ticks se passaram desde a ultima mudan\u00e7a de frame. elapsed_ticks = now - self . last_update # Se j\u00e1 est\u00e1 na hora de mudar de imagem... if elapsed_ticks > self . frame_ticks : # Marca o tick da nova imagem. self . last_update = now # Avan\u00e7a um quadro. self . frame += 1 # Verifica se j\u00e1 chegou no final da anima\u00e7\u00e3o. if self . frame == len ( self . explosion_anim ): # Se sim, tchau explos\u00e3o! self . kill () else : # Se ainda n\u00e3o chegou ao fim da explos\u00e3o, troca de imagem. center = self . rect . center self . image = self . explosion_anim [ self . frame ] self . rect = self . image . get_rect () self . rect . center = center # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () FPS = 30 # Criando um grupo de meteoros all_sprites = pygame . sprite . Group () all_meteors = pygame . sprite . Group () all_bullets = pygame . sprite . Group () groups = {} groups [ 'all_sprites' ] = all_sprites groups [ 'all_meteors' ] = all_meteors groups [ 'all_bullets' ] = all_bullets # Criando o jogador player = Ship ( groups , assets ) all_sprites . add ( player ) # Criando os meteoros for i in range ( 8 ): meteor = Meteor ( assets ) all_sprites . add ( meteor ) all_meteors . add ( meteor ) DONE = 0 PLAYING = 1 EXPLODING = 2 state = PLAYING # ===== Loop principal ===== pygame . mixer . music . play ( loops =- 1 ) while state != DONE : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : state = DONE # S\u00f3 verifica o teclado se est\u00e1 no estado de jogo if state == PLAYING : # Verifica se apertou alguma tecla. if event . type == pygame . KEYDOWN : # Dependendo da tecla, altera a velocidade. if event . key == pygame . K_LEFT : player . speedx -= 8 if event . key == pygame . K_RIGHT : player . speedx += 8 if event . key == pygame . K_SPACE : player . shoot () # Verifica se soltou alguma tecla. if event . type == pygame . KEYUP : # Dependendo da tecla, altera a velocidade. if event . key == pygame . K_LEFT : player . speedx += 8 if event . key == pygame . K_RIGHT : player . speedx -= 8 # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o dos meteoros all_sprites . update () if state == PLAYING : # Verifica se houve colis\u00e3o entre tiro e meteoro hits = pygame . sprite . groupcollide ( all_meteors , all_bullets , True , True ) for meteor in hits : # As chaves s\u00e3o os elementos do primeiro grupo (meteoros) que colidiram com alguma bala # O meteoro e destruido e precisa ser recriado assets [ 'destroy_sound' ] . play () m = Meteor ( assets ) all_sprites . add ( m ) all_meteors . add ( m ) # No lugar do meteoro antigo, adicionar uma explos\u00e3o. explosao = Explosion ( meteor . rect . center , assets ) all_sprites . add ( explosao ) # Verifica se houve colis\u00e3o entre nave e meteoro hits = pygame . sprite . spritecollide ( player , all_meteors , True ) if len ( hits ) > 0 : # Toca o som da colis\u00e3o assets [ 'boom_sound' ] . play () player . kill () explosao = Explosion ( player . rect . center , assets ) all_sprites . add ( explosao ) state = EXPLODING explosion_tick = pygame . time . get_ticks () explosion_duration = explosao . frame_ticks * len ( explosao . explosion_anim ) + 400 elif state == EXPLODING : now = pygame . time . get_ticks () if now - explosion_tick > explosion_duration : state = DONE # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( assets [ 'background' ], ( 0 , 0 )) # Desenhando meteoros all_sprites . draw ( window ) pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados Linhas 59, 60 e 74 a 81: resposta do exerc\u00edcio 15; Linhas 206 a 209: definindo constantes com o valor de cada estado (poderia ser qualquer valor) e definindo o estado inicial como PLAYING . Note que apagamos a vari\u00e1vel game do c\u00f3digo inteiro; Linha 213: condi\u00e7\u00e3o do loop principal depende do estado. O jogo para quando state \u00e9 igual a DONE , ou seja, 0 ; Linha 220: muda o estado para DONE se o jogador apertou no X para fechar a janela; Linha 222: s\u00f3 aplica as consequ\u00eancias de eventos de teclado se o estado for PLAYING ; Linha 244: verifica colis\u00f5es apenas se o estado for PLAYING ; Linhas 263 a 265: mata a nave (para ela sumir) e cria uma explos\u00e3o no lugar; Linhas 266 a 268: muda o estado para EXPLODING e armazena o instante de tempo em que esse estado come\u00e7ou. A vari\u00e1vel explosion_duration guarda a dura\u00e7\u00e3o da anima\u00e7\u00e3o de explos\u00e3o com um adicional de 400 milissegundos; Linhas 269 a 272: se o estado for EXPLODING verifica se j\u00e1 passou o tempo necess\u00e1rio para a anima\u00e7\u00e3o da explos\u00e3o e depois termina o jogo (muda o estado para DONE ). Note que com o uso da m\u00e1quina de estados n\u00e3o precisamos mais do time . sleep ( 1 ) para esperar antes do jogo terminar.","title":"Adicionando estados"},{"location":"aulas/10-pygame/#exercicio-16","text":"Modifique o jogo_v16 . py para que o jogo nunca acabe, ou seja, depois que a nave termina de explodir ela ressurge na posi\u00e7\u00e3o inicial (a resposta estar\u00e1 no jogo_v17 . py ).","title":"EXERC\u00cdCIO 16"},{"location":"aulas/10-pygame/#adicionando-um-placar","text":"Vamos utilizar uma fonte com jeit\u00e3o de arcade dos anos 80. J\u00e1 vimos como desenhar texto na tela, ent\u00e3o juntando esses conhecimentos podemos mostrar o placar ao longo do jogo. O jogo_v17 . py implementa essa funcionalidade. As principais mudan\u00e7as s\u00e3o: referencia/jogo_v17.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random pygame . init () pygame . mixer . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets METEOR_WIDTH = 50 METEOR_HEIGHT = 38 SHIP_WIDTH = 50 SHIP_HEIGHT = 38 assets = {} assets [ 'background' ] = pygame . image . load ( 'assets/img/starfield.png' ) . convert () assets [ 'meteor_img' ] = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () assets [ 'meteor_img' ] = pygame . transform . scale ( assets [ 'meteor_img' ], ( METEOR_WIDTH , METEOR_HEIGHT )) assets [ 'ship_img' ] = pygame . image . load ( 'assets/img/playerShip1_orange.png' ) . convert_alpha () assets [ 'ship_img' ] = pygame . transform . scale ( assets [ 'ship_img' ], ( SHIP_WIDTH , SHIP_HEIGHT )) assets [ 'bullet_img' ] = pygame . image . load ( 'assets/img/laserRed16.png' ) . convert_alpha () explosion_anim = [] for i in range ( 9 ): # Os arquivos de anima\u00e7\u00e3o s\u00e3o numerados de 00 a 08 filename = 'assets/img/regularExplosion0 {} .png' . format ( i ) img = pygame . image . load ( filename ) . convert () img = pygame . transform . scale ( img , ( 32 , 32 )) explosion_anim . append ( img ) assets [ \"explosion_anim\" ] = explosion_anim assets [ \"score_font\" ] = pygame . font . Font ( 'assets/font/PressStart2P.ttf' , 28 ) # Carrega os sons do jogo pygame . mixer . music . load ( 'assets/snd/tgfcoder-FrozenJam-SeamlessLoop.ogg' ) pygame . mixer . music . set_volume ( 0.4 ) assets [ 'boom_sound' ] = pygame . mixer . Sound ( 'assets/snd/expl3.wav' ) assets [ 'destroy_sound' ] = pygame . mixer . Sound ( 'assets/snd/expl6.wav' ) assets [ 'pew_sound' ] = pygame . mixer . Sound ( 'assets/snd/pew.wav' ) # ----- Inicia estruturas de dados # Definindo os novos tipos class Ship ( pygame . sprite . Sprite ): def __init__ ( self , groups , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'ship_img' ] self . rect = self . image . get_rect () self . rect . centerx = WIDTH / 2 self . rect . bottom = HEIGHT - 10 self . speedx = 0 self . groups = groups self . assets = assets # S\u00f3 ser\u00e1 poss\u00edvel atirar uma vez a cada 500 milissegundos self . last_shot = pygame . time . get_ticks () self . shoot_ticks = 500 def update ( self ): # Atualiza\u00e7\u00e3o da posi\u00e7\u00e3o da nave self . rect . x += self . speedx # Mantem dentro da tela if self . rect . right > WIDTH : self . rect . right = WIDTH if self . rect . left < 0 : self . rect . left = 0 def shoot ( self ): # Verifica se pode atirar now = pygame . time . get_ticks () # Verifica quantos ticks se passaram desde o \u00faltimo tiro. elapsed_ticks = now - self . last_shot # Se j\u00e1 pode atirar novamente... if elapsed_ticks > self . shoot_ticks : # Marca o tick da nova imagem. self . last_shot = now # A nova bala vai ser criada logo acima e no centro horizontal da nave new_bullet = Bullet ( self . assets , self . rect . top , self . rect . centerx ) self . groups [ 'all_sprites' ] . add ( new_bullet ) self . groups [ 'all_bullets' ] . add ( new_bullet ) self . assets [ 'pew_sound' ] . play () class Meteor ( pygame . sprite . Sprite ): def __init__ ( self , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'meteor_img' ] self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) # Classe Bullet que representa os tiros class Bullet ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , assets , bottom , centerx ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'bullet_img' ] self . rect = self . image . get_rect () # Coloca no lugar inicial definido em x, y do constutor self . rect . centerx = centerx self . rect . bottom = bottom self . speedy = - 10 # Velocidade fixa para cima def update ( self ): # A bala s\u00f3 se move no eixo y self . rect . y += self . speedy # Se o tiro passar do inicio da tela, morre. if self . rect . bottom < 0 : self . kill () # Classe que representa uma explos\u00e3o de meteoro class Explosion ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , center , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) # Armazena a anima\u00e7\u00e3o de explos\u00e3o self . explosion_anim = assets [ 'explosion_anim' ] # Inicia o processo de anima\u00e7\u00e3o colocando a primeira imagem na tela. self . frame = 0 # Armazena o \u00edndice atual na anima\u00e7\u00e3o self . image = self . explosion_anim [ self . frame ] # Pega a primeira imagem self . rect = self . image . get_rect () self . rect . center = center # Posiciona o centro da imagem # Guarda o tick da primeira imagem, ou seja, o momento em que a imagem foi mostrada self . last_update = pygame . time . get_ticks () # Controle de ticks de anima\u00e7\u00e3o: troca de imagem a cada self.frame_ticks milissegundos. # Quando pygame.time.get_ticks() - self.last_update > self.frame_ticks a # pr\u00f3xima imagem da anima\u00e7\u00e3o ser\u00e1 mostrada self . frame_ticks = 50 def update ( self ): # Verifica o tick atual. now = pygame . time . get_ticks () # Verifica quantos ticks se passaram desde a ultima mudan\u00e7a de frame. elapsed_ticks = now - self . last_update # Se j\u00e1 est\u00e1 na hora de mudar de imagem... if elapsed_ticks > self . frame_ticks : # Marca o tick da nova imagem. self . last_update = now # Avan\u00e7a um quadro. self . frame += 1 # Verifica se j\u00e1 chegou no final da anima\u00e7\u00e3o. if self . frame == len ( self . explosion_anim ): # Se sim, tchau explos\u00e3o! self . kill () else : # Se ainda n\u00e3o chegou ao fim da explos\u00e3o, troca de imagem. center = self . rect . center self . image = self . explosion_anim [ self . frame ] self . rect = self . image . get_rect () self . rect . center = center # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () FPS = 30 # Criando um grupo de meteoros all_sprites = pygame . sprite . Group () all_meteors = pygame . sprite . Group () all_bullets = pygame . sprite . Group () groups = {} groups [ 'all_sprites' ] = all_sprites groups [ 'all_meteors' ] = all_meteors groups [ 'all_bullets' ] = all_bullets # Criando o jogador player = Ship ( groups , assets ) all_sprites . add ( player ) # Criando os meteoros for i in range ( 8 ): meteor = Meteor ( assets ) all_sprites . add ( meteor ) all_meteors . add ( meteor ) DONE = 0 PLAYING = 1 EXPLODING = 2 state = PLAYING score = 0 keys_down = {} # ===== Loop principal ===== pygame . mixer . music . play ( loops =- 1 ) while state != DONE : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : state = DONE # S\u00f3 verifica o teclado se est\u00e1 no estado de jogo if state == PLAYING : # Verifica se apertou alguma tecla. if event . type == pygame . KEYDOWN : # Dependendo da tecla, altera a velocidade. keys_down [ event . key ] = True if event . key == pygame . K_LEFT : player . speedx -= 8 if event . key == pygame . K_RIGHT : player . speedx += 8 if event . key == pygame . K_SPACE : player . shoot () # Verifica se soltou alguma tecla. if event . type == pygame . KEYUP : # Dependendo da tecla, altera a velocidade. if event . key in keys_down and keys_down [ event . key ]: if event . key == pygame . K_LEFT : player . speedx += 8 if event . key == pygame . K_RIGHT : player . speedx -= 8 # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o dos meteoros all_sprites . update () if state == PLAYING : # Verifica se houve colis\u00e3o entre tiro e meteoro hits = pygame . sprite . groupcollide ( all_meteors , all_bullets , True , True ) for meteor in hits : # As chaves s\u00e3o os elementos do primeiro grupo (meteoros) que colidiram com alguma bala # O meteoro e destruido e precisa ser recriado assets [ 'destroy_sound' ] . play () m = Meteor ( assets ) all_sprites . add ( m ) all_meteors . add ( m ) # No lugar do meteoro antigo, adicionar uma explos\u00e3o. explosao = Explosion ( meteor . rect . center , assets ) all_sprites . add ( explosao ) # Ganhou pontos! score += 100 # Verifica se houve colis\u00e3o entre nave e meteoro hits = pygame . sprite . spritecollide ( player , all_meteors , True ) if len ( hits ) > 0 : # Toca o som da colis\u00e3o assets [ 'boom_sound' ] . play () player . kill () explosao = Explosion ( player . rect . center , assets ) all_sprites . add ( explosao ) state = EXPLODING keys_down = {} explosion_tick = pygame . time . get_ticks () explosion_duration = explosao . frame_ticks * len ( explosao . explosion_anim ) + 400 elif state == EXPLODING : now = pygame . time . get_ticks () if now - explosion_tick > explosion_duration : state = PLAYING player = Ship ( groups , assets ) all_sprites . add ( player ) # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( assets [ 'background' ], ( 0 , 0 )) # Desenhando meteoros all_sprites . draw ( window ) # Desenhando o score text_surface = assets [ 'score_font' ] . render ( \" {:08d} \" . format ( score ), True , ( 255 , 255 , 0 )) text_rect = text_surface . get_rect () text_rect . midtop = ( WIDTH / 2 , 10 ) window . blit ( text_surface , text_rect ) pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados Linha 35: carrega a fonte que ser\u00e1 utilizada para mostrar o placar; Linhas 212 e 265: inicializa o placar com 0 . Toda vez que um meteoro explode o jogador ganha 100 pontos; Linhas 213, 230, 240 e 276: cria um dicion\u00e1rio de teclas que guarda se uma tecla estava pressionada ou n\u00e3o. Quando ocorre um evento de tecla levantada ( pygame . KEYUP ), verifica se essa tecla estava previamente pressionada. Isso \u00e9 necess\u00e1rio para evitar um problema quando a nave explode enquanto uma tecla est\u00e1 apertada. Nesse caso, quando a nave \u00e9 recriada e o jogador solta a tecla seria aplicada uma velocidade contr\u00e1ria. Por esse motivo, na linha 276 o dicion\u00e1rio \u00e9 apagado quando o estado muda para EXPLODING ; Linhas 282 a 284: resposta do exerc\u00edcio 16; Linhas 293 a 296: desenha o placar.","title":"Adicionando um placar"},{"location":"aulas/10-pygame/#exercicio-17","text":"Modifique o jogo_v17 . py para que o placar seja zerado quando a nave explode.","title":"EXERC\u00cdCIO 17"},{"location":"aulas/10-pygame/#sistema-de-vidas","text":"O jogo_v18 . py implementa um sistema de vidas. O jogador ter\u00e1 3 vidas. Depois que morrer 3 vezes o jogo termina. As principais mudan\u00e7as s\u00e3o: referencia/jogo_v18.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random pygame . init () pygame . mixer . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets METEOR_WIDTH = 50 METEOR_HEIGHT = 38 SHIP_WIDTH = 50 SHIP_HEIGHT = 38 assets = {} assets [ 'background' ] = pygame . image . load ( 'assets/img/starfield.png' ) . convert () assets [ 'meteor_img' ] = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () assets [ 'meteor_img' ] = pygame . transform . scale ( assets [ 'meteor_img' ], ( METEOR_WIDTH , METEOR_HEIGHT )) assets [ 'ship_img' ] = pygame . image . load ( 'assets/img/playerShip1_orange.png' ) . convert_alpha () assets [ 'ship_img' ] = pygame . transform . scale ( assets [ 'ship_img' ], ( SHIP_WIDTH , SHIP_HEIGHT )) assets [ 'bullet_img' ] = pygame . image . load ( 'assets/img/laserRed16.png' ) . convert_alpha () explosion_anim = [] for i in range ( 9 ): # Os arquivos de anima\u00e7\u00e3o s\u00e3o numerados de 00 a 08 filename = 'assets/img/regularExplosion0 {} .png' . format ( i ) img = pygame . image . load ( filename ) . convert () img = pygame . transform . scale ( img , ( 32 , 32 )) explosion_anim . append ( img ) assets [ \"explosion_anim\" ] = explosion_anim assets [ \"score_font\" ] = pygame . font . Font ( 'assets/font/PressStart2P.ttf' , 28 ) # Carrega os sons do jogo pygame . mixer . music . load ( 'assets/snd/tgfcoder-FrozenJam-SeamlessLoop.ogg' ) pygame . mixer . music . set_volume ( 0.4 ) assets [ 'boom_sound' ] = pygame . mixer . Sound ( 'assets/snd/expl3.wav' ) assets [ 'destroy_sound' ] = pygame . mixer . Sound ( 'assets/snd/expl6.wav' ) assets [ 'pew_sound' ] = pygame . mixer . Sound ( 'assets/snd/pew.wav' ) # ----- Inicia estruturas de dados # Definindo os novos tipos class Ship ( pygame . sprite . Sprite ): def __init__ ( self , groups , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'ship_img' ] self . rect = self . image . get_rect () self . rect . centerx = WIDTH / 2 self . rect . bottom = HEIGHT - 10 self . speedx = 0 self . groups = groups self . assets = assets # S\u00f3 ser\u00e1 poss\u00edvel atirar uma vez a cada 500 milissegundos self . last_shot = pygame . time . get_ticks () self . shoot_ticks = 500 def update ( self ): # Atualiza\u00e7\u00e3o da posi\u00e7\u00e3o da nave self . rect . x += self . speedx # Mantem dentro da tela if self . rect . right > WIDTH : self . rect . right = WIDTH if self . rect . left < 0 : self . rect . left = 0 def shoot ( self ): # Verifica se pode atirar now = pygame . time . get_ticks () # Verifica quantos ticks se passaram desde o \u00faltimo tiro. elapsed_ticks = now - self . last_shot # Se j\u00e1 pode atirar novamente... if elapsed_ticks > self . shoot_ticks : # Marca o tick da nova imagem. self . last_shot = now # A nova bala vai ser criada logo acima e no centro horizontal da nave new_bullet = Bullet ( self . assets , self . rect . top , self . rect . centerx ) self . groups [ 'all_sprites' ] . add ( new_bullet ) self . groups [ 'all_bullets' ] . add ( new_bullet ) self . assets [ 'pew_sound' ] . play () class Meteor ( pygame . sprite . Sprite ): def __init__ ( self , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'meteor_img' ] self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) # Classe Bullet que representa os tiros class Bullet ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , assets , bottom , centerx ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'bullet_img' ] self . rect = self . image . get_rect () # Coloca no lugar inicial definido em x, y do constutor self . rect . centerx = centerx self . rect . bottom = bottom self . speedy = - 10 # Velocidade fixa para cima def update ( self ): # A bala s\u00f3 se move no eixo y self . rect . y += self . speedy # Se o tiro passar do inicio da tela, morre. if self . rect . bottom < 0 : self . kill () # Classe que representa uma explos\u00e3o de meteoro class Explosion ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , center , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) # Armazena a anima\u00e7\u00e3o de explos\u00e3o self . explosion_anim = assets [ 'explosion_anim' ] # Inicia o processo de anima\u00e7\u00e3o colocando a primeira imagem na tela. self . frame = 0 # Armazena o \u00edndice atual na anima\u00e7\u00e3o self . image = self . explosion_anim [ self . frame ] # Pega a primeira imagem self . rect = self . image . get_rect () self . rect . center = center # Posiciona o centro da imagem # Guarda o tick da primeira imagem, ou seja, o momento em que a imagem foi mostrada self . last_update = pygame . time . get_ticks () # Controle de ticks de anima\u00e7\u00e3o: troca de imagem a cada self.frame_ticks milissegundos. # Quando pygame.time.get_ticks() - self.last_update > self.frame_ticks a # pr\u00f3xima imagem da anima\u00e7\u00e3o ser\u00e1 mostrada self . frame_ticks = 50 def update ( self ): # Verifica o tick atual. now = pygame . time . get_ticks () # Verifica quantos ticks se passaram desde a ultima mudan\u00e7a de frame. elapsed_ticks = now - self . last_update # Se j\u00e1 est\u00e1 na hora de mudar de imagem... if elapsed_ticks > self . frame_ticks : # Marca o tick da nova imagem. self . last_update = now # Avan\u00e7a um quadro. self . frame += 1 # Verifica se j\u00e1 chegou no final da anima\u00e7\u00e3o. if self . frame == len ( self . explosion_anim ): # Se sim, tchau explos\u00e3o! self . kill () else : # Se ainda n\u00e3o chegou ao fim da explos\u00e3o, troca de imagem. center = self . rect . center self . image = self . explosion_anim [ self . frame ] self . rect = self . image . get_rect () self . rect . center = center # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () FPS = 30 # Criando um grupo de meteoros all_sprites = pygame . sprite . Group () all_meteors = pygame . sprite . Group () all_bullets = pygame . sprite . Group () groups = {} groups [ 'all_sprites' ] = all_sprites groups [ 'all_meteors' ] = all_meteors groups [ 'all_bullets' ] = all_bullets # Criando o jogador player = Ship ( groups , assets ) all_sprites . add ( player ) # Criando os meteoros for i in range ( 8 ): meteor = Meteor ( assets ) all_sprites . add ( meteor ) all_meteors . add ( meteor ) DONE = 0 PLAYING = 1 EXPLODING = 2 state = PLAYING keys_down = {} score = 0 lives = 3 # ===== Loop principal ===== pygame . mixer . music . play ( loops =- 1 ) while state != DONE : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : state = DONE # S\u00f3 verifica o teclado se est\u00e1 no estado de jogo if state == PLAYING : # Verifica se apertou alguma tecla. if event . type == pygame . KEYDOWN : # Dependendo da tecla, altera a velocidade. keys_down [ event . key ] = True if event . key == pygame . K_LEFT : player . speedx -= 8 if event . key == pygame . K_RIGHT : player . speedx += 8 if event . key == pygame . K_SPACE : player . shoot () # Verifica se soltou alguma tecla. if event . type == pygame . KEYUP : # Dependendo da tecla, altera a velocidade. if event . key in keys_down and keys_down [ event . key ]: if event . key == pygame . K_LEFT : player . speedx += 8 if event . key == pygame . K_RIGHT : player . speedx -= 8 # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o dos meteoros all_sprites . update () if state == PLAYING : # Verifica se houve colis\u00e3o entre tiro e meteoro hits = pygame . sprite . groupcollide ( all_meteors , all_bullets , True , True ) for meteor in hits : # As chaves s\u00e3o os elementos do primeiro grupo (meteoros) que colidiram com alguma bala # O meteoro e destruido e precisa ser recriado assets [ 'destroy_sound' ] . play () m = Meteor ( assets ) all_sprites . add ( m ) all_meteors . add ( m ) # No lugar do meteoro antigo, adicionar uma explos\u00e3o. explosao = Explosion ( meteor . rect . center , assets ) all_sprites . add ( explosao ) # Ganhou pontos! score += 100 # Verifica se houve colis\u00e3o entre nave e meteoro hits = pygame . sprite . spritecollide ( player , all_meteors , True ) if len ( hits ) > 0 : # Toca o som da colis\u00e3o assets [ 'boom_sound' ] . play () player . kill () lives -= 1 explosao = Explosion ( player . rect . center , assets ) all_sprites . add ( explosao ) state = EXPLODING keys_down = {} explosion_tick = pygame . time . get_ticks () explosion_duration = explosao . frame_ticks * len ( explosao . explosion_anim ) + 400 elif state == EXPLODING : now = pygame . time . get_ticks () if now - explosion_tick > explosion_duration : if lives == 0 : state = DONE else : state = PLAYING player = Ship ( groups , assets ) all_sprites . add ( player ) # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( assets [ 'background' ], ( 0 , 0 )) # Desenhando meteoros all_sprites . draw ( window ) # Desenhando o score text_surface = assets [ 'score_font' ] . render ( \" {:08d} \" . format ( score ), True , ( 255 , 255 , 0 )) text_rect = text_surface . get_rect () text_rect . midtop = ( WIDTH / 2 , 10 ) window . blit ( text_surface , text_rect ) # Desenhando as vidas text_surface = assets [ 'score_font' ] . render ( chr ( 9829 ) * lives , True , ( 255 , 0 , 0 )) text_rect = text_surface . get_rect () text_rect . bottomleft = ( 10 , HEIGHT - 10 ) window . blit ( text_surface , text_rect ) pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados Linhas 214 e 274: inicializa o n\u00famero de vidas com 3 e diminui toda vez que a nave explode; Linhas 284 a 286: se a quantidade de vidas chegar a zero o jogo termina; Linhas 304 a 307: desenha as vidas.","title":"Sistema de vidas"},{"location":"aulas/10-pygame/#exercicio-18","text":"Modifique o jogo_v18 . py para que o jogador ganhe automaticamente uma vida a cada 1.000 pontos. A resposta estar\u00e1 no jogo_v19 . py .","title":"EXERC\u00cdCIO 18"},{"location":"aulas/10-pygame/#melhorando-a-colisao","text":"Talvez voc\u00ea tenha percebido que a colis\u00e3o entre sprites nem sempre \u00e9 muito boa. Isso acontece porque as colis\u00f5es s\u00e3o feitas por padr\u00e3o entre as imagens, ou seja, entre os ret\u00e2ngulos (mesmo que sejam transparentes). O jogo_v19 . py utiliza uma fun\u00e7\u00e3o mais precisa de colis\u00e3o. Para isso \u00e9 necess\u00e1rio criar m\u00e1scaras de colis\u00e3o. Uma m\u00e1scara de colis\u00e3o \u00e9 uma imagem na qual os valores iguais a zero ser\u00e3o ignorados no teste de colis\u00e3o. Para utilizar a colis\u00e3o entre m\u00e1scaras \u00e9 necess\u00e1rio que o sprite possua um atributo mask . As principais mudan\u00e7as s\u00e3o: referencia/jogo_v19.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random pygame . init () pygame . mixer . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets METEOR_WIDTH = 50 METEOR_HEIGHT = 38 SHIP_WIDTH = 50 SHIP_HEIGHT = 38 assets = {} assets [ 'background' ] = pygame . image . load ( 'assets/img/starfield.png' ) . convert () assets [ 'meteor_img' ] = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () assets [ 'meteor_img' ] = pygame . transform . scale ( assets [ 'meteor_img' ], ( METEOR_WIDTH , METEOR_HEIGHT )) assets [ 'ship_img' ] = pygame . image . load ( 'assets/img/playerShip1_orange.png' ) . convert_alpha () assets [ 'ship_img' ] = pygame . transform . scale ( assets [ 'ship_img' ], ( SHIP_WIDTH , SHIP_HEIGHT )) assets [ 'bullet_img' ] = pygame . image . load ( 'assets/img/laserRed16.png' ) . convert_alpha () explosion_anim = [] for i in range ( 9 ): # Os arquivos de anima\u00e7\u00e3o s\u00e3o numerados de 00 a 08 filename = 'assets/img/regularExplosion0 {} .png' . format ( i ) img = pygame . image . load ( filename ) . convert () img = pygame . transform . scale ( img , ( 32 , 32 )) explosion_anim . append ( img ) assets [ \"explosion_anim\" ] = explosion_anim assets [ \"score_font\" ] = pygame . font . Font ( 'assets/font/PressStart2P.ttf' , 28 ) # Carrega os sons do jogo pygame . mixer . music . load ( 'assets/snd/tgfcoder-FrozenJam-SeamlessLoop.ogg' ) pygame . mixer . music . set_volume ( 0.4 ) assets [ 'boom_sound' ] = pygame . mixer . Sound ( 'assets/snd/expl3.wav' ) assets [ 'destroy_sound' ] = pygame . mixer . Sound ( 'assets/snd/expl6.wav' ) assets [ 'pew_sound' ] = pygame . mixer . Sound ( 'assets/snd/pew.wav' ) # ----- Inicia estruturas de dados # Definindo os novos tipos class Ship ( pygame . sprite . Sprite ): def __init__ ( self , groups , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'ship_img' ] self . mask = pygame . mask . from_surface ( self . image ) self . rect = self . image . get_rect () self . rect . centerx = WIDTH / 2 self . rect . bottom = HEIGHT - 10 self . speedx = 0 self . groups = groups self . assets = assets # S\u00f3 ser\u00e1 poss\u00edvel atirar uma vez a cada 500 milissegundos self . last_shot = pygame . time . get_ticks () self . shoot_ticks = 500 def update ( self ): # Atualiza\u00e7\u00e3o da posi\u00e7\u00e3o da nave self . rect . x += self . speedx # Mantem dentro da tela if self . rect . right > WIDTH : self . rect . right = WIDTH if self . rect . left < 0 : self . rect . left = 0 def shoot ( self ): # Verifica se pode atirar now = pygame . time . get_ticks () # Verifica quantos ticks se passaram desde o \u00faltimo tiro. elapsed_ticks = now - self . last_shot # Se j\u00e1 pode atirar novamente... if elapsed_ticks > self . shoot_ticks : # Marca o tick da nova imagem. self . last_shot = now # A nova bala vai ser criada logo acima e no centro horizontal da nave new_bullet = Bullet ( self . assets , self . rect . top , self . rect . centerx ) self . groups [ 'all_sprites' ] . add ( new_bullet ) self . groups [ 'all_bullets' ] . add ( new_bullet ) self . assets [ 'pew_sound' ] . play () class Meteor ( pygame . sprite . Sprite ): def __init__ ( self , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'meteor_img' ] self . mask = pygame . mask . from_surface ( self . image ) self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) # Classe Bullet que representa os tiros class Bullet ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , assets , bottom , centerx ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'bullet_img' ] self . mask = pygame . mask . from_surface ( self . image ) self . rect = self . image . get_rect () # Coloca no lugar inicial definido em x, y do constutor self . rect . centerx = centerx self . rect . bottom = bottom self . speedy = - 10 # Velocidade fixa para cima def update ( self ): # A bala s\u00f3 se move no eixo y self . rect . y += self . speedy # Se o tiro passar do inicio da tela, morre. if self . rect . bottom < 0 : self . kill () # Classe que representa uma explos\u00e3o de meteoro class Explosion ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , center , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) # Armazena a anima\u00e7\u00e3o de explos\u00e3o self . explosion_anim = assets [ 'explosion_anim' ] # Inicia o processo de anima\u00e7\u00e3o colocando a primeira imagem na tela. self . frame = 0 # Armazena o \u00edndice atual na anima\u00e7\u00e3o self . image = self . explosion_anim [ self . frame ] # Pega a primeira imagem self . rect = self . image . get_rect () self . rect . center = center # Posiciona o centro da imagem # Guarda o tick da primeira imagem, ou seja, o momento em que a imagem foi mostrada self . last_update = pygame . time . get_ticks () # Controle de ticks de anima\u00e7\u00e3o: troca de imagem a cada self.frame_ticks milissegundos. # Quando pygame.time.get_ticks() - self.last_update > self.frame_ticks a # pr\u00f3xima imagem da anima\u00e7\u00e3o ser\u00e1 mostrada self . frame_ticks = 50 def update ( self ): # Verifica o tick atual. now = pygame . time . get_ticks () # Verifica quantos ticks se passaram desde a ultima mudan\u00e7a de frame. elapsed_ticks = now - self . last_update # Se j\u00e1 est\u00e1 na hora de mudar de imagem... if elapsed_ticks > self . frame_ticks : # Marca o tick da nova imagem. self . last_update = now # Avan\u00e7a um quadro. self . frame += 1 # Verifica se j\u00e1 chegou no final da anima\u00e7\u00e3o. if self . frame == len ( self . explosion_anim ): # Se sim, tchau explos\u00e3o! self . kill () else : # Se ainda n\u00e3o chegou ao fim da explos\u00e3o, troca de imagem. center = self . rect . center self . image = self . explosion_anim [ self . frame ] self . rect = self . image . get_rect () self . rect . center = center # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () FPS = 30 # Criando um grupo de meteoros all_sprites = pygame . sprite . Group () all_meteors = pygame . sprite . Group () all_bullets = pygame . sprite . Group () groups = {} groups [ 'all_sprites' ] = all_sprites groups [ 'all_meteors' ] = all_meteors groups [ 'all_bullets' ] = all_bullets # Criando o jogador player = Ship ( groups , assets ) all_sprites . add ( player ) # Criando os meteoros for i in range ( 8 ): meteor = Meteor ( assets ) all_sprites . add ( meteor ) all_meteors . add ( meteor ) DONE = 0 PLAYING = 1 EXPLODING = 2 state = PLAYING keys_down = {} score = 0 lives = 3 # ===== Loop principal ===== pygame . mixer . music . play ( loops =- 1 ) while state != DONE : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : state = DONE # S\u00f3 verifica o teclado se est\u00e1 no estado de jogo if state == PLAYING : # Verifica se apertou alguma tecla. if event . type == pygame . KEYDOWN : # Dependendo da tecla, altera a velocidade. keys_down [ event . key ] = True if event . key == pygame . K_LEFT : player . speedx -= 8 if event . key == pygame . K_RIGHT : player . speedx += 8 if event . key == pygame . K_SPACE : player . shoot () # Verifica se soltou alguma tecla. if event . type == pygame . KEYUP : # Dependendo da tecla, altera a velocidade. if event . key in keys_down and keys_down [ event . key ]: if event . key == pygame . K_LEFT : player . speedx += 8 if event . key == pygame . K_RIGHT : player . speedx -= 8 # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o dos meteoros all_sprites . update () if state == PLAYING : # Verifica se houve colis\u00e3o entre tiro e meteoro hits = pygame . sprite . groupcollide ( all_meteors , all_bullets , True , True , pygame . sprite . collide_mask ) for meteor in hits : # As chaves s\u00e3o os elementos do primeiro grupo (meteoros) que colidiram com alguma bala # O meteoro e destruido e precisa ser recriado assets [ 'destroy_sound' ] . play () m = Meteor ( assets ) all_sprites . add ( m ) all_meteors . add ( m ) # No lugar do meteoro antigo, adicionar uma explos\u00e3o. explosao = Explosion ( meteor . rect . center , assets ) all_sprites . add ( explosao ) # Ganhou pontos! score += 100 if score % 1000 == 0 : lives += 1 # Verifica se houve colis\u00e3o entre nave e meteoro hits = pygame . sprite . spritecollide ( player , all_meteors , True , pygame . sprite . collide_mask ) if len ( hits ) > 0 : # Toca o som da colis\u00e3o assets [ 'boom_sound' ] . play () player . kill () lives -= 1 explosao = Explosion ( player . rect . center , assets ) all_sprites . add ( explosao ) state = EXPLODING keys_down = {} explosion_tick = pygame . time . get_ticks () explosion_duration = explosao . frame_ticks * len ( explosao . explosion_anim ) + 400 elif state == EXPLODING : now = pygame . time . get_ticks () if now - explosion_tick > explosion_duration : if lives == 0 : state = DONE else : state = PLAYING player = Ship ( groups , assets ) all_sprites . add ( player ) # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( assets [ 'background' ], ( 0 , 0 )) # Desenhando meteoros all_sprites . draw ( window ) # Desenhando o score text_surface = assets [ 'score_font' ] . render ( \" {:08d} \" . format ( score ), True , ( 255 , 255 , 0 )) text_rect = text_surface . get_rect () text_rect . midtop = ( WIDTH / 2 , 10 ) window . blit ( text_surface , text_rect ) # Desenhando as vidas text_surface = assets [ 'score_font' ] . render ( chr ( 9829 ) * lives , True , ( 255 , 0 , 0 )) text_rect = text_surface . get_rect () text_rect . bottomleft = ( 10 , HEIGHT - 10 ) window . blit ( text_surface , text_rect ) pygame . display . update () # Mostra o novo frame para o jogador # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados Linhas 52, 96 e 123: cria as m\u00e1scaras de colis\u00e3o a partir da imagem do sprite; Linhas 256 e 274: define que as colis\u00f5es devem ser realizadas usando m\u00e1scaras; Linhas 270 e 271: resposta do exerc\u00edcio 18.","title":"Melhorando a colis\u00e3o"},{"location":"aulas/10-pygame/#separando-o-codigo-em-mais-funcoes","text":"Este c\u00f3digo est\u00e1 ficando muito grande! Est\u00e1 na hora de quebrar esse monolito em fun\u00e7\u00f5es simples. Isso vai facilitar o desenvolvimento de novas telas de jogo. O jogo_v20 . py cria as fun\u00e7\u00f5es load_assets e game_screen que extraem o carregamento dos assets e a l\u00f3gica do jogo. Nessa vers\u00e3o n\u00e3o existe nenhuma mudan\u00e7a, visualmente falando, mas essa refatora\u00e7\u00e3o vai ser bastante \u00fatil para o pr\u00f3ximo passo. Principais mudan\u00e7as: referencia/jogo_v20.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random pygame . init () pygame . mixer . init () # ----- Gera tela principal WIDTH = 480 HEIGHT = 600 window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) # ----- Inicia assets FPS = 30 METEOR_WIDTH = 50 METEOR_HEIGHT = 38 SHIP_WIDTH = 50 SHIP_HEIGHT = 38 def load_assets (): assets = {} assets [ 'background' ] = pygame . image . load ( 'assets/img/starfield.png' ) . convert () assets [ 'meteor_img' ] = pygame . image . load ( 'assets/img/meteorBrown_med1.png' ) . convert_alpha () assets [ 'meteor_img' ] = pygame . transform . scale ( assets [ 'meteor_img' ], ( METEOR_WIDTH , METEOR_HEIGHT )) assets [ 'ship_img' ] = pygame . image . load ( 'assets/img/playerShip1_orange.png' ) . convert_alpha () assets [ 'ship_img' ] = pygame . transform . scale ( assets [ 'ship_img' ], ( SHIP_WIDTH , SHIP_HEIGHT )) assets [ 'bullet_img' ] = pygame . image . load ( 'assets/img/laserRed16.png' ) . convert_alpha () explosion_anim = [] for i in range ( 9 ): # Os arquivos de anima\u00e7\u00e3o s\u00e3o numerados de 00 a 08 filename = 'assets/img/regularExplosion0 {} .png' . format ( i ) img = pygame . image . load ( filename ) . convert () img = pygame . transform . scale ( img , ( 32 , 32 )) explosion_anim . append ( img ) assets [ \"explosion_anim\" ] = explosion_anim assets [ \"score_font\" ] = pygame . font . Font ( 'assets/font/PressStart2P.ttf' , 28 ) # Carrega os sons do jogo pygame . mixer . music . load ( 'assets/snd/tgfcoder-FrozenJam-SeamlessLoop.ogg' ) pygame . mixer . music . set_volume ( 0.4 ) assets [ 'boom_sound' ] = pygame . mixer . Sound ( 'assets/snd/expl3.wav' ) assets [ 'destroy_sound' ] = pygame . mixer . Sound ( 'assets/snd/expl6.wav' ) assets [ 'pew_sound' ] = pygame . mixer . Sound ( 'assets/snd/pew.wav' ) return assets # ----- Inicia estruturas de dados # Definindo os novos tipos class Ship ( pygame . sprite . Sprite ): def __init__ ( self , groups , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'ship_img' ] self . mask = pygame . mask . from_surface ( self . image ) self . rect = self . image . get_rect () self . rect . centerx = WIDTH / 2 self . rect . bottom = HEIGHT - 10 self . speedx = 0 self . groups = groups self . assets = assets # S\u00f3 ser\u00e1 poss\u00edvel atirar uma vez a cada 500 milissegundos self . last_shot = pygame . time . get_ticks () self . shoot_ticks = 500 def update ( self ): # Atualiza\u00e7\u00e3o da posi\u00e7\u00e3o da nave self . rect . x += self . speedx # Mantem dentro da tela if self . rect . right > WIDTH : self . rect . right = WIDTH if self . rect . left < 0 : self . rect . left = 0 def shoot ( self ): # Verifica se pode atirar now = pygame . time . get_ticks () # Verifica quantos ticks se passaram desde o \u00faltimo tiro. elapsed_ticks = now - self . last_shot # Se j\u00e1 pode atirar novamente... if elapsed_ticks > self . shoot_ticks : # Marca o tick da nova imagem. self . last_shot = now # A nova bala vai ser criada logo acima e no centro horizontal da nave new_bullet = Bullet ( self . assets , self . rect . top , self . rect . centerx ) self . groups [ 'all_sprites' ] . add ( new_bullet ) self . groups [ 'all_bullets' ] . add ( new_bullet ) self . assets [ 'pew_sound' ] . play () class Meteor ( pygame . sprite . Sprite ): def __init__ ( self , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'meteor_img' ] self . mask = pygame . mask . from_surface ( self . image ) self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) # Classe Bullet que representa os tiros class Bullet ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , assets , bottom , centerx ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ 'bullet_img' ] self . mask = pygame . mask . from_surface ( self . image ) self . rect = self . image . get_rect () # Coloca no lugar inicial definido em x, y do constutor self . rect . centerx = centerx self . rect . bottom = bottom self . speedy = - 10 # Velocidade fixa para cima def update ( self ): # A bala s\u00f3 se move no eixo y self . rect . y += self . speedy # Se o tiro passar do inicio da tela, morre. if self . rect . bottom < 0 : self . kill () # Classe que representa uma explos\u00e3o de meteoro class Explosion ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , center , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) # Armazena a anima\u00e7\u00e3o de explos\u00e3o self . explosion_anim = assets [ 'explosion_anim' ] # Inicia o processo de anima\u00e7\u00e3o colocando a primeira imagem na tela. self . frame = 0 # Armazena o \u00edndice atual na anima\u00e7\u00e3o self . image = self . explosion_anim [ self . frame ] # Pega a primeira imagem self . rect = self . image . get_rect () self . rect . center = center # Posiciona o centro da imagem # Guarda o tick da primeira imagem, ou seja, o momento em que a imagem foi mostrada self . last_update = pygame . time . get_ticks () # Controle de ticks de anima\u00e7\u00e3o: troca de imagem a cada self.frame_ticks milissegundos. # Quando pygame.time.get_ticks() - self.last_update > self.frame_ticks a # pr\u00f3xima imagem da anima\u00e7\u00e3o ser\u00e1 mostrada self . frame_ticks = 50 def update ( self ): # Verifica o tick atual. now = pygame . time . get_ticks () # Verifica quantos ticks se passaram desde a ultima mudan\u00e7a de frame. elapsed_ticks = now - self . last_update # Se j\u00e1 est\u00e1 na hora de mudar de imagem... if elapsed_ticks > self . frame_ticks : # Marca o tick da nova imagem. self . last_update = now # Avan\u00e7a um quadro. self . frame += 1 # Verifica se j\u00e1 chegou no final da anima\u00e7\u00e3o. if self . frame == len ( self . explosion_anim ): # Se sim, tchau explos\u00e3o! self . kill () else : # Se ainda n\u00e3o chegou ao fim da explos\u00e3o, troca de imagem. center = self . rect . center self . image = self . explosion_anim [ self . frame ] self . rect = self . image . get_rect () self . rect . center = center def game_screen ( window ): # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () assets = load_assets () # Criando um grupo de meteoros all_sprites = pygame . sprite . Group () all_meteors = pygame . sprite . Group () all_bullets = pygame . sprite . Group () groups = {} groups [ 'all_sprites' ] = all_sprites groups [ 'all_meteors' ] = all_meteors groups [ 'all_bullets' ] = all_bullets # Criando o jogador player = Ship ( groups , assets ) all_sprites . add ( player ) # Criando os meteoros for i in range ( 8 ): meteor = Meteor ( assets ) all_sprites . add ( meteor ) all_meteors . add ( meteor ) DONE = 0 PLAYING = 1 EXPLODING = 2 state = PLAYING keys_down = {} score = 0 lives = 3 # ===== Loop principal ===== pygame . mixer . music . play ( loops =- 1 ) while state != DONE : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : state = DONE # S\u00f3 verifica o teclado se est\u00e1 no estado de jogo if state == PLAYING : # Verifica se apertou alguma tecla. if event . type == pygame . KEYDOWN : # Dependendo da tecla, altera a velocidade. keys_down [ event . key ] = True if event . key == pygame . K_LEFT : player . speedx -= 8 if event . key == pygame . K_RIGHT : player . speedx += 8 if event . key == pygame . K_SPACE : player . shoot () # Verifica se soltou alguma tecla. if event . type == pygame . KEYUP : # Dependendo da tecla, altera a velocidade. if event . key in keys_down and keys_down [ event . key ]: if event . key == pygame . K_LEFT : player . speedx += 8 if event . key == pygame . K_RIGHT : player . speedx -= 8 # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o dos meteoros all_sprites . update () if state == PLAYING : # Verifica se houve colis\u00e3o entre tiro e meteoro hits = pygame . sprite . groupcollide ( all_meteors , all_bullets , True , True , pygame . sprite . collide_mask ) for meteor in hits : # As chaves s\u00e3o os elementos do primeiro grupo (meteoros) que colidiram com alguma bala # O meteoro e destruido e precisa ser recriado assets [ 'destroy_sound' ] . play () m = Meteor ( assets ) all_sprites . add ( m ) all_meteors . add ( m ) # No lugar do meteoro antigo, adicionar uma explos\u00e3o. explosao = Explosion ( meteor . rect . center , assets ) all_sprites . add ( explosao ) # Ganhou pontos! score += 100 if score % 1000 == 0 : lives += 1 # Verifica se houve colis\u00e3o entre nave e meteoro hits = pygame . sprite . spritecollide ( player , all_meteors , True , pygame . sprite . collide_mask ) if len ( hits ) > 0 : # Toca o som da colis\u00e3o assets [ 'boom_sound' ] . play () player . kill () lives -= 1 explosao = Explosion ( player . rect . center , assets ) all_sprites . add ( explosao ) state = EXPLODING keys_down = {} explosion_tick = pygame . time . get_ticks () explosion_duration = explosao . frame_ticks * len ( explosao . explosion_anim ) + 400 elif state == EXPLODING : now = pygame . time . get_ticks () if now - explosion_tick > explosion_duration : if lives == 0 : state = DONE else : state = PLAYING player = Ship ( groups , assets ) all_sprites . add ( player ) # ----- Gera sa\u00eddas window . fill (( 0 , 0 , 0 )) # Preenche com a cor branca window . blit ( assets [ 'background' ], ( 0 , 0 )) # Desenhando meteoros all_sprites . draw ( window ) # Desenhando o score text_surface = assets [ 'score_font' ] . render ( \" {:08d} \" . format ( score ), True , ( 255 , 255 , 0 )) text_rect = text_surface . get_rect () text_rect . midtop = ( WIDTH / 2 , 10 ) window . blit ( text_surface , text_rect ) # Desenhando as vidas text_surface = assets [ 'score_font' ] . render ( chr ( 9829 ) * lives , True , ( 255 , 0 , 0 )) text_rect = text_surface . get_rect () text_rect . bottomleft = ( 10 , HEIGHT - 10 ) window . blit ( text_surface , text_rect ) pygame . display . update () # Mostra o novo frame para o jogador game_screen ( window ) # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados Linhas 22 a 46: fun\u00e7\u00e3o que carrega os assets. \u00c9 exatamente o mesmo c\u00f3digo de antes, mas agora dentro de uma fun\u00e7\u00e3o; Linhas 192 a 320: fun\u00e7\u00e3o que executa o loop principal. \u00c9 exatamente o mesmo c\u00f3digo de antes, mas agora dentro de uma fun\u00e7\u00e3o.","title":"Separando o c\u00f3digo em mais fun\u00e7\u00f5es"},{"location":"aulas/10-pygame/#separando-o-codigo-em-arquivos-diferentes","text":"Abra o arquivo jogo_21 . py . Onde est\u00e1 todo aquele c\u00f3digo? O c\u00f3digo do arquivo jogo_20 . py foi separado em 5 arquivos: jogo_21 . py - possui apenas a l\u00f3gica mais geral do jogo: inicializa o pygame, chama a tela do jogo e finaliza o pygame; referencia/jogo_v21.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random from config import WIDTH , HEIGHT from game_screen import game_screen pygame . init () pygame . mixer . init () # ----- Gera tela principal window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) game_screen ( window ) # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados game_screen . py - fun\u00e7\u00e3o com o loop principal do jogo; referencia/game_screen.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 import pygame from config import FPS , WIDTH , HEIGHT , BLACK , YELLOW , RED from assets import load_assets , DESTROY_SOUND , BOOM_SOUND , BACKGROUND , SCORE_FONT from sprites import Ship , Meteor , Bullet , Explosion def game_screen ( window ): # Vari\u00e1vel para o ajuste de velocidade clock = pygame . time . Clock () assets = load_assets () # Criando um grupo de meteoros all_sprites = pygame . sprite . Group () all_meteors = pygame . sprite . Group () all_bullets = pygame . sprite . Group () groups = {} groups [ 'all_sprites' ] = all_sprites groups [ 'all_meteors' ] = all_meteors groups [ 'all_bullets' ] = all_bullets # Criando o jogador player = Ship ( groups , assets ) all_sprites . add ( player ) # Criando os meteoros for i in range ( 8 ): meteor = Meteor ( assets ) all_sprites . add ( meteor ) all_meteors . add ( meteor ) DONE = 0 PLAYING = 1 EXPLODING = 2 state = PLAYING keys_down = {} score = 0 lives = 3 # ===== Loop principal ===== pygame . mixer . music . play ( loops =- 1 ) while state != DONE : clock . tick ( FPS ) # ----- Trata eventos for event in pygame . event . get (): # ----- Verifica consequ\u00eancias if event . type == pygame . QUIT : state = DONE # S\u00f3 verifica o teclado se est\u00e1 no estado de jogo if state == PLAYING : # Verifica se apertou alguma tecla. if event . type == pygame . KEYDOWN : # Dependendo da tecla, altera a velocidade. keys_down [ event . key ] = True if event . key == pygame . K_LEFT : player . speedx -= 8 if event . key == pygame . K_RIGHT : player . speedx += 8 if event . key == pygame . K_SPACE : player . shoot () # Verifica se soltou alguma tecla. if event . type == pygame . KEYUP : # Dependendo da tecla, altera a velocidade. if event . key in keys_down and keys_down [ event . key ]: if event . key == pygame . K_LEFT : player . speedx += 8 if event . key == pygame . K_RIGHT : player . speedx -= 8 # ----- Atualiza estado do jogo # Atualizando a posi\u00e7\u00e3o dos meteoros all_sprites . update () if state == PLAYING : # Verifica se houve colis\u00e3o entre tiro e meteoro hits = pygame . sprite . groupcollide ( all_meteors , all_bullets , True , True , pygame . sprite . collide_mask ) for meteor in hits : # As chaves s\u00e3o os elementos do primeiro grupo (meteoros) que colidiram com alguma bala # O meteoro e destruido e precisa ser recriado assets [ DESTROY_SOUND ] . play () m = Meteor ( assets ) all_sprites . add ( m ) all_meteors . add ( m ) # No lugar do meteoro antigo, adicionar uma explos\u00e3o. explosao = Explosion ( meteor . rect . center , assets ) all_sprites . add ( explosao ) # Ganhou pontos! score += 100 if score % 1000 == 0 : lives += 1 # Verifica se houve colis\u00e3o entre nave e meteoro hits = pygame . sprite . spritecollide ( player , all_meteors , True , pygame . sprite . collide_mask ) if len ( hits ) > 0 : # Toca o som da colis\u00e3o assets [ BOOM_SOUND ] . play () player . kill () lives -= 1 explosao = Explosion ( player . rect . center , assets ) all_sprites . add ( explosao ) state = EXPLODING keys_down = {} explosion_tick = pygame . time . get_ticks () explosion_duration = explosao . frame_ticks * len ( explosao . explosion_anim ) + 400 elif state == EXPLODING : now = pygame . time . get_ticks () if now - explosion_tick > explosion_duration : if lives == 0 : state = DONE else : state = PLAYING player = Ship ( groups , assets ) all_sprites . add ( player ) # ----- Gera sa\u00eddas window . fill ( BLACK ) # Preenche com a cor branca window . blit ( assets [ BACKGROUND ], ( 0 , 0 )) # Desenhando meteoros all_sprites . draw ( window ) # Desenhando o score text_surface = assets [ SCORE_FONT ] . render ( \" {:08d} \" . format ( score ), True , YELLOW ) text_rect = text_surface . get_rect () text_rect . midtop = ( WIDTH / 2 , 10 ) window . blit ( text_surface , text_rect ) # Desenhando as vidas text_surface = assets [ SCORE_FONT ] . render ( chr ( 9829 ) * lives , True , RED ) text_rect = text_surface . get_rect () text_rect . bottomleft = ( 10 , HEIGHT - 10 ) window . blit ( text_surface , text_rect ) pygame . display . update () # Mostra o novo frame para o jogador sprites . py - defini\u00e7\u00e3o das classes do jogo; referencia/sprites.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 import random import pygame from config import WIDTH , HEIGHT , METEOR_WIDTH , METEOR_HEIGHT , SHIP_WIDTH , SHIP_HEIGHT from assets import SHIP_IMG , PEW_SOUND , METEOR_IMG , BULLET_IMG , EXPLOSION_ANIM class Ship ( pygame . sprite . Sprite ): def __init__ ( self , groups , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ SHIP_IMG ] self . mask = pygame . mask . from_surface ( self . image ) self . rect = self . image . get_rect () self . rect . centerx = WIDTH / 2 self . rect . bottom = HEIGHT - 10 self . speedx = 0 self . groups = groups self . assets = assets # S\u00f3 ser\u00e1 poss\u00edvel atirar uma vez a cada 500 milissegundos self . last_shot = pygame . time . get_ticks () self . shoot_ticks = 500 def update ( self ): # Atualiza\u00e7\u00e3o da posi\u00e7\u00e3o da nave self . rect . x += self . speedx # Mantem dentro da tela if self . rect . right > WIDTH : self . rect . right = WIDTH if self . rect . left < 0 : self . rect . left = 0 def shoot ( self ): # Verifica se pode atirar now = pygame . time . get_ticks () # Verifica quantos ticks se passaram desde o \u00faltimo tiro. elapsed_ticks = now - self . last_shot # Se j\u00e1 pode atirar novamente... if elapsed_ticks > self . shoot_ticks : # Marca o tick da nova imagem. self . last_shot = now # A nova bala vai ser criada logo acima e no centro horizontal da nave new_bullet = Bullet ( self . assets , self . rect . top , self . rect . centerx ) self . groups [ 'all_sprites' ] . add ( new_bullet ) self . groups [ 'all_bullets' ] . add ( new_bullet ) self . assets [ PEW_SOUND ] . play () class Meteor ( pygame . sprite . Sprite ): def __init__ ( self , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ METEOR_IMG ] self . mask = pygame . mask . from_surface ( self . image ) self . rect = self . image . get_rect () self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) def update ( self ): # Atualizando a posi\u00e7\u00e3o do meteoro self . rect . x += self . speedx self . rect . y += self . speedy # Se o meteoro passar do final da tela, volta para cima e sorteia # novas posi\u00e7\u00f5es e velocidades if self . rect . top > HEIGHT or self . rect . right < 0 or self . rect . left > WIDTH : self . rect . x = random . randint ( 0 , WIDTH - METEOR_WIDTH ) self . rect . y = random . randint ( - 100 , - METEOR_HEIGHT ) self . speedx = random . randint ( - 3 , 3 ) self . speedy = random . randint ( 2 , 9 ) # Classe Bullet que representa os tiros class Bullet ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , assets , bottom , centerx ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) self . image = assets [ BULLET_IMG ] self . mask = pygame . mask . from_surface ( self . image ) self . rect = self . image . get_rect () # Coloca no lugar inicial definido em x, y do constutor self . rect . centerx = centerx self . rect . bottom = bottom self . speedy = - 10 # Velocidade fixa para cima def update ( self ): # A bala s\u00f3 se move no eixo y self . rect . y += self . speedy # Se o tiro passar do inicio da tela, morre. if self . rect . bottom < 0 : self . kill () # Classe que representa uma explos\u00e3o de meteoro class Explosion ( pygame . sprite . Sprite ): # Construtor da classe. def __init__ ( self , center , assets ): # Construtor da classe m\u00e3e (Sprite). pygame . sprite . Sprite . __init__ ( self ) # Armazena a anima\u00e7\u00e3o de explos\u00e3o self . explosion_anim = assets [ EXPLOSION_ANIM ] # Inicia o processo de anima\u00e7\u00e3o colocando a primeira imagem na tela. self . frame = 0 # Armazena o \u00edndice atual na anima\u00e7\u00e3o self . image = self . explosion_anim [ self . frame ] # Pega a primeira imagem self . rect = self . image . get_rect () self . rect . center = center # Posiciona o centro da imagem # Guarda o tick da primeira imagem, ou seja, o momento em que a imagem foi mostrada self . last_update = pygame . time . get_ticks () # Controle de ticks de anima\u00e7\u00e3o: troca de imagem a cada self.frame_ticks milissegundos. # Quando pygame.time.get_ticks() - self.last_update > self.frame_ticks a # pr\u00f3xima imagem da anima\u00e7\u00e3o ser\u00e1 mostrada self . frame_ticks = 50 def update ( self ): # Verifica o tick atual. now = pygame . time . get_ticks () # Verifica quantos ticks se passaram desde a ultima mudan\u00e7a de frame. elapsed_ticks = now - self . last_update # Se j\u00e1 est\u00e1 na hora de mudar de imagem... if elapsed_ticks > self . frame_ticks : # Marca o tick da nova imagem. self . last_update = now # Avan\u00e7a um quadro. self . frame += 1 # Verifica se j\u00e1 chegou no final da anima\u00e7\u00e3o. if self . frame == len ( self . explosion_anim ): # Se sim, tchau explos\u00e3o! self . kill () else : # Se ainda n\u00e3o chegou ao fim da explos\u00e3o, troca de imagem. center = self . rect . center self . image = self . explosion_anim [ self . frame ] self . rect = self . image . get_rect () self . rect . center = center assets . py - fun\u00e7\u00e3o de carregamento de assets do jogo; referencia/assets.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import pygame import os from config import METEOR_WIDTH , METEOR_HEIGHT , SHIP_WIDTH , SHIP_HEIGHT , IMG_DIR , SND_DIR , FNT_DIR BACKGROUND = 'background' METEOR_IMG = 'meteor_img' METEOR_IMG = 'meteor_img' SHIP_IMG = 'ship_img' SHIP_IMG = 'ship_img' BULLET_IMG = 'bullet_img' EXPLOSION_ANIM = 'explosion_anim' SCORE_FONT = 'score_font' BOOM_SOUND = 'boom_sound' DESTROY_SOUND = 'destroy_sound' PEW_SOUND = 'pew_sound' def load_assets (): assets = {} assets [ BACKGROUND ] = pygame . image . load ( os . path . join ( IMG_DIR , 'starfield.png' )) . convert () assets [ METEOR_IMG ] = pygame . image . load ( os . path . join ( IMG_DIR , 'meteorBrown_med1.png' )) . convert_alpha () assets [ METEOR_IMG ] = pygame . transform . scale ( assets [ 'meteor_img' ], ( METEOR_WIDTH , METEOR_HEIGHT )) assets [ SHIP_IMG ] = pygame . image . load ( os . path . join ( IMG_DIR , 'playerShip1_orange.png' )) . convert_alpha () assets [ SHIP_IMG ] = pygame . transform . scale ( assets [ 'ship_img' ], ( SHIP_WIDTH , SHIP_HEIGHT )) assets [ BULLET_IMG ] = pygame . image . load ( os . path . join ( IMG_DIR , 'laserRed16.png' )) . convert_alpha () explosion_anim = [] for i in range ( 9 ): # Os arquivos de anima\u00e7\u00e3o s\u00e3o numerados de 00 a 08 filename = os . path . join ( IMG_DIR , 'regularExplosion0 {} .png' . format ( i )) img = pygame . image . load ( filename ) . convert () img = pygame . transform . scale ( img , ( 32 , 32 )) explosion_anim . append ( img ) assets [ EXPLOSION_ANIM ] = explosion_anim assets [ SCORE_FONT ] = pygame . font . Font ( os . path . join ( FNT_DIR , 'PressStart2P.ttf' ), 28 ) # Carrega os sons do jogo pygame . mixer . music . load ( os . path . join ( SND_DIR , 'tgfcoder-FrozenJam-SeamlessLoop.ogg' )) pygame . mixer . music . set_volume ( 0.4 ) assets [ BOOM_SOUND ] = pygame . mixer . Sound ( os . path . join ( SND_DIR , 'expl3.wav' )) assets [ DESTROY_SOUND ] = pygame . mixer . Sound ( os . path . join ( SND_DIR , 'expl6.wav' )) assets [ PEW_SOUND ] = pygame . mixer . Sound ( os . path . join ( SND_DIR , 'pew.wav' )) return assets config . py - constantes. referencia/config.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from os import path # Estabelece a pasta que contem as figuras e sons. IMG_DIR = path . join ( path . dirname ( __file__ ), 'assets' , 'img' ) SND_DIR = path . join ( path . dirname ( __file__ ), 'assets' , 'snd' ) FNT_DIR = path . join ( path . dirname ( __file__ ), 'assets' , 'font' ) # Dados gerais do jogo. WIDTH = 480 # Largura da tela HEIGHT = 600 # Altura da tela FPS = 60 # Frames por segundo # Define tamanhos METEOR_WIDTH = 50 METEOR_HEIGHT = 38 SHIP_WIDTH = 50 SHIP_HEIGHT = 38 # Define algumas vari\u00e1veis com as cores b\u00e1sicas WHITE = ( 255 , 255 , 255 ) BLACK = ( 0 , 0 , 0 ) RED = ( 255 , 0 , 0 ) GREEN = ( 0 , 255 , 0 ) BLUE = ( 0 , 0 , 255 ) YELLOW = ( 255 , 255 , 0 ) # Estados para controle do fluxo da aplica\u00e7\u00e3o INIT = 0 GAME = 1 QUIT = 2 Lembra quando precisamos de uma fun\u00e7\u00e3o da biblioteca de matem\u00e1tica e damos um import math ? Quando queremos utilizar um valor ou fun\u00e7\u00e3o que foi definida em outro arquivo tamb\u00e9m usamos o import . Essa divis\u00e3o em arquivos facilita o desenvolvimento concorrente do jogo pelos membros da equipe.","title":"Separando o c\u00f3digo em arquivos diferentes"},{"location":"aulas/10-pygame/#adicionando-uma-tela-inicial","text":"Essa refatora\u00e7\u00e3o toda n\u00e3o foi em v\u00e3o. No jogo_v22 . py vemos como essa refatora\u00e7\u00e3o ajudou a desenvolver uma nova tela de jogo! Vemos tamb\u00e9m o truque da m\u00e1quina de estados para organizar a aplica\u00e7\u00e3o principal. Agora n\u00e3o temos muitas, linhas, mas as mudan\u00e7as est\u00e3o nas linhas 17 a 24. referencia/jogo_v22.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # ===== Inicializa\u00e7\u00e3o ===== # ----- Importa e inicia pacotes import pygame import random from config import WIDTH , HEIGHT , INIT , GAME , QUIT from init_screen import init_screen from game_screen import game_screen pygame . init () pygame . mixer . init () # ----- Gera tela principal window = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( 'Navinha' ) state = INIT while state != QUIT : if state == INIT : state = init_screen ( window ) elif state == GAME : state = game_screen ( window ) else : state = QUIT # ===== Finaliza\u00e7\u00e3o ===== pygame . quit () # Fun\u00e7\u00e3o do PyGame que finaliza os recursos utilizados","title":"Adicionando uma tela inicial"},{"location":"aulas/10-pygame/#exercicio-19","text":"Modifique o jogo_v22 . py para adicionar uma tela de game over.","title":"EXERC\u00cdCIO 19"},{"location":"aulas/10-pygame/#referencias","text":"https://www.pygame.org/docs/ http://kidscancode.org/blog/2016/08/pygame_shmup_part_1/","title":"Refer\u00eancias"},{"location":"dicas/buscando-ajuda/","text":"Buscando Ajuda \u00b6 Em programa\u00e7\u00e3o \u00e9 muito importante saber buscar informa\u00e7\u00f5es. Buscar a forma correta de se utilizar um comando, descobrir quais s\u00e3o as possibilidades oferecidas por uma determinada biblioteca, ou mesmo procurar ideias de como resolver um problema. Existem tantas possibilidades que mesmo programadores experientes precisam procurar informa\u00e7\u00f5es na internet em alguns momentos. Li\u00e7\u00e3o n\u00famero um: n\u00e3o tenha vergonha de procurar respostas na internet. Mais do que isso, precisamos desenvolver estrat\u00e9gias eficientes para buscar essas informa\u00e7\u00f5es. Quais fontes s\u00e3o confi\u00e1veis? Que termos devemos utilizar nas buscas? Algumas das respostas s\u00e3o aprendidas com a experi\u00eancia, mas a seguir fornecemos uma pequena lista de possibilidades de onde procurar informa\u00e7\u00f5es. Documenta\u00e7\u00e3o \u00b6 A documenta\u00e7\u00e3o da linguagem Python possui diversos recursos para programadores de todos os n\u00edveis. Muitas vezes quando procuramos por fun\u00e7\u00f5es ou operadores mais b\u00e1sicos da linguagem na internet o link da documenta\u00e7\u00e3o ( https://docs.python.org/3/ ) aparece como uma das primeiras respostas. Procure dar prioridade para essa resposta, pois ser\u00e1 mais confi\u00e1vel. Importante A vers\u00e3o atual do Python \u00e9 o Python 3. Existe muito material na internet referente \u00e0 vers\u00e3o Python 2. Mesmo quando for entrar no link da documenta\u00e7\u00e3o, certifique-se de que est\u00e1 acessando a documenta\u00e7\u00e3o do Python 3 ( https://docs.python.org/3/ ) e n\u00e3o do Python 2 ( https://docs.python.org/2/ ). A documenta\u00e7\u00e3o tamb\u00e9m pode ser acessada pelo terminal. Para isso, digite o comando python no terminal para entrar no modo interativo do Python e ent\u00e3o digite o comando help() para entrar no modo de documenta\u00e7\u00e3o. Nesse modo voc\u00ea pode digitar o nome de um comando ou m\u00f3dulo para ler a sua documenta\u00e7\u00e3o. StackOverflow \u00b6 O StackOverflow \u00e9 um site que agrega perguntas e respostas relacionadas a programa\u00e7\u00e3o. Muitas das respostas de buscas na internet relacionadas a programa\u00e7\u00e3o acabam caindo em algum link desse site. Importante Nem todas as respostas encontradas no StackOverflow s\u00e3o confi\u00e1veis. \u00c9 importante aprender a identificar se uma resposta \u00e9 confi\u00e1vel ou n\u00e3o. Algumas dicas para verificar respostas do StackOverflow: Teste o c\u00f3digo: se voc\u00ea est\u00e1 procurando por uma resposta que \u00e9 um trecho de c\u00f3digo, voc\u00ea pode test\u00e1-lo em seu pr\u00f3prio programa para ver se ele funciona. Se ele n\u00e3o funcionar j\u00e1 \u00e9 um bom ind\u00edcio de que n\u00e3o \u00e9 o que voc\u00ea estava procurando. Mas mesmo se ele funcionar, isso n\u00e3o quer dizer que foi uma boa resposta. Verifique os pontos a seguir. Verifique qual foi a resposta aceita: ao lado das respostas \u00e9 poss\u00edvel visualizar qual foi a resposta aceita e quantos votos ela recebeu. No exemplo abaixo vemos que a resposta foi aceita como correta e recebeu 4310 votos positivos (ambos indicados do lado esquerdo). Verifique a reputa\u00e7\u00e3o do autor da resposta: os pontos de reputa\u00e7\u00e3o n\u00e3o s\u00e3o um fator definitivo. \u00c9 poss\u00edvel que pessoas com poucos pontos de reputa\u00e7\u00e3o d\u00eaem a resposta exata para o seu problema ou pessoas com muitos pontos de reputa\u00e7\u00e3o d\u00eaem uma resposta errada ou desatualizada. De qualquer forma, se a pessoa que respondeu a pergunta possui muitos pontos de reputa\u00e7\u00e3o \u00e9 um bom sinal de que a resposta pode ser confi\u00e1vel. No exemplo acima o autor possui 56,9 mil pontos de reputa\u00e7\u00e3o e a pessoa que editou a resposta, 23,1 mil (ambos s\u00e3o relativamente altos). Outros recursos online \u00b6 Existem diversos recursos gratuitos dispon\u00edveis na internet para aprender Python. Aqui apresentamos alguns que podem ser \u00fateis: Cursos online \u00b6 Enthought Academic: https://www.enthought.com/ Codecademy: http://www.codecademy.com/en/tracks/python Learn Python: https://learnpython.trinket.io/ Learn Python (o nome \u00e9 o mesmo, mas \u00e9 outro site): https://www.learnpython.org/ Mais exerc\u00edcios \u00b6 Codewars: https://www.codewars.com/collections/basic-python Project Euler (desafios matem\u00e1ticos para serem resolvidos com programa\u00e7\u00e3o): https://projecteuler.net/ Olimp\u00edada Brasileira de Inform\u00e1tica: https://olimpiada.ic.unicamp.br/pratique/","title":"Buscando Ajuda"},{"location":"dicas/buscando-ajuda/#buscando-ajuda","text":"Em programa\u00e7\u00e3o \u00e9 muito importante saber buscar informa\u00e7\u00f5es. Buscar a forma correta de se utilizar um comando, descobrir quais s\u00e3o as possibilidades oferecidas por uma determinada biblioteca, ou mesmo procurar ideias de como resolver um problema. Existem tantas possibilidades que mesmo programadores experientes precisam procurar informa\u00e7\u00f5es na internet em alguns momentos. Li\u00e7\u00e3o n\u00famero um: n\u00e3o tenha vergonha de procurar respostas na internet. Mais do que isso, precisamos desenvolver estrat\u00e9gias eficientes para buscar essas informa\u00e7\u00f5es. Quais fontes s\u00e3o confi\u00e1veis? Que termos devemos utilizar nas buscas? Algumas das respostas s\u00e3o aprendidas com a experi\u00eancia, mas a seguir fornecemos uma pequena lista de possibilidades de onde procurar informa\u00e7\u00f5es.","title":"Buscando Ajuda"},{"location":"dicas/buscando-ajuda/#documentacao","text":"A documenta\u00e7\u00e3o da linguagem Python possui diversos recursos para programadores de todos os n\u00edveis. Muitas vezes quando procuramos por fun\u00e7\u00f5es ou operadores mais b\u00e1sicos da linguagem na internet o link da documenta\u00e7\u00e3o ( https://docs.python.org/3/ ) aparece como uma das primeiras respostas. Procure dar prioridade para essa resposta, pois ser\u00e1 mais confi\u00e1vel. Importante A vers\u00e3o atual do Python \u00e9 o Python 3. Existe muito material na internet referente \u00e0 vers\u00e3o Python 2. Mesmo quando for entrar no link da documenta\u00e7\u00e3o, certifique-se de que est\u00e1 acessando a documenta\u00e7\u00e3o do Python 3 ( https://docs.python.org/3/ ) e n\u00e3o do Python 2 ( https://docs.python.org/2/ ). A documenta\u00e7\u00e3o tamb\u00e9m pode ser acessada pelo terminal. Para isso, digite o comando python no terminal para entrar no modo interativo do Python e ent\u00e3o digite o comando help() para entrar no modo de documenta\u00e7\u00e3o. Nesse modo voc\u00ea pode digitar o nome de um comando ou m\u00f3dulo para ler a sua documenta\u00e7\u00e3o.","title":"Documenta\u00e7\u00e3o"},{"location":"dicas/buscando-ajuda/#stackoverflow","text":"O StackOverflow \u00e9 um site que agrega perguntas e respostas relacionadas a programa\u00e7\u00e3o. Muitas das respostas de buscas na internet relacionadas a programa\u00e7\u00e3o acabam caindo em algum link desse site. Importante Nem todas as respostas encontradas no StackOverflow s\u00e3o confi\u00e1veis. \u00c9 importante aprender a identificar se uma resposta \u00e9 confi\u00e1vel ou n\u00e3o. Algumas dicas para verificar respostas do StackOverflow: Teste o c\u00f3digo: se voc\u00ea est\u00e1 procurando por uma resposta que \u00e9 um trecho de c\u00f3digo, voc\u00ea pode test\u00e1-lo em seu pr\u00f3prio programa para ver se ele funciona. Se ele n\u00e3o funcionar j\u00e1 \u00e9 um bom ind\u00edcio de que n\u00e3o \u00e9 o que voc\u00ea estava procurando. Mas mesmo se ele funcionar, isso n\u00e3o quer dizer que foi uma boa resposta. Verifique os pontos a seguir. Verifique qual foi a resposta aceita: ao lado das respostas \u00e9 poss\u00edvel visualizar qual foi a resposta aceita e quantos votos ela recebeu. No exemplo abaixo vemos que a resposta foi aceita como correta e recebeu 4310 votos positivos (ambos indicados do lado esquerdo). Verifique a reputa\u00e7\u00e3o do autor da resposta: os pontos de reputa\u00e7\u00e3o n\u00e3o s\u00e3o um fator definitivo. \u00c9 poss\u00edvel que pessoas com poucos pontos de reputa\u00e7\u00e3o d\u00eaem a resposta exata para o seu problema ou pessoas com muitos pontos de reputa\u00e7\u00e3o d\u00eaem uma resposta errada ou desatualizada. De qualquer forma, se a pessoa que respondeu a pergunta possui muitos pontos de reputa\u00e7\u00e3o \u00e9 um bom sinal de que a resposta pode ser confi\u00e1vel. No exemplo acima o autor possui 56,9 mil pontos de reputa\u00e7\u00e3o e a pessoa que editou a resposta, 23,1 mil (ambos s\u00e3o relativamente altos).","title":"StackOverflow"},{"location":"dicas/buscando-ajuda/#outros-recursos-online","text":"Existem diversos recursos gratuitos dispon\u00edveis na internet para aprender Python. Aqui apresentamos alguns que podem ser \u00fateis:","title":"Outros recursos online"},{"location":"dicas/buscando-ajuda/#cursos-online","text":"Enthought Academic: https://www.enthought.com/ Codecademy: http://www.codecademy.com/en/tracks/python Learn Python: https://learnpython.trinket.io/ Learn Python (o nome \u00e9 o mesmo, mas \u00e9 outro site): https://www.learnpython.org/","title":"Cursos online"},{"location":"dicas/buscando-ajuda/#mais-exercicios","text":"Codewars: https://www.codewars.com/collections/basic-python Project Euler (desafios matem\u00e1ticos para serem resolvidos com programa\u00e7\u00e3o): https://projecteuler.net/ Olimp\u00edada Brasileira de Inform\u00e1tica: https://olimpiada.ic.unicamp.br/pratique/","title":"Mais exerc\u00edcios"},{"location":"tutoriais/terminal-macos/","text":"Navegando Pelo Terminal (macOS) \u00b6 Voc\u00ea j\u00e1 deve ter visto em algum filme uma cena como a mostrada acima: um \"hacker\" digita comandos freneticamente em uma interface onde s\u00f3 aparecem comandos de texto inintelig\u00edveis at\u00e9 que magicamente ele obt\u00e9m os dados que todos julgavam ser imposs\u00edvel obter . Interfaces de linha de comando podem assustar um pouco no come\u00e7o, mas veremos que sabendo apenas 2 comandos j\u00e1 \u00e9 poss\u00edvel utiliz\u00e1-las para navegar pelos arquivos do computador. Talvez voc\u00ea nunca tenha aberto o terminal/console/prompt do seu computador, mas ele est\u00e1 ( e sempre esteve ) l\u00e1! Vamos come\u00e7ar abrindo o terminal no nosso computador. Abrindo o Terminal \u00b6 Aten\u00e7\u00e3o A partir deste ponto existem algumas diferen\u00e7as entre os sistemas operacionais. Este handout foi desenvolvido para usu\u00e1rios Mac OS X . Se voc\u00ea usa Windows, consulte o outro handout disponibilizado . Temos duas op\u00e7\u00f5es: Abra a pasta Applications , depois abra a pasta Utilities dentro dela e ent\u00e3o d\u00ea um duplo clique em Terminal ; Pressione Cmd + Space para lan\u00e7ar o Spotlight Search , digite Terminal e aperte Enter . N\u00e3o vamos entrar em detalhes por enquanto, mas tudo o que aparece antes do $ s\u00e3o informa\u00e7\u00f5es como: o nome do seu usu\u00e1rio, em que pasta voc\u00ea est\u00e1 atualmente. Por enquanto voc\u00ea s\u00f3 precisa saber que os comandos s\u00e3o digitados depois do $. O comando ls \u00b6 Vamos come\u00e7ar pelo comando ls . Digite ls e aperte a tecla Enter : O comando ls lista os arquivos e pastas presentes na pasta atual. Funciona mais ou menos assim: imagine que voc\u00ea \u00e9 um personagem de um jogo em uma sala (a pasta atual) com diversas informa\u00e7\u00f5es (arquivos) e algumas portas (outras pastas). Todos os comandos que voc\u00ea executar ser\u00e3o executados na pasta atual. Por enquanto, vamos considerar duas possibilidades de a\u00e7\u00e3o: Visualizar os arquivos dispon\u00edveis da pasta atual; Navegar para outra pasta. O comando ls realiza a primeira op\u00e7\u00e3o. Se voc\u00ea n\u00e3o mudou nenhuma configura\u00e7\u00e3o do terminal voc\u00ea sempre come\u00e7a na pasta do seu usu\u00e1rio (tamb\u00e9m conhecida como sua home e \u00e9 abreviada pelo s\u00edmbolo \" ~ \" no terminal). Para verificar que o comando listou os arquivos e pastas dispon\u00edveis, vamos abrir o Finder na mesma pasta: O comando cd \u00b6 Agora vamos tentar a segunda op\u00e7\u00e3o: navegar para outra pasta. Para isso usamos o comando cd . Ele deve ser seguido do nome da pasta. Vamos entrar na pasta insper listada acima. Para isso vamos usar o comando cd insper . Os arquivos no seu computador provavelmente ser\u00e3o diferentes dos arquivos deste exemplo. Os comandos executados anteriormente n\u00e3o s\u00e3o apagados. O comando cd n\u00e3o imprime nada no terminal. Esse \u00e9 o resultado esperado. Vamos visualizar o conte\u00fado da pasta insper . Para isso, mais uma vez usamos o comando ls : Vemos que essa pasta cont\u00e9m o arquivo calendario.txt e diversas pastas com nomes de disciplinas. Vamos entrar na pasta design-de-software . Mas antes disso, voc\u00ea notou que, na pasta atual, design-de-software \u00e9 a \u00fanica pasta que come\u00e7a com as letras des ? Al\u00e9m disso, o terminal acabou de listar as pastas, ent\u00e3o em teoria ele \"sabe\" quais s\u00e3o as pastas e arquivos dispon\u00edveis. N\u00e3o seria bom se eu pudesse escrever s\u00f3 o come\u00e7o do nome da pasta e o terminal j\u00e1 completasse com o resto? E sim, ele faz isso! Podemos, por exemplo, digitar somente cd des : Depois disso, ao apertar a tecla Tab , o terminal vai completar o comando com o resto do nome: No nosso exemplo, dentro da pasta design-de-software existe uma pasta aulas , que cont\u00e9m outras duas pastas aula01 e aula02 , que por sua vez cont\u00e9m 4 arquivos. Pode ser um pouco cansativo usar um comando separado para entrar em cada pasta, ainda mais se voc\u00ea j\u00e1 souber o caminho completo. Por isso, tamb\u00e9m podemos avan\u00e7ar mais de um n\u00edvel no comando cd , separando os nomes das pastas com uma barra ('/'): Para verificar que estamos no lugar certo vamos usar, mais uma vez, o comando ls : Finalmente, podemos tamb\u00e9m voltar para pastas acima da pasta atual. Para isso usamos o .. , que se refere \u00e0 pasta m\u00e3e. Por exemplo: Vemos que agora estamos na pasta aulas : Podemos tamb\u00e9m compor o .. no caminho de uma pasta. Por exemplo: ../.. s\u00e3o dois n\u00edveis acima da pasta atual. Assim, depois de executar cd ../.. vemos que estamos novamente na pasta insper :","title":"macOS"},{"location":"tutoriais/terminal-macos/#navegando-pelo-terminal-macos","text":"Voc\u00ea j\u00e1 deve ter visto em algum filme uma cena como a mostrada acima: um \"hacker\" digita comandos freneticamente em uma interface onde s\u00f3 aparecem comandos de texto inintelig\u00edveis at\u00e9 que magicamente ele obt\u00e9m os dados que todos julgavam ser imposs\u00edvel obter . Interfaces de linha de comando podem assustar um pouco no come\u00e7o, mas veremos que sabendo apenas 2 comandos j\u00e1 \u00e9 poss\u00edvel utiliz\u00e1-las para navegar pelos arquivos do computador. Talvez voc\u00ea nunca tenha aberto o terminal/console/prompt do seu computador, mas ele est\u00e1 ( e sempre esteve ) l\u00e1! Vamos come\u00e7ar abrindo o terminal no nosso computador.","title":"Navegando Pelo Terminal (macOS)"},{"location":"tutoriais/terminal-macos/#abrindo-o-terminal","text":"Aten\u00e7\u00e3o A partir deste ponto existem algumas diferen\u00e7as entre os sistemas operacionais. Este handout foi desenvolvido para usu\u00e1rios Mac OS X . Se voc\u00ea usa Windows, consulte o outro handout disponibilizado . Temos duas op\u00e7\u00f5es: Abra a pasta Applications , depois abra a pasta Utilities dentro dela e ent\u00e3o d\u00ea um duplo clique em Terminal ; Pressione Cmd + Space para lan\u00e7ar o Spotlight Search , digite Terminal e aperte Enter . N\u00e3o vamos entrar em detalhes por enquanto, mas tudo o que aparece antes do $ s\u00e3o informa\u00e7\u00f5es como: o nome do seu usu\u00e1rio, em que pasta voc\u00ea est\u00e1 atualmente. Por enquanto voc\u00ea s\u00f3 precisa saber que os comandos s\u00e3o digitados depois do $.","title":"Abrindo o Terminal"},{"location":"tutoriais/terminal-macos/#o-comando-ls","text":"Vamos come\u00e7ar pelo comando ls . Digite ls e aperte a tecla Enter : O comando ls lista os arquivos e pastas presentes na pasta atual. Funciona mais ou menos assim: imagine que voc\u00ea \u00e9 um personagem de um jogo em uma sala (a pasta atual) com diversas informa\u00e7\u00f5es (arquivos) e algumas portas (outras pastas). Todos os comandos que voc\u00ea executar ser\u00e3o executados na pasta atual. Por enquanto, vamos considerar duas possibilidades de a\u00e7\u00e3o: Visualizar os arquivos dispon\u00edveis da pasta atual; Navegar para outra pasta. O comando ls realiza a primeira op\u00e7\u00e3o. Se voc\u00ea n\u00e3o mudou nenhuma configura\u00e7\u00e3o do terminal voc\u00ea sempre come\u00e7a na pasta do seu usu\u00e1rio (tamb\u00e9m conhecida como sua home e \u00e9 abreviada pelo s\u00edmbolo \" ~ \" no terminal). Para verificar que o comando listou os arquivos e pastas dispon\u00edveis, vamos abrir o Finder na mesma pasta:","title":"O comando ls"},{"location":"tutoriais/terminal-macos/#o-comando-cd","text":"Agora vamos tentar a segunda op\u00e7\u00e3o: navegar para outra pasta. Para isso usamos o comando cd . Ele deve ser seguido do nome da pasta. Vamos entrar na pasta insper listada acima. Para isso vamos usar o comando cd insper . Os arquivos no seu computador provavelmente ser\u00e3o diferentes dos arquivos deste exemplo. Os comandos executados anteriormente n\u00e3o s\u00e3o apagados. O comando cd n\u00e3o imprime nada no terminal. Esse \u00e9 o resultado esperado. Vamos visualizar o conte\u00fado da pasta insper . Para isso, mais uma vez usamos o comando ls : Vemos que essa pasta cont\u00e9m o arquivo calendario.txt e diversas pastas com nomes de disciplinas. Vamos entrar na pasta design-de-software . Mas antes disso, voc\u00ea notou que, na pasta atual, design-de-software \u00e9 a \u00fanica pasta que come\u00e7a com as letras des ? Al\u00e9m disso, o terminal acabou de listar as pastas, ent\u00e3o em teoria ele \"sabe\" quais s\u00e3o as pastas e arquivos dispon\u00edveis. N\u00e3o seria bom se eu pudesse escrever s\u00f3 o come\u00e7o do nome da pasta e o terminal j\u00e1 completasse com o resto? E sim, ele faz isso! Podemos, por exemplo, digitar somente cd des : Depois disso, ao apertar a tecla Tab , o terminal vai completar o comando com o resto do nome: No nosso exemplo, dentro da pasta design-de-software existe uma pasta aulas , que cont\u00e9m outras duas pastas aula01 e aula02 , que por sua vez cont\u00e9m 4 arquivos. Pode ser um pouco cansativo usar um comando separado para entrar em cada pasta, ainda mais se voc\u00ea j\u00e1 souber o caminho completo. Por isso, tamb\u00e9m podemos avan\u00e7ar mais de um n\u00edvel no comando cd , separando os nomes das pastas com uma barra ('/'): Para verificar que estamos no lugar certo vamos usar, mais uma vez, o comando ls : Finalmente, podemos tamb\u00e9m voltar para pastas acima da pasta atual. Para isso usamos o .. , que se refere \u00e0 pasta m\u00e3e. Por exemplo: Vemos que agora estamos na pasta aulas : Podemos tamb\u00e9m compor o .. no caminho de uma pasta. Por exemplo: ../.. s\u00e3o dois n\u00edveis acima da pasta atual. Assim, depois de executar cd ../.. vemos que estamos novamente na pasta insper :","title":"O comando cd"},{"location":"tutoriais/terminal-win/","text":"Navegando Pelo Terminal (Windows) \u00b6 Voc\u00ea j\u00e1 deve ter visto em algum filme uma cena como a mostrada acima: um \"hacker\" digita comandos freneticamente em uma interface onde s\u00f3 aparecem comandos de texto inintelig\u00edveis at\u00e9 que magicamente ele obt\u00e9m os dados que todos julgavam ser imposs\u00edvel obter . Interfaces de linha de comando podem assustar um pouco no come\u00e7o, mas veremos que sabendo apenas 2 comandos j\u00e1 \u00e9 poss\u00edvel utiliz\u00e1-las para navegar pelos arquivos do computador. Talvez voc\u00ea nunca tenha aberto o terminal/console/prompt do seu computador, mas ele est\u00e1 ( e sempre esteve ) l\u00e1! Vamos come\u00e7ar abrindo o terminal no nosso computador. Abrindo o Terminal \u00b6 Aten\u00e7\u00e3o A partir deste ponto existem algumas diferen\u00e7as entre os sistemas operacionais. Este handout foi desenvolvido para usu\u00e1rios Windows . Se voc\u00ea usa Mac OS X, consulte o outro handout disponibilizado . No Windows, vamos utilizar uma vers\u00e3o alternativa do terminal chamada Anaconda Prompt. Ela foi instalada quando voc\u00ea instalou o Anaconda no seu computador. Para abrir o Anaconda Prompt clique em \"Digite aqui para pesquisar\" no canto inferior esquerdo (ou aperte a tecla Win ), digite \"anaconda prompt\" e aperte a tecla Enter ; N\u00e3o vamos entrar em detalhes, mas a principal informa\u00e7\u00e3o que aparece antes do > \u00e9 a sua pasta atual. Os comandos s\u00e3o digitados depois do > . O comando dir \u00b6 Vamos come\u00e7ar pelo comando dir . Digite dir e aperte a tecla Enter : O comando dir lista os arquivos e pastas presentes na pasta atual. Funciona mais ou menos assim: imagine que voc\u00ea \u00e9 um personagem de um jogo em uma sala (a pasta atual) com diversas informa\u00e7\u00f5es (arquivos) e algumas portas (outras pastas). Todos os comandos que voc\u00ea executar ser\u00e3o executados na pasta atual. Por enquanto, vamos considerar duas possibilidades de a\u00e7\u00e3o: Visualizar os arquivos dispon\u00edveis da pasta atual; Navegar para outra pasta. O comando dir realiza a primeira op\u00e7\u00e3o. Se voc\u00ea n\u00e3o mudou nenhuma configura\u00e7\u00e3o do terminal voc\u00ea sempre come\u00e7a na pasta do seu usu\u00e1rio (tamb\u00e9m conhecida como sua home ). Para verificar que o comando listou os arquivos e pastas dispon\u00edveis, vamos abrir o Explorador de Arquivos na mesma pasta: O comando cd \u00b6 Agora vamos tentar a segunda op\u00e7\u00e3o: navegar para outra pasta. Para isso usamos o comando cd . Ele deve ser seguido do nome da pasta. Vamos entrar na pasta insper listada acima. Para isso vamos usar o comando cd insper . Os arquivos no seu computador provavelmente ser\u00e3o diferentes dos arquivos deste exemplo. Os comandos executados anteriormente n\u00e3o s\u00e3o apagados. O comando cd n\u00e3o imprime nada no terminal. Esse \u00e9 o resultado esperado. Vamos visualizar o conte\u00fado da pasta insper . Para isso, mais uma vez usamos o comando dir : Vemos que essa pasta cont\u00e9m o arquivo calendario.txt e diversas pastas com nomes de disciplinas. Vamos entrar na pasta design-de-software . Mas antes disso, voc\u00ea notou que, na pasta atual, design-de-software \u00e9 a \u00fanica pasta que come\u00e7a com as letras des ? Al\u00e9m disso, o terminal acabou de listar as pastas, ent\u00e3o em teoria ele \"sabe\" quais s\u00e3o as pastas e arquivos dispon\u00edveis. N\u00e3o seria bom se eu pudesse escrever s\u00f3 o come\u00e7o do nome da pasta e o terminal j\u00e1 completasse com o resto? E sim, ele faz isso! Podemos, por exemplo, digitar somente cd des : Depois disso, ao apertar a tecla Tab , o terminal vai completar o comando com o resto do nome: No nosso exemplo, dentro da pasta design-de-software existe uma pasta aulas , que cont\u00e9m outras duas pastas aula01 e aula02 , que por sua vez cont\u00e9m 4 arquivos. Pode ser um pouco cansativo usar um comando separado para entrar em cada pasta, ainda mais se voc\u00ea j\u00e1 souber o caminho completo. Por isso, tamb\u00e9m podemos avan\u00e7ar mais de um n\u00edvel no comando cd , separando os nomes das pastas com uma barra invertida ('\\'): Para verificar que estamos no lugar certo vamos usar, mais uma vez, o comando dir : Finalmente, podemos tamb\u00e9m voltar para pastas acima da pasta atual. Para isso usamos o .. , que se refere \u00e0 pasta m\u00e3e. Por exemplo: Vemos que agora estamos na pasta aulas : Podemos tamb\u00e9m compor o .. no caminho de uma pasta. Por exemplo: ..\\.. s\u00e3o dois n\u00edveis acima da pasta atual. Assim, depois de executar cd ..\\.. vemos que estamos novamente na pasta insper .","title":"Windows"},{"location":"tutoriais/terminal-win/#navegando-pelo-terminal-windows","text":"Voc\u00ea j\u00e1 deve ter visto em algum filme uma cena como a mostrada acima: um \"hacker\" digita comandos freneticamente em uma interface onde s\u00f3 aparecem comandos de texto inintelig\u00edveis at\u00e9 que magicamente ele obt\u00e9m os dados que todos julgavam ser imposs\u00edvel obter . Interfaces de linha de comando podem assustar um pouco no come\u00e7o, mas veremos que sabendo apenas 2 comandos j\u00e1 \u00e9 poss\u00edvel utiliz\u00e1-las para navegar pelos arquivos do computador. Talvez voc\u00ea nunca tenha aberto o terminal/console/prompt do seu computador, mas ele est\u00e1 ( e sempre esteve ) l\u00e1! Vamos come\u00e7ar abrindo o terminal no nosso computador.","title":"Navegando Pelo Terminal (Windows)"},{"location":"tutoriais/terminal-win/#abrindo-o-terminal","text":"Aten\u00e7\u00e3o A partir deste ponto existem algumas diferen\u00e7as entre os sistemas operacionais. Este handout foi desenvolvido para usu\u00e1rios Windows . Se voc\u00ea usa Mac OS X, consulte o outro handout disponibilizado . No Windows, vamos utilizar uma vers\u00e3o alternativa do terminal chamada Anaconda Prompt. Ela foi instalada quando voc\u00ea instalou o Anaconda no seu computador. Para abrir o Anaconda Prompt clique em \"Digite aqui para pesquisar\" no canto inferior esquerdo (ou aperte a tecla Win ), digite \"anaconda prompt\" e aperte a tecla Enter ; N\u00e3o vamos entrar em detalhes, mas a principal informa\u00e7\u00e3o que aparece antes do > \u00e9 a sua pasta atual. Os comandos s\u00e3o digitados depois do > .","title":"Abrindo o Terminal"},{"location":"tutoriais/terminal-win/#o-comando-dir","text":"Vamos come\u00e7ar pelo comando dir . Digite dir e aperte a tecla Enter : O comando dir lista os arquivos e pastas presentes na pasta atual. Funciona mais ou menos assim: imagine que voc\u00ea \u00e9 um personagem de um jogo em uma sala (a pasta atual) com diversas informa\u00e7\u00f5es (arquivos) e algumas portas (outras pastas). Todos os comandos que voc\u00ea executar ser\u00e3o executados na pasta atual. Por enquanto, vamos considerar duas possibilidades de a\u00e7\u00e3o: Visualizar os arquivos dispon\u00edveis da pasta atual; Navegar para outra pasta. O comando dir realiza a primeira op\u00e7\u00e3o. Se voc\u00ea n\u00e3o mudou nenhuma configura\u00e7\u00e3o do terminal voc\u00ea sempre come\u00e7a na pasta do seu usu\u00e1rio (tamb\u00e9m conhecida como sua home ). Para verificar que o comando listou os arquivos e pastas dispon\u00edveis, vamos abrir o Explorador de Arquivos na mesma pasta:","title":"O comando dir"},{"location":"tutoriais/terminal-win/#o-comando-cd","text":"Agora vamos tentar a segunda op\u00e7\u00e3o: navegar para outra pasta. Para isso usamos o comando cd . Ele deve ser seguido do nome da pasta. Vamos entrar na pasta insper listada acima. Para isso vamos usar o comando cd insper . Os arquivos no seu computador provavelmente ser\u00e3o diferentes dos arquivos deste exemplo. Os comandos executados anteriormente n\u00e3o s\u00e3o apagados. O comando cd n\u00e3o imprime nada no terminal. Esse \u00e9 o resultado esperado. Vamos visualizar o conte\u00fado da pasta insper . Para isso, mais uma vez usamos o comando dir : Vemos que essa pasta cont\u00e9m o arquivo calendario.txt e diversas pastas com nomes de disciplinas. Vamos entrar na pasta design-de-software . Mas antes disso, voc\u00ea notou que, na pasta atual, design-de-software \u00e9 a \u00fanica pasta que come\u00e7a com as letras des ? Al\u00e9m disso, o terminal acabou de listar as pastas, ent\u00e3o em teoria ele \"sabe\" quais s\u00e3o as pastas e arquivos dispon\u00edveis. N\u00e3o seria bom se eu pudesse escrever s\u00f3 o come\u00e7o do nome da pasta e o terminal j\u00e1 completasse com o resto? E sim, ele faz isso! Podemos, por exemplo, digitar somente cd des : Depois disso, ao apertar a tecla Tab , o terminal vai completar o comando com o resto do nome: No nosso exemplo, dentro da pasta design-de-software existe uma pasta aulas , que cont\u00e9m outras duas pastas aula01 e aula02 , que por sua vez cont\u00e9m 4 arquivos. Pode ser um pouco cansativo usar um comando separado para entrar em cada pasta, ainda mais se voc\u00ea j\u00e1 souber o caminho completo. Por isso, tamb\u00e9m podemos avan\u00e7ar mais de um n\u00edvel no comando cd , separando os nomes das pastas com uma barra invertida ('\\'): Para verificar que estamos no lugar certo vamos usar, mais uma vez, o comando dir : Finalmente, podemos tamb\u00e9m voltar para pastas acima da pasta atual. Para isso usamos o .. , que se refere \u00e0 pasta m\u00e3e. Por exemplo: Vemos que agora estamos na pasta aulas : Podemos tamb\u00e9m compor o .. no caminho de uma pasta. Por exemplo: ..\\.. s\u00e3o dois n\u00edveis acima da pasta atual. Assim, depois de executar cd ..\\.. vemos que estamos novamente na pasta insper .","title":"O comando cd"}]}